<!DOCTYPE article
 PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2 20190208//EN" "JATS-archivearticle1.dtd">
<article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="preprint"><?all-math-mml yes?><?use-mml?><?origin ukpmcpa?><front><journal-meta><journal-id journal-id-type="nlm-ta">bioRxiv</journal-id><journal-title-group><journal-title>bioRxiv : the preprint server for biology</journal-title></journal-title-group><issn pub-type="ppub"/></journal-meta><article-meta><article-id pub-id-type="manuscript">EMS192531</article-id><article-id pub-id-type="doi">10.1101/2023.12.03.569785</article-id><article-id pub-id-type="archive">PPR768143</article-id><article-version-alternatives><article-version article-version-type="status">preprint</article-version><article-version article-version-type="number">1</article-version></article-version-alternatives><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>ConvexML: Scalable and accurate inference of single-cell chronograms from CRISPR/Cas9 lineage tracing data</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Prillo</surname><given-names>Sebastian</given-names></name><xref ref-type="aff" rid="A1">1</xref></contrib><contrib contrib-type="author"><name><surname>Ravoor</surname><given-names>Akshay</given-names></name><xref ref-type="aff" rid="A1">1</xref></contrib><contrib contrib-type="author"><name><surname>Yosef</surname><given-names>Nir</given-names></name><xref ref-type="aff" rid="A1">1</xref><xref ref-type="aff" rid="A2">2</xref><xref ref-type="corresp" rid="CR1">*</xref></contrib><contrib contrib-type="author"><name><surname>Song</surname><given-names>Yun S.</given-names></name><xref ref-type="aff" rid="A1">1</xref><xref ref-type="aff" rid="A3">3</xref><xref ref-type="corresp" rid="CR1">*</xref></contrib><aff id="A1"><label>1</label>Computer Science Division, University of California, Berkeley</aff><aff id="A2"><label>2</label>Department of Systems Immunology, Weizmann Institute of Science</aff><aff id="A3"><label>3</label>Department of Statistics, University of California, Berkeley</aff></contrib-group><author-notes><corresp id="CR1"><label>*</label>To whom correspondence should be addressed: <email>niryosef@berkeley.edu</email>, <email>yss@berkeley.edu</email></corresp></author-notes><pub-date pub-type="nihms-submitted"><day>05</day><month>12</month><year>2023</year></pub-date><pub-date pub-type="preprint"><day>03</day><month>12</month><year>2023</year></pub-date><permissions><ali:free_to_read/><license><ali:license_ref>https://creativecommons.org/licenses/by-nc-nd/4.0/</ali:license_ref><license-p>This work is licensed under a <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0 International license</ext-link>.</license-p></license></permissions><abstract><p id="P1">CRISPR/Cas9 gene editing technology has enabled lineage tracing for thousands of cells <italic>in vivo</italic>. However, most of the analysis of CRISPR/Cas9 lineage tracing data has so far been limited to the reconstruction of single-cell tree <italic>topologies</italic>, which depict lineage relationships between cells, but not the amount of time that has passed between ancestral cell states and the present. Time-resolved trees, known as <italic>chronograms</italic>, would allow one to study the evolutionary dynamics of cell populations at an unprecedented level of resolution. Indeed, time-resolved trees would reveal the timing of events on the tree, the relative fitness of subclones, and the dynamics underlying phenotypic changes in the cell population – among other important applications. In this work, we introduce the first scalable and accurate method to refine any given single-cell tree topology into a single-cell chronogram by estimating its branch lengths. To do this, we leverage a statistical model of CRISPR/Cas9 cutting with missing data, paired with a conservative version of maximum parsimony that reconstructs only the ancestral states that we are confident about. As part of our method, we propose a novel approach to represent and handle missing data – specifically, double-resection events – which greatly simplifies and speeds up branch length estimation without compromising quality. All this leads to a convex maximum likelihood estimation (MLE) problem that can be readily solved in seconds with off-the-shelf convex optimization solvers. To stabilize estimates in low-information regimes, we propose a simple penalized version of MLE using a minimum branch length and pseudocounts. We benchmark our method using simulations and show that it performs well on several tasks, outperforming more naive baselines. Our method, which we name ‘ConvexML’, is available through the <monospace>cassiopeia</monospace> open source Python package.</p></abstract></article-meta></front><body><sec id="S1" sec-type="intro"><label>1</label><title>Introduction</title><p id="P2">Many important biological processes such as development, cancer progression and adaptive immunity unfold through time, originating from a small progenitor cell population and progressing through repeated cell division. A realization of these processes can be described by a single-cell <italic>chronogram</italic>: a rooted tree that represents the history of a clone, where each edge represents the lifetime of a cell, and internal nodes represent cell division events, as depicted in <xref ref-type="fig" rid="F1">Figure 1A</xref>. Single-cell chronograms thus capture the entire developmental history of the cell population, allowing us to understand when and how cells commit to their fates. Because of this, single-cell chronograms have been of interest for decades.</p><p id="P3">Almost 40 years ago, the first single-cell chronogram for the development of <italic>C. elegans</italic> was determined through visual observation over the timespan from zygote to hatched larva [<xref ref-type="bibr" rid="R3">3</xref>, <xref ref-type="bibr" rid="R4">4</xref>]. Since then, the advent of CRISPR/Cas9 genome editing and high-throughput single-cell sequencing technologies has enabled lineage tracing for thousands of cells <italic>in vivo</italic> [<xref ref-type="bibr" rid="R5">5</xref>, <xref ref-type="bibr" rid="R6">6</xref>, <xref ref-type="bibr" rid="R7">7</xref>, <xref ref-type="bibr" rid="R8">8</xref>, <xref ref-type="bibr" rid="R9">9</xref>, <xref ref-type="bibr" rid="R10">10</xref>]. However, unlike microscopy-based techniques, these approaches record lineage history indirectly through irreversible heritable Cas9 mutations – called <italic>indels</italic> – at engineered DNA <italic>target sites</italic>, as depicted in <xref ref-type="fig" rid="F1">Figure 1C</xref>. These target sites (or simply <italic>sites</italic>) are arranged into lineage tracing <italic>barcodes</italic> (or <italic>character arrays</italic>) that act as fake genes which mutate stochastically and are transcribed and measured through the transcriptome. <xref ref-type="fig" rid="F1">Figure 1D</xref> depicts the evolution and inheritance of CRISPR/Cas9 lineage tracing barcodes on a single-cell chronogram. Inferring a lineage tree from this CRISPR/Cas9 lineage tracing data is challenging, and has led to the development of many computational methods [<xref ref-type="bibr" rid="R2">2</xref>].</p><p id="P4">Single-cell chronograms provide a detailed account of the cell population’s history, revealing the timing of events on the tree, the relative fitness of subclones, and the dynamics underlying phenotypic changes in the cell population – among others, as depicted in <xref ref-type="fig" rid="F1">Figure 1F-H</xref>. This is in contrast to single-cell tree <italic>topologies</italic>, which are like single-cell chronograms except that they do not have branch lengths. Although single-cell tree topologies reveal the lineage relationships between cells, the lack of time resolution precludes them from tackling the aforementioned tasks.</p><p id="P5">Unfortunately, the task of estimating single-cell chronograms from CRISPR/Cas9 lineage tracing data is daunting, and methods developed so far have abandoned the hope of estimating single-cell chronograms to their full resolution. For one, only extant cells are sequenced, so it is not possible to pinpoint cell death events. Also, only a fraction of the cells in the population are sampled and sequenced, so one can only expect to estimate the single-cell chronogram <italic>induced</italic> by the sampled cells. Formally, the induced chronogram is defined as the subtree whose leaves are the sampled cells. For example, <xref ref-type="fig" rid="F1">Figure 1B</xref> illustrates the induced chronogram obtained by sampling cells A, D, G, J in the chronogram from <xref ref-type="fig" rid="F1">Figure 1A</xref>. Note that edges in the induced chronogram no longer map one-to-one to the lifetime of a cell; instead, they map one (edge)-to-many (cell lifetimes). Sampling cells greatly affects the distribution of branch lengths in the tree, as shown in <xref ref-type="supplementary-material" rid="SD1">Supplementary Figure S1</xref>. Most methods developed so far have not attempted to estimate branch lengths, opting instead to estimate just topologies [<xref ref-type="bibr" rid="R2">2</xref>], limiting their value.</p><p id="P6">The task of estimating single-cell chronograms is complicated by the fact that lineage tracing data are especially prone to go missing. There are three primary reasons for this. The first one is <italic>sequencing dropouts</italic>, whereby the limited capture efficiency of single-cell RNA-sequencing technologies leads to some barcodes not being sequenced. The second reason is heritable <italic>epigenetic silencing</italic> events. When this occurs, chromatin state is modified in such a way that a lineage tracing barcode is no longer transcribed and thus cannot be read out through the transcriptome. The third reason is <italic>double-resection</italic> events, wherein concurrent CRISPR/Cas9 cuts at proximal barcoding sites cause the flanked sites to get lost. Missing data from epigenetic silencing and double-resection events is inherited upon cell division. Double-resection events are particularly challenging to represent because they create an indel that spans multiple barcoding sites and introduce complex correlations between barcoding sites which complicate branch length estimation [<xref ref-type="bibr" rid="R11">11</xref>]. These three sources of missing data are illustrated in <xref ref-type="fig" rid="F1">Figure 1D</xref>; note specifically our choice of representation of double-resection events, which will turn out to be crucial for branch length estimation.</p><p id="P7">The estimation of time-resolved trees from molecular data has a rich history outside of single-cell lineage tracing. The field of Statistical Phylogenetics has studied the problem extensively, with the goal of estimating gene trees and species trees from multiple sequence alignments of DNA and amino-acid sequences. Popular software for reconstructing phylogenetic trees includes FastTree [<xref ref-type="bibr" rid="R12">12</xref>], PhyML [<xref ref-type="bibr" rid="R13">13</xref>], IQ-Tree [<xref ref-type="bibr" rid="R14">14</xref>] RAxML [<xref ref-type="bibr" rid="R15">15</xref>], and BEAST2 [<xref ref-type="bibr" rid="R16">16</xref>]. Unfortunately, these methods are not suitable for CRISPR/Cas9 lineage tracing data because (1) they were designed for small, finite state spaces such as the 20 amino acid alphabet, (2) they require a known substitution model which is usually assumed to be reversible, or (3) they have an elevated computational cost characteristic of Monte-Carlo Bayesian methods, forbidding them from scaling beyond a few hundred sequences. CRISPR/Cas9 lineage tracing datasets contain hundreds of unique states, an unknown substitution model which is irreversible, and hundreds to thousands of cells.</p><p id="P8">Although attempts have been made to adapt Statistical Phylogenetics models to CRISPR/Cas9 lineage tracing data, they still suffer from elevated computational costs. The recent work TiDeTree [<xref ref-type="bibr" rid="R17">17</xref>] implemented withing the BEAST2 platform [<xref ref-type="bibr" rid="R16">16</xref>] takes several hours to infer a chronogram for a tree with just 700 leaves. This comes from the need to run MCMC chains for inference. Similarly, the GAPML method [<xref ref-type="bibr" rid="R18">18</xref>] which was designed specifically for the GESTALT technology takes up to 2 hours on a tree with just 200 leaves. This comes from modeling the correlations between sites caused by double-resection events, and the cost of marginalizing out the character states of the ancestral (unobserved) cells - which we shall call the <italic>ancestral states</italic> for short. This calls for new methods that can improve the trade-off between computational efficiency and statistical efficiency.</p><p id="P9">In this work, we introduce the first scalable and accurate method to estimate single-cell chronograms from CRISPR/Cas9 lineage tracing data. Our approach is modular: we propose first estimating a single-cell topology using any of many available methods [<xref ref-type="bibr" rid="R1">1</xref>, <xref ref-type="bibr" rid="R2">2</xref>], and then refining it into a single-cell chronogram by estimating its branch lengths, as depicted in <xref ref-type="fig" rid="F1">Figure 1E</xref>. To estimate branch lengths, we leverage a statistical model for the CRISPR/Cas9 mutation process with missing data, and use a conservative version of maximum parsimony to reconstruct most – but not all – of the ancestral states, while still producing essentially unbiased estimates. We pay particular attention to double-resection events, and propose a novel representation and treatment that is well-suited to our model. Taken together, all this leads to a convex maximum likelihood estimation (MLE) problem that can be readily solved with off-the-shelf convex optimization solvers. Because lineage tracing data can be of varying quality, we propose the use of a penalized version of MLE using a minimum branch length and pseudocounts. Our method typically takes only a few seconds to estimate branch lengths for a tree topology with 400 leaves using a single CPU core.</p><p id="P10">We develop a benchmarking suite with three tasks to asses the performance of single-cell chronogram estimation methods: (1) estimation of the times of the internal nodes in the tree, (2) estimation of the number of ancestral lineages halfway (time-wise) through the experiment, and (3) fitness estimation. We show that our method performs well on these tasks, outperforming more naive baselines. We also compare our method’s performance against that of an ‘oracle’ model that has access to the ground truth ancestral states and show that it has comparable performance. In contrast, naively employing maximum parsimony leads to biased branch length estimates. This validates the suitability of conservative maximum parsimony for CRISPR/Cas9 lineage tracing data, a key methodological innovation of our work which underlies our scalability. Similarly, we show the suitability of our novel representation of missing data, specifically that concerning double-resection events. To finish, we discuss some of the many extensions of our method that are made possible by its simplicity. We name our method ‘ConvexML’ and make it available through the <monospace>cassiopeia</monospace> open source Python package.</p></sec><sec id="S2" sec-type="methods"><label>2</label><title>Methods</title><sec id="S3"><label>2.1</label><title>A Statistical Model for CRISPR/Cas9 Lineage Tracing Data</title><p id="P11">We start by describing how the CRISPR/Cas9 lineage tracing data are represented (or <italic>encoded</italic>). Let <italic>n</italic> be the number of cells assayed and let <italic>k</italic> be the number of lineage tracing sites or characters. The observed lineage tracing data – called the <italic>character matrix</italic> – is represented as a matrix <italic>X</italic> of size <italic>n</italic> × <italic>k</italic> with integer entries. The <italic>i</italic>-th row of <italic>X</italic> represents the observed character states of the <italic>i</italic>-th cell. The character states are grouped consecutively into <italic>barcodes</italic> of a known fixed size. Each non-missing entry of the character matrix represents an indel - an insertion or deletion of nucleotides at the given site. Indels are represented with distinct positive integers, and 0 is used to represent the uncut state. The integer − 1 is used to represent missing data. <xref ref-type="fig" rid="F1">Figure 1D</xref> illustrates the use of this notation. Of particular interest is our representation of double-resection events, which we shall discuss shortly. Our statistical model defines a probability distribution over <italic>X</italic>, and we shall subsequently use maximum likelihood estimation (MLE) to estimate branch lengths.</p><sec id="S4"><title>Data generation process</title><p id="P12">To define our statistical model for the data <italic>X</italic>, we will define the data generating process in two steps. In the first step, lineage tracing data is generated <italic>without any missingness</italic>, which we call <italic>Z</italic>. In other words, we pretend that there are no sequencing dropouts, epigenetic silencing, nor double-resection events. In the second step, we <italic>retrospectively</italic> analyze the data <italic>Z</italic> and determine what entries <italic>R should have gone missing</italic>, thus obtaining <italic>X</italic>. We will formalize this two-step process below, but it is an important conceptual leap because by decoupling the missing data mechanism from the CRISPR/Cas9 mutation process, the distribution of <italic>Z</italic> is easier to analyze since independence between sites holds, whereas this is <bold>not</bold> true for <italic>X</italic>. Indeed, sequencing dropouts, epigenetic silencing and double-resections all create correlations between different sites of <italic>X</italic>, since if there is a − 1 in some site of a barcode, a − 1 is more likely to also be present in an adjacent site of the barcode, as seen in <xref ref-type="fig" rid="F1">Figure 1D</xref>.</p><p id="P13">To provide intuition for how this two-step process works, it is instructive to consider a simpler statistical model: one in which we roll <italic>n</italic> dice, and each die roll has a probability <italic>ϕ</italic> of being made to go missing. There are two equivalent ways to model this: in the first way, <italic>before</italic> rolling a die, we decide whether it will go missing. If so, we do not roll the die. In the second way, we first roll <italic>all</italic> the dice, obtaining die rolls <italic>Z</italic>, and <italic>afterward</italic> determine which die rolls to hide (by replacing their values with − 1) to obtain the observed data <italic>X</italic>. Both models are equivalent in that they induce the same probability distribution for the observed data <italic>X</italic>. However, the second approach is richer because it provides us with extra random variables in <italic>Z</italic> – essentially, counterfactuals for the values of the missing entries. This way of thinking is convenient for analyzing CRISPR/Cas9 lineage tracing data, as it simplifies the mathematical derivation of the MLE.</p></sec><sec id="S5"><title>Statistical model</title><p id="P14">Let us thus formally define the statistical model for CRISPR/Cas9 lineage tracing data <italic>X</italic>. We start by defining a model for <italic>Z</italic> – the process <italic>without</italic> missing data. Let 𝒯 be the given single-cell tree topology over the <italic>n</italic> cells – that is to say, a leaf-labeled, rooted tree whose leaves correspond to the <italic>n</italic> cells. The model is parameterized by branch lengths <inline-formula><mml:math id="M1"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:msubsup></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> for 𝒯; here <italic>m</italic> is the number of edges of 𝒯. Let 𝒯<sub><italic>l</italic></sub> be the single-cell chronogram obtained by assigning the branch lengths <italic>l</italic> to 𝒯. The generative model for <italic>Z</italic> is as follows:</p><p id="P15"><list list-type="order" id="L1"><list-item><p id="P16">The <italic>k</italic> sites are independent and identically distributed.</p></list-item><list-item><p id="P17">Each site evolves down the tree 𝒯<sub><italic>l</italic></sub> following a continuous-time Markov chain defined as follows:</p><p id="P18"><list list-type="alpha-lower" id="L2"><list-item><p id="P19">Each site starts uncut at the root (in state 0).</p></list-item><list-item><p id="P20">CRISPR/Cas9 cuts each site with a rate of <italic>c</italic>, where <italic>c</italic> is a nuisance parameter.</p></list-item><list-item><p id="P21">When a site is cut, it takes on state <italic>s</italic> ∈ ℕ = {1, 2, 3, …} with probability <italic>q</italic><sub><italic>s</italic></sub> ≥ 0, where <italic>q</italic> is nuisance probability distribution over ℕ.</p></list-item><list-item><p id="P22">Once a state is cut, it can no longer be cut again.</p></list-item></list></p></list-item></list></p><p id="P23">We denote by <italic>θ</italic> = (<italic>l, c, q</italic>) the full set of model parameters including the nuisance parameters. By the end of the process we obtain <italic>Z</italic>, the states for all the leaves in the tree. More generally, the process described so far defines a statistical model 𝒫 = {<italic>p</italic><sub><italic>θ</italic></sub>} for lineage tracing data representing the character states for <italic>all</italic> the nodes in the tree 𝒯; we denote these data by <inline-formula><mml:math id="M2"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula>, which is a random matrix of size <inline-formula><mml:math id="M3"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>n</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> × <italic>k</italic> where <inline-formula><mml:math id="M4"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>n</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> is the number of nodes in 𝒯 (including internal nodes).</p></sec><sec id="S6"><title>Missing data</title><p id="P24">The final step is to model the missing data mechanism occurring over the tree, which explains how to obtain <italic>X</italic> from <italic>Z</italic>. For this, following [<xref ref-type="bibr" rid="R19">19</xref>], let <inline-formula><mml:math id="M5"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> be the binary response/missingness mask matrix of size <inline-formula><mml:math id="M6"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>n</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> × <italic>k</italic> indicating which entries of <inline-formula><mml:math id="M7"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> ought to (not) go missing (with <inline-formula><mml:math id="M8"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> for missingness and <inline-formula><mml:math id="M9"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> for response). Given <inline-formula><mml:math id="M10"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> and <inline-formula><mml:math id="M11"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula>, the actual data generated by the process at all nodes of the tree, which we denote as <inline-formula><mml:math id="M12"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>X</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula>, is: <disp-formula id="FD1"><mml:math id="M13"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msub><mml:mrow><mml:mover><mml:mi>X</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mtd><mml:mtd><mml:mtext> if </mml:mtext><mml:msub><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mtd><mml:mtd><mml:mtext> if </mml:mtext><mml:msub><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p id="P25">The subset of <inline-formula><mml:math id="M14"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>X</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> corresponding to the leaf nodes is then <italic>X</italic> – what we observe and were looking to model. We need to specify how <inline-formula><mml:math id="M15"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> is jointly distributed with <inline-formula><mml:math id="M16"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula>. We will take a very general approach of Mealli and Rubin [<xref ref-type="bibr" rid="R20">20</xref>], and assume that missing data is <italic>missing always completely at random</italic> (MACAR), meaning the missing data mask <inline-formula><mml:math id="M17"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> is independent from the lineage tracing data <inline-formula><mml:math id="M18"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula>. Formally, we assume a joint factorization <inline-formula><mml:math id="M19"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mtext>mis</mml:mtext></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>θ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>ϕ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> where <italic>ϕ</italic> are the parameters of the missing data mechanism (such as the sequencing dropout probability, epigenetic silencing rate, or temporal proximity of cuts required to induce a double-resection). However, we assume nothing else about the distribution <inline-formula><mml:math id="M20"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msub><mml:mi>g</mml:mi><mml:mi>ϕ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> meaning that we take a non-parametric approach to missing data. In particular, the entries of the missing data mask <inline-formula><mml:math id="M21"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> may be correlated, as in sequencing dropouts, epigenetic silencing and double-resection events. Lastly, we will assume that <italic>ϕ</italic> and <italic>θ</italic> are <italic>distinct</italic>, meaning that the value of <italic>θ</italic> puts no constrains on the value of <italic>ϕ</italic> and vice versa; formally (<italic>θ, ϕ</italic>) ∈ Θ × Φ for some sets Θ and Φ. The MACAR and distinctness assumptions are together called <italic>ignorability</italic> of the missing data mechanism, and are crucial for justifying maximum likelihood estimation with missing data [<xref ref-type="bibr" rid="R20">20</xref>], as we will do shortly.</p></sec><sec id="S7"><title>Modeling double-resections</title><p id="P26">An important use of ignorable missing data is to model double-resection events. Biologically, in a double-resection event, two sites <italic>i</italic> and <italic>j</italic> in the same barcode are cut close in time, resulting in the whole segment of sites between <italic>i</italic> and <italic>j</italic> to disappear, and a shared indel to be created spanning all sites <italic>i</italic> through <italic>j</italic>. Double-resection events are quite common and can be identified from the sequencing reads. Just like epigenetic silencing events, double-resection events are heritable. Prior work has chosen to represent double-resection events using complex indel states called ‘indel tracts’ [<xref ref-type="bibr" rid="R18">18</xref>]. Unfortunately, this substantially complicates branch length estimation since complex correlations between barcoding sites need to be modeled. Instead, we propose a novel representation of double-resections which is computationally tractable and does not compromise the quality of branch length estimates. Mathematically, we choose to model double-resection events via an ignorable missing data mechanism, as follows: if concurrent cuts at sites <italic>i</italic> and <italic>j</italic> cause a double-resection, then sites <italic>i</italic> + 1 through <italic>j</italic> − 1 inclusive become ignorable missing data, as illustrated in <xref ref-type="fig" rid="F1">Figure 1D</xref>. Note that sites <italic>i</italic> + 1 through <italic>j</italic> − 1 could have had mutations after the double-resection event in a reality with no missing data; these are precisely the counterfactuals modeled by <inline-formula><mml:math id="M22"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula>. We choose not to model the fact that the indel created at sites <italic>i</italic> and <italic>j</italic> is shared; instead, we just retain the indels created by the model without missing data, i.e. two independent indels drawn from <italic>q</italic> as if double-resections did not exist in the first place. As we will show later in a targeted experiment, this representation and treatment of double-resection events leads to accurate branch length estimates.</p><p id="P27">We have now defined a statistical model <inline-formula><mml:math id="M23"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msup><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mrow><mml:mtext>(mis) </mml:mtext></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mtext>mis </mml:mtext></mml:mrow></mml:msubsup><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> for the lineage tracing data <italic>X</italic> with missingness. The full list of random variables defined is outlined in <xref ref-type="table" rid="T1">Table 1</xref>. We now proceed to discuss how this statistical model for <italic>X</italic> aligns with the biology behind the CRISPR/Cas9 lineage tracing assay, and how it is misspecified.</p></sec><sec id="S8"><title>Discussion of model assumptions</title><p id="P28">First, let us discuss the assumption that the sites in <inline-formula><mml:math id="M24"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> are independent. Since we choose to model sequencing dropouts, epigenetic silencing and double-resection events as missing data mechanisms, the missing data they introduce do not violate the independence of sites in <inline-formula><mml:math id="M25"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> (instead, it is the sites in <inline-formula><mml:math id="M26"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>X</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> that are correlated). Secondly, CRISPR/Cas9 uses a different guide RNA sequence for each target site in a given barcode, so target sites within the same barcode evolve independently. Thirdly, barcodes are integrated randomly into the genome, so that they are far enough apart to interact with CRISPR/Cas9 independently. The only source of non-trivial model misspecification comes from our assumption that double-resections create two independent alleles at the two cut sites, when in fact the resulting indel should be shared and thus correlated, as seen in <xref ref-type="fig" rid="F1">Figure 1D</xref>. This independent treatment of correlated indels may seem inappropriate, but it can be viewed as a form of composite-likelihood, which in general is known to retain consistency for parameter estimation under weak assumptions [<xref ref-type="bibr" rid="R21">21</xref>, <xref ref-type="bibr" rid="R22">22</xref>]. As we show later, when paired with conservative maximum parsimony, our method can produce highly accurate estimates of branch length even with large double-resection events. Thus, overall, independence of sites in <inline-formula><mml:math id="M27"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> turns out to be a reasonable assumption for branch length estimation.</p><p id="P29">Now let us discuss the assumption that sites in <inline-formula><mml:math id="M28"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> are identically distributed. Due to the local state of chromatin, some lineage tracing barcodes might be more prone to CRISPR/Cas9 cutting than others, leading to different cut rates across sites. Site rate variation has received attention in the field of statistical phylogenetics, where it has led to the development of more sophisticated methods, such as [<xref ref-type="bibr" rid="R11">11</xref>, <xref ref-type="bibr" rid="R23">23</xref>, <xref ref-type="bibr" rid="R24">24</xref>]. However, models that assume equal rates across sites still perform well and have been used extensively, such as the seminal work of Whelan and Goldman [<xref ref-type="bibr" rid="R25">25</xref>]. Modeling site rate variation also leads to slower runtimes. Therefore, in this work we will assume that all sites are cut at the same (unknown) rate, leaving analysis of more sophisticated models for future work.</p><p id="P30">The Markov assumption governing site evolution is standard for analyzing molecular data, and is the workforce of Statistical Phylogenetics, enabling complex yet tractable statistical models. Hence, we adopt it in our work.</p><p id="P31">Regarding the ignorability of the missing data mechanism, we must consider the three different sources of missing data: sequencing dropouts, epigenetic silencing, and double-resections. Ignorability is true for sequencing dropouts, since all barcodes are equally likely to be dropped out during RNA-sequencing, regardless of their indel state, and the dropout probability is distinct from <italic>θ</italic>. Ignorability can also hold for epigenetic silencing. For example, suppose that barcodes get silenced at each node <italic>v</italic> of the tree 𝒯 with some probability <italic>ϕ</italic><sub><italic>v</italic></sub>. In this case, the parameter of the missing data mechanism would be the vector of probabilities <italic>ϕ</italic> of dimension <italic>ñ</italic>. It is distinct from <italic>θ</italic>, and <inline-formula><mml:math id="M29"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> is independent of <inline-formula><mml:math id="M30"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> for any <italic>θ, ϕ</italic>, so that ignorability holds. On the other hand, suppose that the probability of epigenetic silencing at node <italic>v</italic> of 𝒯<sub><italic>l</italic></sub> depends on the branch lengths, for example <italic>ϕ</italic><sub><italic>v</italic></sub> = 1− exp(− <italic>tη</italic>) where <italic>t</italic> is the distance from the parent of <italic>v</italic> to <italic>v</italic>, and <italic>η</italic> is a rate parameter. In this case, the epigenetic silencing mechanism is not ignorable because <italic>ϕ</italic> is not distinct from <italic>θ</italic>. For similar reasons, missing data created by double-resection events is generally not ignorable. However, because it hinders scalability and avoids imposing potentially-misspecified parametric assumptions on the epigenetic silencing mechanism and on double-resection events, we also assume they are ignorable. Any other missing data mechanisms, should they exist, are also treated as ignorable. As we show later, this ignorable model of missing data yields accurate branch lengths despite misspecification, showing its suitability.</p></sec></sec><sec id="S9"><label>2.2</label><title>Maximum Likelihood Estimation of Branch Lengths</title><p id="P32">Having defined a statistical model for lineage tracing data <italic>X</italic> and discussed the suitability of the modeling assumptions made, we proceed to show how to perform maximum likelihood estimation of branch lengths under this model. Crucially, we show how to deal with unobserved ancestral states, missing data, and the nuisance parameters <italic>c</italic> and <italic>q</italic>.</p><p id="P33">We first deal with unobserved ancestral states. Let <italic>x</italic> be the observed value of <italic>X</italic>. The maximum likelihood estimator of branch lengths is given by: <disp-formula id="FD2"><label>(1)</label><mml:math id="M31"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msub><mml:mrow><mml:mover><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:munder><mml:mrow><mml:mi>arg</mml:mi><mml:mo>⁡</mml:mo><mml:mo movablelimits="true">max</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mtext> ultrametric </mml:mtext></mml:mrow></mml:munder><mml:munder><mml:mo movablelimits="true">max</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi></mml:mrow></mml:munder><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">s</mml:mi></mml:mrow></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p id="P34">Here, <italic>ultrametric</italic> means that all leaves in the tree have the same distance from the root. This condition is imposed because all cells are sampled at the same time, but it is possible to relax this condition to account for temporal sampling of cells.</p><sec id="S10"><title>Unobserved ancestral states</title><p id="P35">To deal with unobserved ancestral states, we reconstruct most – but not all – of the ancestral states with a <italic>conservative</italic> version of maximum parsimony. Concretely, we only reconstruct ancestral states that are unambiguous under all maximum parsimony reconstructions consistent with the evolutionary process, as described in detail in <xref ref-type="supplementary-material" rid="SD1">Appendix B</xref>. In other words, we only reconstruct ancestral states which we are confident about. Ambiguous states are not reconstructed – represented with the new symbol <monospace>NONE</monospace> (not to be confused with the missing data state − 1) – and marginalized over by considering all possibilities, just like in an ignorable missing data mechanism. Intuitively, one can think about conservative maximum parsimony in terms of <italic>mutation mapping</italic>: we are trying to map each entry <italic>s &gt;</italic> 0 in the character matrix to exactly one edge in the tree (the edge on which said mutation was introduced); however, it is possible that an entry can be optimally mapped to more than one edge of the tree. In this case, the set of possible optimal edges will form a path. Since we do not know on which of those edges of the path the mutation happened, we do not reconstruct the state along the internal nodes of the whole path, using the symbol <monospace>NONE</monospace> instead. The state in nodes above the path is reconstructed as 0, and in nodes below the path as <italic>s</italic>. Concrete examples are shown in <xref ref-type="supplementary-material" rid="SD1">Figure S16</xref> and <xref ref-type="supplementary-material" rid="SD1">Figure S17</xref>.</p><p id="P36">Essentially, what we have is a missing data mechanism (with missing data state <monospace>NONE</monospace>) on top of the original missing data mechanism (with missing data state − 1). This is mathematically equivalent to a single ignorable missing data mechanism. Therefore, in what follows, we drop the <monospace>NONE</monospace> symbol and replace it with the missing data state − 1, which thus now stands for sequencing dropouts, heritable missing data, double-resection missing data, <italic>and</italic> ambiguous ancestral states. All this missing data are treated as ignorable and hence marginalized out during MLE.</p><p id="P37">As we show in Theorem 5, conservative maximum parsimony has the key property that missing data states − 1 can be marginalized out trivially. Importantly, the likelihood is essentially as easy to compute as if there were no missing data. Letting <inline-formula><mml:math id="M32"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> be the conservative maximum parsimony reconstruction of ancestral states (with <monospace>NONE</monospace> replaced by − 1 as discussed, since it is mathematically equivalent), the MLE amounts to: <disp-formula id="FD3"><label>(2)</label><mml:math id="M33"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msub><mml:mrow><mml:mover><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mtext>MLE </mml:mtext></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:munder><mml:mrow><mml:mi>arg</mml:mi><mml:mo>⁡</mml:mo><mml:mo movablelimits="true">max</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mtext> ultrametric </mml:mtext></mml:mrow></mml:munder><mml:munder><mml:mo movablelimits="true">max</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi></mml:mrow></mml:munder><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mi>mis</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>X</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p id="P38">We assume that the solution to the optimization problem <xref ref-type="disp-formula" rid="FD2">Eq. (1)</xref> is close to that of <xref ref-type="disp-formula" rid="FD3">Eq. (2)</xref>. This is a good assumption if the ancestral states in <inline-formula><mml:math id="M34"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> are correctly reconstructed, but otherwise risks biasing the MLE. As we demonstrate later through simulation in <xref ref-type="fig" rid="F3">Fig. 3</xref>, conservative maximum parsimony introduces essentially no bias, unlike naive maximum parsimony, and hence the reconstructions in <inline-formula><mml:math id="M35"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> are reliable.</p></sec><sec id="S11"><title>Missing data</title><p id="P39">We next deal with missing data. The theory for dealing with ignorable missing data is well established [<xref ref-type="bibr" rid="R26">26</xref>, <xref ref-type="bibr" rid="R20">20</xref>, <xref ref-type="bibr" rid="R19">19</xref>], but we reproduce the necessary derivations here for aself-contained exposition; the key result is that under ignorability, we can treat the non-missing entries of <inline-formula><mml:math id="M36"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>X</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> as having been sampled from their marginal distribution.</p><p id="P40">We start by defining <inline-formula><mml:math id="M37"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:msup><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mrow><mml:mover><mml:mi>n</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>×</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> to be the missing data mask corresponding to <inline-formula><mml:math id="M38"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula>. We will use the following notation:</p><p id="P41"><bold>Definition 1.</bold> Let <italic>a</italic> and <italic>b</italic> be matrices of the same dimensions, with <italic>b</italic> being binary. We denote by <italic>a</italic>[<italic>b</italic>] the vector obtained by concatenating the entries of <italic>a</italic> for which the corresponding entries in <italic>b</italic> equal 1. <italic>A</italic>[<italic>b</italic>] is similarly defined for a random matrix <italic>A</italic> of the same dimensions as <italic>b</italic>. We still index <italic>a</italic>[<italic>b</italic>] and <italic>A</italic>[<italic>b</italic>] as matrices for convenience, but it is important to note that they are just a <italic>subset</italic> of the matrix entries.</p><p id="P42">The following result establishes that we can ‘ignore’ missing data, as done in [<xref ref-type="bibr" rid="R26">26</xref>, <xref ref-type="bibr" rid="R19">19</xref>]:</p><p id="P43"><bold>Proposition 1.</bold> For all <inline-formula><mml:math id="M39"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> it holds that: <disp-formula id="FD4"><mml:math id="M40"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mi>mis</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>X</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>ϕ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>θ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p id="P44">Importantly, since <italic>ϕ</italic> is distinct from <italic>θ</italic>, then <italic>ϕ</italic> and <italic>θ</italic> can be optimized independently in <xref ref-type="disp-formula" rid="FD3">Eq. (2)</xref>. Therefore, the MLE reduces to: <disp-formula id="FD5"><label>(3)</label><mml:math id="M41"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msub><mml:mrow><mml:mover><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:munder><mml:mrow><mml:mi>arg</mml:mi><mml:mo>⁡</mml:mo><mml:mo movablelimits="true">max</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mtext> ultrametric </mml:mtext></mml:mrow></mml:munder><mml:munder><mml:mo movablelimits="true">max</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:munder><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>θ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p id="P45"><italic>Proof</italic>. We have <disp-formula id="FD6"><mml:math id="M42"><mml:mtable><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mi>mis</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>X</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mtext> is a function of </mml:mtext><mml:mrow><mml:mover><mml:mi>X</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">⟹=</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mi>mis</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>X</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mtext> (definition of </mml:mtext><mml:mrow><mml:mover><mml:mi>X</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">⟹=</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mi>mis</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mtext> (marginalize out missing data) </mml:mtext><mml:mo stretchy="false">⟹=</mml:mo><mml:munder><mml:mi>∑</mml:mi><mml:mi>y</mml:mi></mml:munder><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mi>mis</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mtext> (MACAR factorization) </mml:mtext><mml:mo stretchy="false">⟹=</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>ϕ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:munder><mml:mi>∑</mml:mi><mml:mi>y</mml:mi></mml:munder><mml:msub><mml:mi>p</mml:mi><mml:mi>θ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mtext> (marginalize out missing data) </mml:mtext><mml:mo stretchy="false">⟹=</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>ϕ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>θ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula> where <bold>1</bold> in lines 4 and 5 denotes an all-ones matrix of the same dimensions as <inline-formula><mml:math id="M43"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula>. □</p></sec><sec id="S12"><title>Nuisance parameters</title><p id="P46">Finally, it remains to deal with the nuisance parameters <italic>c</italic> and <italic>q</italic>. To do this, we first unclutter notation by using the standard notation <inline-formula><mml:math id="M44"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msup><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula>, and so on [<xref ref-type="bibr" rid="R20">20</xref>] (note that the dependence on <inline-formula><mml:math id="M45"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> is now implicit), using the superscript ‘1’ to subset the non-missing entries of the object. Let <italic>V</italic> be the vertex set of 𝒯, and <italic>E</italic> the edge set of 𝒯. Since 𝒯 is rooted, we give edges their natural orientation pointing away from the root. For a node <italic>v</italic> and site <italic>i</italic>, we denote by gpa<sub><italic>i</italic></sub>(<italic>v</italic>) the first ancestor of <italic>v</italic> which has a non-missing state at site <italic>i</italic> (read as ‘grandparent’). The log-probability in the MLE objective in <xref ref-type="disp-formula" rid="FD5">Eq. (3)</xref> is then given by <disp-formula id="FD7"><label>(4)</label><mml:math id="M46"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mrow/><mml:mstyle><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>θ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:munderover><mml:mi>∑</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>θ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>=</mml:mo><mml:munderover><mml:mi>∑</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>gpa</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>≠</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munder><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>θ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∣</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula> where the first equality follows from the independence of sites. The second equality requires using combinatorial properties of the conservative maximum parsimony reconstruction, and is proved in <xref ref-type="supplementary-material" rid="SD1">Theorem 5 in Appendix B</xref>. Finally, letting <italic>l</italic><sub><italic>uv</italic></sub> be the length of the path from <italic>u</italic> to <italic>v</italic> in the tree, we can compute the probability of an observed transition between nodes <italic>u</italic> → <italic>v</italic> where <italic>u</italic> = gpa<sub><italic>i</italic></sub>(<italic>v</italic>) as follows: <disp-formula id="FD8"><label>(5)</label><mml:math id="M47"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msub><mml:mi>p</mml:mi><mml:mi>θ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∣</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mtd><mml:mtd><mml:mtext> if </mml:mtext><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>exp</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mtd><mml:mtd><mml:mtext> if </mml:mtext><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>exp</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mtd><mml:mtd><mml:mtext> if </mml:mtext><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mtext> and </mml:mtext><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn><mml:mo>.</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mtext> otherwise. </mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p id="P47">Plugging this into <xref ref-type="disp-formula" rid="FD7">Eq. (4)</xref>, we arrive at <disp-formula id="FD9"><label>(6)</label><mml:math id="M48"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mrow/><mml:mstyle><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>θ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mi>∑</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover></mml:mstyle></mml:mtd><mml:mtd><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">p</mml:mi><mml:mi mathvariant="normal">a</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:munder><mml:mo>−</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mrow><mml:mo>+</mml:mo><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>gpa</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mtext> and </mml:mtext><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:munder><mml:mi>log</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>exp</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p id="P48">Note that in <xref ref-type="disp-formula" rid="FD9">Eq. (6)</xref>, the term log <inline-formula><mml:math id="M49"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msub><mml:mi>q</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> does not depend on <italic>l</italic>, so we can drop it from the objective function and hence, crucially, the MLE does not depend on <italic>q</italic>. To finish, let us denote by uncuts(<italic>u</italic> →<italic>v</italic>) and cuts(<italic>u</italic>→ <italic>v</italic>) the number of characters that go uncut and cut, respectively, on the path from (<italic>u, v</italic>). In other words, <disp-formula id="FD10"><mml:math id="M50"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mrow/><mml:mstyle/></mml:mtd><mml:mtd><mml:mi>uncuts</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="normal">#</mml:mi><mml:mo stretchy="false">{</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo>:</mml:mo><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>gpa</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mspace width="1em"/><mml:mi>cuts</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="normal">#</mml:mi><mml:mo stretchy="false">{</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo>:</mml:mo><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>gpa</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mtext> and </mml:mtext><mml:msub><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mo stretchy="false">}</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p id="P49">The MLE problem hence simplifies to <disp-formula id="FD11"><label>(7)</label><mml:math id="M51"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mrow/><mml:mstyle><mml:msub><mml:mrow><mml:mover><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mtext>MLE </mml:mtext></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:munder><mml:mrow><mml:mi>arg</mml:mi><mml:mo>⁡</mml:mo><mml:mo movablelimits="true">max</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mtext> ultrametric </mml:mtext></mml:mrow></mml:munder><mml:munder><mml:mo movablelimits="true">max</mml:mo><mml:mi>c</mml:mi></mml:munder><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:munder><mml:mo stretchy="false">[</mml:mo></mml:mstyle></mml:mtd><mml:mtd><mml:mo>−</mml:mo><mml:mi>uncuts</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mrow><mml:mo>+</mml:mo><mml:mi>cuts</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>log</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>exp</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p id="P50">Although the MLE no longer depends on <italic>q</italic>, it still depends on the nuisance parameter <italic>c</italic>. It is a well known fact that branch lengths <italic>l</italic> and cut rate parameter <italic>c</italic> are unidentifiable without further assumptions, since they can be scaled up and down by the same constant without changing the likelihood. To resolve this ambiguity, without loss of generality, we assume that the chronogram has depth exactly equal to 1, which is equivalent to assuming that without loss of generality the duration of the experiment is normalized to 1. In other words, we solve for: <disp-formula id="FD12"><label>(8)</label><mml:math id="M52"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mrow/><mml:mstyle><mml:msub><mml:mrow><mml:mover><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mtext>MLE </mml:mtext></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:munder><mml:mrow><mml:mi>arg</mml:mi><mml:mo>⁡</mml:mo><mml:mo movablelimits="true">max</mml:mo></mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>l</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mtext> ultrametric, </mml:mtext></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mtext> has depth </mml:mtext><mml:mn>1</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:munder><mml:munder><mml:mo movablelimits="true">max</mml:mo><mml:mi>c</mml:mi></mml:munder><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:munder><mml:mo stretchy="false">[</mml:mo></mml:mstyle></mml:mtd><mml:mtd><mml:mo>−</mml:mo><mml:mi>uncuts</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mrow><mml:mo>+</mml:mo><mml:mi>cuts</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>log</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>exp</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p id="P51">This is equivalent to solving the MLE problem in <xref ref-type="disp-formula" rid="FD11">Eq. (7)</xref> using a cut rate of <italic>c</italic> = 1, and afterwards scaling the chronogram to unit depth. Since the MLE problem in <xref ref-type="disp-formula" rid="FD11">Eq. (7)</xref> with <italic>c</italic> = 1 is an exponential cone program in the variables {<italic>l</italic><sub><italic>uv</italic></sub> : (<italic>u, v</italic>) ∈ <italic>E</italic>}, it can be readily solved with off-the-shelf convex optimization solvers. When we implement the method, we exclude any terms in the objective where uncuts(<italic>u</italic> → <italic>v</italic>) = 0 or cuts(<italic>u</italic> → <italic>v</italic>) = 0 since they do not contribute, leading to a computation graph which has size essentially <italic>O</italic>(<italic>n</italic>) rather than <italic>O</italic>(<italic>n</italic><sup>2</sup>) and thus leads to significantly faster runtime. This concludes optimization under the proposed model. In our implementation, for trees with 400 leaves and as many as 150 characters, the optimizer takes just a few seconds. In contrast, a method like TiDeTree takes several <italic>hours</italic> on a tree with 700 leaves [<xref ref-type="bibr" rid="R17">17</xref>]. We leverage the cvxpy Python library [<xref ref-type="bibr" rid="R27">27</xref>, <xref ref-type="bibr" rid="R28">28</xref>] and the ECOS [<xref ref-type="bibr" rid="R29">29</xref>] and SCS [<xref ref-type="bibr" rid="R30">30</xref>] solvers as the backend. We find that ECOS is faster but can sometimes fail, in which case we fallback to the slower but more robust SCS solver.</p></sec></sec><sec id="S13"><label>2.3</label><title>Regularizing the MLE</title><p id="P52">Due to limited lineage tracing capacity, it is not unusual for some cells in the population to have the exact same lineage tracing character states. When this happens, the single-cell tree topology will contain subtrees whose leaves all have the same character states. We call these <italic>homogeneous</italic> subtrees. As we show next, the MLE will estimate branch lengths of 0 for these subtrees. Moreover, the result is very general: it does not depend on whether ancestral states have been reconstructed with maximum parsimony or marginalized out, and it does not depend on the continuous-time Markov chain model. Concretely, we prove the following result:</p><p id="P53"><bold>Theorem 1</bold> (Homogeneous Proper Subtree Collapse). Consider any continuous-time Markov chain model (for example, the Jukes-Cantor model of DNA evolution, the WAG model of amino acid evolution [<xref ref-type="bibr" rid="R25">25</xref>], or the CRISPR/Cas9 lineage tracing model in this paper with fixed <italic>c, q</italic>). Let <italic>p</italic><sub><italic>l</italic></sub> be the associated probability measure when running this Markov chain on 𝒯<sub><italic>l</italic></sub>. Let 𝒮 be a proper subtree of 𝒯 (meaning that it is distinct from 𝒯). Let <italic>z</italic> be states for the leaves of the tree such that all <italic>leaves</italic> of 𝒮 have the same state, and let <inline-formula><mml:math id="M53"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> be a reconstruction of the ancestral states of <italic>z</italic> where all <italic>nodes</italic> of 𝒮 have the same state (as in a maximum parsimony reconstruction). Let <italic>l</italic> be any ultrametric branch lengths for 𝒯. Then there exist other ultrametric branch lengths <italic>l</italic><sup>′</sup> for 𝒯 that satisfy:</p><p id="P54"><list list-type="alpha-lower" id="L3"><list-item><p id="P55">All the branch lengths of 𝒮 are zero under <italic>l</italic><sup>′</sup>.</p></list-item><list-item><p id="P56"><inline-formula><mml:math id="M54"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msub><mml:mi>p</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:msup><mml:mi>l</mml:mi><mml:mrow><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mover><mml:mi>z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula></p></list-item><list-item><p id="P57">p<sub><italic>l</italic></sub>(<italic>Z</italic> = <italic>z</italic>) ≤ <italic>p</italic><sub><italic>l</italic></sub> (<italic>Z</italic> = <italic>z</italic>).</p></list-item></list></p><p id="P58"><italic>Proof</italic>. See <xref ref-type="supplementary-material" rid="SD1">Appendix A for a proof</xref>. The proof relies on a simple probabilistic coupling argument.</p><p id="P59">As a consequence, the MLE can always collapse homogeneous proper subtrees. We coin this phenomenon <italic>subtree collapse</italic>. More generally, we observed empirically that the MLE defined in <xref ref-type="disp-formula" rid="FD12">Eq. (8)</xref> tends to estimate many branch lengths as 0, a phenomenon which we coin <italic>edge collapse</italic>.</p><p id="P60">Subtree collapse, and more generally edge collapse, are undesirable because it suggests that some cells have divided arbitrarily fast. To address this issue, and more generally to make the MLE robust in low-information regimes where there is little information to support branch lengths, we propose to combine two simple regularizers. The first is to impose a minimum branch length <italic>ϵ</italic>. This can be easily accomplished by adding the minimum branch length constraint to the MLE optimization problem of <xref ref-type="disp-formula" rid="FD12">Eq. (8)</xref>. The second is to add pseudocounts to the data, in the form of <italic>λ</italic> cuts and <italic>λ</italic> uncuts per branch. This is like pretending that we have observed <italic>λ</italic> characters getting cut on each edge, as well as <italic>λ</italic> characters remaining uncut on that edge. Intuitively, this regularizes the branch lengths towards trees that look more neutrally evolving. This also has the benefit of making the optimization problem strongly convex, ensuring there is a unique solution. With this, our method falls into the category of penalized likelihood methods [<xref ref-type="bibr" rid="R31">31</xref>] like GAPML [<xref ref-type="bibr" rid="R18">18</xref>], where the MLE is stabilized with a regularizer to aid in low-information regimes. Other alternatives include Bayesian methods such as TiDeTree [<xref ref-type="bibr" rid="R17">17</xref>], but suffer from higher computational costs.</p><p id="P61">Incorporating our two regularizers to the optimization problem, we obtain: <disp-formula id="FD13"><label>(9)</label><mml:math id="M55"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mrow/><mml:mstyle><mml:msubsup><mml:mrow><mml:mover><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mtext>MLE </mml:mtext></mml:mrow><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi></mml:mrow></mml:msubsup><mml:mo>∈</mml:mo><mml:munder><mml:mrow><mml:mi>arg</mml:mi><mml:mo>⁡</mml:mo><mml:mo movablelimits="true">max</mml:mo></mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>l</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mtext> ultrametric, </mml:mtext></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mtext> has depth </mml:mtext><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:mi>ϵ</mml:mi><mml:mi mathvariant="normal">∀</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:munder><mml:munder><mml:mo movablelimits="true">max</mml:mo><mml:mi>c</mml:mi></mml:munder><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:munder><mml:mo stretchy="false">[</mml:mo></mml:mstyle></mml:mtd><mml:mtd><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>uncuts</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>λ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mrow><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>cuts</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>λ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>log</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>exp</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p id="P62">This is equivalent to solving the MLE problem <xref ref-type="disp-formula" rid="FD11">Eq. (7)</xref> while adding <italic>λ</italic> pseudocounts and imposing the constraints <italic>c</italic> = 1 and <italic>l</italic><sub><italic>uv</italic></sub> ≥<italic>ϵd</italic> ∀ (<italic>u, v</italic>) ∈ <italic>E</italic> where <italic>d</italic> is the depth of 𝒯<sub><italic>l</italic></sub>, and then finally normalizing the tree to have a depth of 1. This is still a convex optimization problem in the {<italic>l</italic><sub><italic>uv</italic></sub> : (<italic>u, v</italic>) ∈ <italic>E</italic>} variables and can thus still be solved easily with off-the-shelf convex optimization solvers.</p><p id="P63">The value of <italic>ϵ</italic> is interpretable and can thus be selected based on prior biological knowledge. Concretely, if the shortest amount of time that can pass between two consecutive cell division events is known to be approximately <italic>t</italic>, and if the length of the experiment is <italic>T</italic>, then <italic>ϵ</italic> can be set to <italic>t/T</italic>. Imposing a minimum branch length avoids edge collapse completely.</p><p id="P64">Pseudocounts are a popular regularization technique with the advantage that the regularization strength <italic>λ</italic> is interpretable in terms of a data perturbation. We explore using values of <italic>λ</italic> equal to 0 (no said regularization), 0.1 (small regularization) and 0.5 (large regularization). Note that pseudocounts do not guarantee that a minimum branch length is satisfied, which is why we use both forms of regularization.</p><p id="P65">Other regularization strategies are possible, such as the one used by GAPML [<xref ref-type="bibr" rid="R18">18</xref>] where large differences in branch lengths are discouraged via an ℓ<sub>2</sub> penalty in log-space. However, we use a minimum branch length and pseudocounts because their regularization strengths <italic>ϵ</italic> and <italic>λ</italic> are interpretable and thus easier to select without needing to perform an extensive grid search with cross-validation.</p></sec></sec><sec id="S14" sec-type="results"><label>3</label><title>Results</title><sec id="S15"><label>3.1</label><title>Benchmarked Models</title><p id="P66">We benchmark several models, including ablations, oracles, and baselines. First, we benchmark our MLE using ground truth ancestral states, conservative maximum parsimony, or naive maximum parsimony, which we denote as <inline-formula><mml:math id="M56"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msubsup><mml:mrow><mml:mover><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">G</mml:mi><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi></mml:mrow></mml:msubsup><mml:mo>+</mml:mo><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mover><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">P</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi></mml:mrow></mml:msubsup><mml:mo>+</mml:mo><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mover><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">P</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi></mml:mrow></mml:msubsup><mml:mo>+</mml:mo><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow><mml:mo>,</mml:mo></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> respectively. We set <italic>ϵ</italic> to a small value of <italic>ϵ</italic> = 0.01 and vary <italic>λ</italic> ∈{0, 0.1, 0.5}. The value of <italic>ϵ</italic> = 0.01 was chosen to mimic biological knowledge of minimum cell division times (and may vary depending on the application); <xref ref-type="supplementary-material" rid="SD1">Supplementary Figure S2</xref> shows that indeed <italic>ϵ</italic> = 0.01 is a reasonable lower bound on cell division times in our simulated trees.</p><p id="P67">Second, we also benchmark a baseline model <inline-formula><mml:math id="M57"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msub><mml:mrow><mml:mover><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mtext>Mutations </mml:mtext></mml:mrow></mml:msub></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> which sets each branch length to the number of mutations on the branch. This baseline shows what happens if we ignore the mutation model. To avoid assigning a length of zero to edges without mutations, we set their edge length to 0.5 instead. To make the tree ultrametric, we extend all tips to match the depth of the deepest leaf. Finally, we scale the tree to have a depth of 1. Analogously to the MLE, we benchmark three versions of this model: <inline-formula><mml:math id="M58"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msub><mml:mrow><mml:mover><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">G</mml:mi><mml:mi mathvariant="normal">T</mml:mi></mml:mrow><mml:mo>+</mml:mo><mml:mtext> Mutations </mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">P</mml:mi></mml:mrow><mml:mo>+</mml:mo><mml:mtext> Mutations </mml:mtext></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">P</mml:mi></mml:mrow><mml:mo>+</mml:mo><mml:mtext> Mutations </mml:mtext></mml:mrow></mml:msub></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> respectively. When using conservative maximum parsimony, mutations that are mapped to <italic>m</italic> edges are made to contribute 1<italic>/m</italic> mutations to each of those edges.</p></sec><sec id="S16"><label>3.2</label><title>Simulated Data Benchmark</title><sec id="S17"><title>Simulation steps</title><p id="P68">We evaluate the performance of the models on simulated data. Our simulations involve three steps: (1) simulating a ground truth single-cell chronogram, (2) simulating lineage tracing data on the chronogram, and (3) sampling leaves. Briefly, our ground truth single-cell chronograms are simulated under a birth-death process where the birth and death rates are allowed to change with certain probability at each cell division, allowing us to model changes in the fitness of subclones. The simulation ends when a specified population size is reached; if the whole population of cells dies, we retry. Our simulated lineage tracing assay controls the number of barcodes, the number of sites per barcode, the indel distribution, the CRISPR/Cas9 site-specific mutation rates, and the rates of epigenetic silencing and sequencing dropouts. Sampling leaves is done by specifying the number of sampled leaves.</p></sec><sec id="S18"><title>Evaluation tasks</title><p id="P69">Using our simulation framework, we set out to evaluate the performance of the different methods on several tasks, and across varying qualities of lineage tracing data. We considered the following three evaluation tasks and associated metrics:</p><p id="P70"><list list-type="order" id="L4"><list-item><p id="P71"><bold>”Internal node time” task:</bold> Mean absolute error at estimating the time of the internal nodes in the induced chronogram.</p></list-item><list-item><p id="P72"><bold>”Ancestral lineages” task:</bold> Relative error at estimating the number of ancestral lineages halfway (time-wise) through the induced chronogram.</p></list-item><list-item><p id="P73"><bold>”Fitness estimation” task:</bold> Spearman correlation at estimating the fitness of each sampled cell. The ground truth fitness of a cell is defined in our simulations as the difference between its birth and death rates. We use the Neher et al.’s LBI estimator [<xref ref-type="bibr" rid="R32">32</xref>] as implemented in the jungle package<sup><xref ref-type="fn" rid="FN1">1</xref></sup> to derive fitness estimates from our single-cell chronograms, as in the work of [<xref ref-type="bibr" rid="R33">33</xref>].</p></list-item></list></p></sec><sec id="S19"><title>Using reconstructed tree topology</title><p id="P74">Furthermore, since in real applications we do not have access to the ground truth single-cell tree topology, we also benchmark the performance of the branch length estimation methods when the tree topology must first be estimated. To do this, we first estimate the single-cell topology using the Maxcut solver based on Snir and Rao [<xref ref-type="bibr" rid="R34">34</xref>] from the <monospace>cassiopeia</monospace> package [<xref ref-type="bibr" rid="R1">1</xref>] – which is a supertree method based on triplets – and then apply the branch length estimator. We chose the Maxcut solver since it is a top performer at the triplets correct and Robinson-Foulds metric commonly used to evaluate topology reconstruction quality (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figure S3</xref>) and runs much faster than the ILP algorithm. We resolve multifurcations into binary splits using a Huffman-tree algorithm wherein subtrees with the least size are merged first. Since the ground truth topology and the reconstructed topology differ, the internal node time task becomes harder to evaluate. To resolve this discrepancy, we create estimates for the time of each internal node <italic>v</italic> in the ground truth tree by taking the mean time of the MRCA (most recent common ancestor) in the reconstructed tree of all pairs of leaves whose MRCA in the ground truth tree is <italic>v</italic>.</p></sec><sec id="S20"><title>Questions of interest</title><p id="P75">With our simulated data benchmark we seek to answer the following questions: (i) Does our method significantly outperform the naive baseline which estimates branch lengths as the number of mutations? (ii) How much does accuracy drop when the single-cell topology must be estimated first – as in real applications – as compared to when the ground truth topology is known? (iii) Does regularization stabilize branch length estimates, particularly in low-information regimes? (iv) Does conservative maximum parsimony provide accurate branch length estimates, as compared to naive maximum parsimony and to the oracle method which has access to ground truth ancestral states? (v) Similarly, does our treatment of double-resection event enable unbiased branch length estimates?</p></sec><sec id="S21"><title>Simulating chronograms</title><p id="P76">To answer the above questions, we perform the following simulations. We simulate 50 chronograms with 40,000 extant cells each, scaled to have a depth of exactly 1. We then sample exactly 400 leaves from each tree, thus achieving a sampling probability of 1%.</p><p id="P77">The simulation is performed using a birth-death process with rate variation to emulate fitness changes, and is described in detail in <xref ref-type="supplementary-material" rid="SD1">Appendix C</xref>. The resulting trees display nuanced fitness variation, as can be seen in <xref ref-type="supplementary-material" rid="SD1">Supplementary Figure S4</xref>, which shows 9 of our 50 ground truth induced chronograms.</p></sec><sec id="S22"><title>The default parameter regime</title><p id="P78">For each chronogram, we simulate a lineage tracing experiment with 13 barcodes and 3 target sites per barcode, for a total of 39 target sites; we choose 3 target sites per barcode based on the technology used in [<xref ref-type="bibr" rid="R10">10</xref>, <xref ref-type="bibr" rid="R35">35</xref>, <xref ref-type="bibr" rid="R33">33</xref>]. The per-site CRISPR/Cas9 mutation rates are splined from real data to achieve an expected 50% of mutated entries in the character matrix, and are shown in <xref ref-type="supplementary-material" rid="SD1">Supplementary Figure S5</xref>. We consider 100 possible indel states with a non-uniform probability distribution <italic>q</italic>, as in real data, such that some states are much more common than others. Concretely, the <italic>q</italic><sub><italic>s</italic></sub> are taken to be the quantiles of an exponential distribution with scale parameter 10<sup>−5</sup>. This non-uniform probability distribution is shown in <xref ref-type="supplementary-material" rid="SD1">Supplementary Figure S6</xref>. The indels are encoded as integers between 1 and 100 inclusive. We introduce sequencing dropouts and epigenetic silencing missing data mechanisms such that on average 20% of the character matrix is missing, with 10% arising from sequencing dropouts and 10% from epigenetic silencing. The missing data they introduce is represented with the integer − 1. Epigenetic silencing occurs similarly to CRISPR/Cas9 mutations, happening with a fixed rate during the whole length of the experiment (which as discussed before, is in fact <italic>not</italic> an ignorable missing data mechanism). Double-resections are also simulated; they occur whenever two sites in the same barcode are cut before a cell divides, as illustrated in <xref ref-type="fig" rid="F1">Figure 1D</xref>. When a double-resection event occurs at positions <italic>i</italic> and <italic>j</italic>, we create an identical indel at positions <italic>i</italic> and <italic>j</italic> with integer encoding 10<sup>8</sup> + 2<sup><italic>i</italic></sup> + 2<sup><italic>j</italic></sup> such that we can identify the endpoints of the double-resection as in real data; positions <italic>i</italic> + 1 through <italic>j</italic> − 1 go missing and are thus set to − 1. If more than two sites in a barcode are cut before the cell divides, <italic>i</italic> and <italic>j</italic> are taken to be the leftmost and rightmost of these sites in the barcode. We call the collection of all these lineage tracing parameters the ‘default’ lineage tracing parameter regime. The branch length estimation methods are then evaluated on the three benchmarking tasks described above using the 50 simulated trees.</p></sec><sec id="S23"><title>Varying parameters</title><p id="P79">We then proceed to repeat the benchmark, this time varying each of the lineage tracing parameters in turn. This allows us to explore lineage tracing datasets with varying levels of quality, as in real life. We vary the number of barcodes in the set {3, 6, 13, 20, 30, 50}, the expected proportion of mutated character matrix entries in the set {10%, 30%, 50%, 70%, 90%}, the number of possible indels in the set {5, 10, 25, 50, 100, 500, 1000}, and the expected missing data fraction in the set {10%, 20%, 30%, 40%, 50%, 60%}, always keeping the expected sequencing missing data fraction at 10%, and adjusting the expected heritable epigenetic missing data fraction accordingly.</p></sec><sec id="S24"><title>Assessing ancestral state reconstruction</title><p id="P80">To specifically analyze the bias of conservative maximum parsimony, we perform a second targeted experiment where we simulate a very large number of lineage tracing characters – 100,002 characters consisting of 33,334 barcodes of size 3 – on one of the previously described trees and then apply the MLE using either (i) ground truth ancestral states, (ii) conservative maximum parsimony, or (iii) naive (standard) maximum parsimony. It is the scalability of our method that allows us to perform such a large-scale experiment to analyze its bias. Since the state space size is crucial for parsimony methods, we vary the number of indel states in the set {1, 2, …, 9} ∪ {10, 20, …, 100}, so that in particular we explore a binary tracer with a unique indel state. Since missing data makes ancestral state reconstruction challenging, we use 60% expected missing data, with half coming from epigenetic silencing and the other half from sequencing dropouts. Since double-resection events indirectly increase the state space size (as they encode the indices of the outer sites), we initially exclude them from the experiment. Finally, unlike the default parameter regime, to ensure that the main source of model misspecification comes from the reconstruction of unobserved ancestral states, we use the same cut rate for all sites, thus excluding site rate variation from this specific experiment; the cut rate is chosen such that an observed entry of the character matrix has 50% change of being mutated.</p></sec><sec id="S25"><title>Assessing the effect of double-resections</title><p id="P81">To specifically explore the effect of double-resections, we repeat the previous experiment which has 100,002 characters but turning on double-resection events, which introduces more missing data but also indirectly increases the state space size. Moreover, to exacerbate the effect of double-resections, we perform a third version of the experiment where we not only simulate double-resections, but also increase the cassette size from 3 to 10 (while keeping the total number of characters controlled and equal to 100,000 by using 10,000 barcodes).</p></sec></sec><sec id="S26"><label>3.3</label><title>Performance Comparison</title><sec id="S27"><title>MLE outperforms the baseline estimator</title><p id="P82">The performance of each model on the default parameter regime, with and without access to the ground truth topology, is shown in <xref ref-type="fig" rid="F2">Figure 2</xref>. We can see that all variants of our MLE method outperform the baseline estimator. This pattern holds across all lineage tracing parameter regimes, shown in <xref ref-type="supplementary-material" rid="SD1">Supplementary Figures S7</xref>, <xref ref-type="supplementary-material" rid="SD1">S8</xref>, and <xref ref-type="supplementary-material" rid="SD1">S9</xref>.</p></sec><sec id="S28"><title>The effects of using reconstructed tree topologies</title><p id="P83">We find that using reconstructed single-cell tree topologies – as opposed to ground truth topologies – consistently degrades performance on the internal node time and fitness prediction tasks, as expected. On the ‘ancestral lineages’ task, however, this is not always the case. For example, on the default regime (<xref ref-type="fig" rid="F2">Figure 2</xref>) using a value of <italic>λ</italic> = 0.5 in our MLE leads to better performance with the reconstructed topology. We attribute this to the MLE being over-regularized and the bias introduced by regularization cancelling off with the bias of the topology reconstruction algorithm. The interaction between topology, branch length estimation procedure, and downstream metric is thus nuanced, and errors in the topology and branch length estimation steps can compound, or more interestingly, cancel each other.</p></sec><sec id="S29"><title>The effects of regularization</title><p id="P84">Using regularization improves performance most noticeably in low-information regimes such as when the amount of missing data increases, the expected proportion mutated decreases, or the number of lineage tracing barcodes decreases, as seen in <xref ref-type="supplementary-material" rid="SD1">Supplementary Figures S7</xref>, <xref ref-type="supplementary-material" rid="SD1">S8</xref>, and <xref ref-type="supplementary-material" rid="SD1">S9</xref>. This is expected since the purpose of regularization is precisely to stabilize branch length estimates in low-information regimes. Other than low-information regimes, the regularization strength <italic>λ</italic> makes the most difference on the ancestral lineages task, where a small amount of regularization <italic>λ</italic> = 0.1 provides the best results. Generally, using some level of regularization as opposed to none appears to be beneficial across the board.</p></sec><sec id="S30"><title>Conservative maximum parsimony vs. naive maximum parsimony</title><p id="P85">Conservative maximum parsimony tends to outperform naive maximum parsimony, the gap being most noticeable in high-information regimes such as when the number of lineage tracing barcodes is 50. This makes sense, as only at high sample sizes the risk of the estimator becomes dominated by the bias rather than by the variance. For the ‘internal node time’ task as we increase the number of barcodes, the performance of conservative maximum parsimony remains close to the performance of the oracle model with access to ground truth ancestral states. In contrast, the performance of naive maximum parsimony improves more slowly. For example, the performance of naive maximum parsimony with 50 barcodes is comparable to the performance of conservative maximum parsimony with just 30 barcodes.</p><p id="P86">In our second experiment, we dissected the bias of our conservative maximum parsimony approach by simulating a very large number of characters (100,002, as described in <xref ref-type="sec" rid="S16">Section 3.2</xref>) on one of our trees and evaluating the performance of the MLE when using either (i) ground truth ancestral states, (ii) conservative maximum parsimony, or (iii) naive maximum parsimony. In the first version of the experiment, we excluded double-resection events since they indirectly increase the state space size. The results are shown in <xref ref-type="fig" rid="F3">Figure 3</xref>. As the number of indel states increases, the bias of conservative maximum parsimony seems to converge to nearly 0 in a geometric fashion. The mean absolute error achieved is negligible when compared to the error for the default lineage tracing regime as seen in <xref ref-type="fig" rid="F2">Figure 2</xref>, which is at least 0.05. Naive maximum parsimony, on the other hand, shows large bias with a MAE of 0.06, which is comparable to the MAEs seen in <xref ref-type="fig" rid="F2">Figure 2</xref>. Since CRISPR/Cas9 lineage tracing systems are characterized by their large state space, this targeted experiment shows the suitability of conservative maximum parsimony for branch length estimation.</p></sec><sec id="S31"><title>The effect of double-resections</title><p id="P87">We finished by turning on double-resection events in our previous simulation with 100,002 characters. The results are shown in <xref ref-type="supplementary-material" rid="SD1">Supplementary Figure S10A</xref>. The indirectly increased state space size due to double-resections improves performance of our branch length estimator for a low number of states, while the misspecified treatment of double-resections minimally degrades performance for larger state space sizes. Increasing the barcode size from 3 to 10 while keeping the number of characters roughly the same magnifies these trends, as shown in <xref ref-type="supplementary-material" rid="SD1">Supplementary Figure S10B</xref>. Even with these barcodes of length 10, the error of conservative maximum parsimony remains close to 0 for large state space sizes. These results show that paired with conservative maximum parsimony, independent modelling of sites is accurate even in the presence of double-resection events – which is the key to the scalability of our method as compared to previous methods such as GAPML [<xref ref-type="bibr" rid="R18">18</xref>].</p><p id="P88">One may wonder what happens if one uses a different representation of double-resection events, e.g., if one encodes them by assigning the indel state to <italic>all</italic> sites <italic>i</italic> through <italic>j</italic>, instead of only to sites <italic>i</italic> and <italic>j</italic>; in <xref ref-type="fig" rid="F1">Figure 1D</xref>, this would mean assigning state 5 to sites 1, 2, and 3, instead of assigning state 5 to sites 1 and 3 and − 1 to site 2. This is the current preprocessing behaviour of the <monospace>Cassiopeia</monospace> package [<xref ref-type="bibr" rid="R1">1</xref>]. The results are shown in <xref ref-type="supplementary-material" rid="SD1">Supplementary Figure S11</xref>. As we can see, performance deteriorates dramatically, even for the model with ground truth ancestral states. Intuitively, our novel representation of ancestral states is effective because it entails exactly two cutting events, which is the correct number.</p></sec><sec id="S32"><title>Recommendation</title><p id="P89">Based on these results, our recommendation to practitioners is to use conservative maximum parsimony with the regularized MLE <inline-formula><mml:math id="M59"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:msubsup><mml:mrow><mml:mover><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mtext> MLE-Reg </mml:mtext></mml:mrow><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi></mml:mrow></mml:msubsup></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> setting <italic>ϵ</italic> to the best known lower bound on the minimum time between cell division events, and explore values of <italic>λ</italic> of 0.0, 0.1 and 0.5 as we did. For example, if cells are expected to take at least 1 day to divide and the experiment last 60 days, our recommendation would be to set the minimum branch length to <italic>ϵ</italic> = 1<italic>/</italic>60 ≈ 0.016. Character-level cross-validation is a promising avenue to automate the choice of <italic>λ</italic> (and even <italic>ϵ</italic>) and we leave it to future work. Double-resections should be encoded using our novel representation, with − 1 (i.e., missing data) at the internal sites of the double-resection, and the indel state duplicated at the flanking sites, as seen in <xref ref-type="fig" rid="F1">Figure 1D</xref>. To ensure that the indel state created by a double-resection event is distinct from any indel created by a standard single-site cut, we recommend using a modified encoding such as 10<sup>8</sup><italic>s</italic> + 2<sup><italic>i</italic></sup> + 2<sup><italic>j</italic></sup>, where <italic>s</italic> is the original encoding of the indel and <italic>i, j</italic> are the sites of the double-resection. (In particular, note that in our simulations from <xref ref-type="sec" rid="S16">Section 3.2</xref>, we are considering a worse-case scenario where only one indel state is possible during a double-resection.)</p></sec></sec></sec><sec id="S33" sec-type="discussion"><label>4</label><title>Discussion</title><p id="P90">In this work, we introduced the first scalable and accurate method to estimate branch lengths for single-cell tree topologies, refining them into single-cell chronograms. Specifically, we proposed using a regularized maximum likelihood estimator tailored to the CRISPR/Cas9 mutation process. Key to our approach is our treatment of missing data – particularly our representation of double-resection events – paired with our use of a conservative version of maximum parsimony to reconstruct only ancestral states which we are confident about. This simplifies the optimization problem considerably and without introducing the typical bias of maximum parsimony. Specifically, this leads to a convex optimization problem that can be solved in seconds with off-the-shelf convex optimization solvers. We proposed a simple regularization scheme based on a minimum branch length and pseudocounts to stabilize estimates in low-information regimes. We designed a synthetic benchmark with three task and showed that our method performs well on them, outperforming more naive baselines. We specifically showed the ability of our method to estimate branch lengths in an unbiased way even with large amounts of missing data and in the presence of large double-resection events. Finally, we commented on extensions of our method that are made easily available thanks to the convexity of our MLE. Our branch length estimator, which we title ‘ConvexML’, is implemented in the <monospace>cassiopeia</monospace> Python package which is publicly available, and the methods and simulation frameworks presented in this paper are also readily available.</p><p id="P91">The simplicity and scalability of our method enable numerous extensions, some of which we are currently pursuing. For instance, we are working on accounting for site rate variation (i.e., the fact that different target sites evolve at different rates) by allowing a different cut rate for each site; we expect that as lineage tracing technologies get better, site rate variation may become more and more relevant. The resulting optimization problem is essentially identical to the original one if the site-specific rates are known. If the site-specific rates are not known, they can be estimated using a simple coordinate ascent procedure wherein the branch lengths and site rates are optimized in turn. Another important extension is to estimate branch lengths for trees that are not ultrametric. This arises in applications where cells are sampled at different moments in time.</p><p id="P92">We also plan to explore the use of character-level cross-validation to automatically perform hyperparameter selection; although we aimed to make our hyperparameters as interpretable as possible, a cross-validation scheme would nonetheless decrease the burden on the user. Lastly, we look forward to leveraging our branch length estimator to infer the transcriptional dynamics of cell populations, a problem that is akin to learning amino acid substitution rate matrices and which has its own rich history in the field of statistical phylogenetics. By doing so, we seek to shed light into the transcriptional dynamics of cancer development; in this application, branch lengths are crucial to obtain good quantitative estimates.</p></sec><sec sec-type="supplementary-material" id="SM"><title>Supplementary Material</title><supplementary-material content-type="local-data" id="SD1"><label>Supplementary Figures and Appendices</label><media xlink:href="EMS192531-supplement-Supplementary_Figures_and_Appendices.pdf" mimetype="application" mime-subtype="pdf" id="d2aAdEbB" position="anchor"/></supplementary-material></sec></body><back><ack id="S34"><title>Acknowledgements</title><p>This research is supported in part by an NIH grant R56-HG013117 and the European Union Council (ERC, Tx-phylogeography, 101089213). Views and opinions expressed are however those of the authors only and do not necessarily reflect those of the European Union or the European Research Council Executive Agency. Neither the European Union nor the granting authority can be held responsible for them.</p></ack><fn-group><fn id="FN1"><label>1</label><p id="P93">Publicly available at <ext-link ext-link-type="uri" xlink:href="https://github.com/felixhorns/jungle">https://github.com/felixhorns/jungle</ext-link></p></fn></fn-group><ref-list><ref id="R1"><label>[1]</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Jones</surname><given-names>Matthew G</given-names></name><name><surname>Khodaverdian</surname><given-names>Alex</given-names></name><name><surname>Quinn</surname><given-names>Jeffrey J</given-names></name><name><surname>Chan</surname><given-names>Michelle M</given-names></name><name><surname>Hussmann</surname><given-names>Jeffrey A</given-names></name><name><surname>Wang</surname><given-names>Robert</given-names></name><name><surname>Xu</surname><given-names>Chenling</given-names></name><name><surname>Weissman</surname><given-names>Jonathan S</given-names></name><name><surname>Yosef</surname><given-names>Nir</given-names></name></person-group><chapter-title>Inference of single-cell phylogenies from lineage tracing data using cassiopeia</chapter-title><source>Genome Biology</source><year>2020</year><month>April</month><volume>21</volume><issue>1</issue><publisher-name>Publisher Copyright: © 2020 The Author(s)</publisher-name><pub-id pub-id-type="pmcid">PMC7155257</pub-id><pub-id pub-id-type="pmid">32290857</pub-id><pub-id pub-id-type="doi">10.1186/s13059-020-02000-8</pub-id></element-citation></ref><ref id="R2"><label>[2]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gong</surname><given-names>Wuming</given-names></name><name><surname>Granados</surname><given-names>Alejandro A</given-names></name><name><surname>Hu</surname><given-names>Jingyuan</given-names></name><name><surname>Jones</surname><given-names>Matthew G</given-names></name><name><surname>Raz</surname><given-names>Ofir</given-names></name><name><surname>Salvador-Martínez</surname><given-names>Irepan</given-names></name><name><surname>Zhang</surname><given-names>Hanrui</given-names></name><name><surname>Chow</surname><given-names>Ke-Huan K</given-names></name><name><surname>Kwak</surname><given-names>Il-Youp</given-names></name><name><surname>Retkute</surname><given-names>Renata</given-names></name><name><surname>Prusokas</surname><given-names>Alidivinas</given-names></name><etal/></person-group><article-title>Benchmarked approaches for reconstruction of in vitro cell lineages and in silico models of C elegans and M musculus developmental trees</article-title><source>Cell Systems</source><year>2021</year><volume>12</volume><issue>8</issue><fpage>810</fpage><lpage>826</lpage><pub-id pub-id-type="pmid">34146472</pub-id></element-citation></ref><ref id="R3"><label>[3]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sulston</surname><given-names>JE</given-names></name><name><surname>Schierenberg</surname><given-names>E</given-names></name><name><surname>White</surname><given-names>JG</given-names></name><name><surname>Thomson</surname><given-names>JN</given-names></name></person-group><article-title>The embryonic cell lineage of the nematode caenorhabditis elegans</article-title><source>Developmental Biology</source><year>1983</year><volume>100</volume><issue>1</issue><fpage>64</fpage><lpage>119</lpage><pub-id pub-id-type="pmid">6684600</pub-id></element-citation></ref><ref id="R4"><label>[4]</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Deppe</surname><given-names>U</given-names></name><name><surname>Schierenberg</surname><given-names>E</given-names></name><name><surname>Cole</surname><given-names>T</given-names></name><name><surname>Krieg</surname><given-names>C</given-names></name><name><surname>Schmitt</surname><given-names>D</given-names></name><name><surname>Yoder</surname><given-names>B</given-names></name><name><surname>von Ehrenstein</surname><given-names>G</given-names></name></person-group><source>Cell lineages of the embryo of the nematode caenorhabditis elegans</source><conf-name>Proceedings of the National Academy of Sciences</conf-name><year>1978</year><volume>75</volume><issue>1</issue><fpage>376</fpage><lpage>380</lpage></element-citation></ref><ref id="R5"><label>[5]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>McKenna</surname><given-names>Aaron</given-names></name><name><surname>Findlay</surname><given-names>Gregory M</given-names></name><name><surname>Gagnon</surname><given-names>James A</given-names></name><name><surname>Horwitz</surname><given-names>Marshall S</given-names></name><name><surname>Schier</surname><given-names>Alexander F</given-names></name><name><surname>Shendure</surname><given-names>Jay</given-names></name></person-group><article-title>Whole-organism lineage tracing by combinatorial and cumulative genome editing</article-title><source>Science</source><year>2016</year><volume>353</volume><issue>6298</issue><elocation-id>aaf7907</elocation-id><pub-id pub-id-type="pmcid">PMC4967023</pub-id><pub-id pub-id-type="pmid">27229144</pub-id><pub-id pub-id-type="doi">10.1126/science.aaf7907</pub-id></element-citation></ref><ref id="R6"><label>[6]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Raj</surname><given-names>Bushra</given-names></name><name><surname>Wagner</surname><given-names>Daniel E</given-names></name><name><surname>McKenna</surname><given-names>Aaron</given-names></name><name><surname>Pandey</surname><given-names>Shristi</given-names></name><name><surname>Klein</surname><given-names>Allon M</given-names></name><name><surname>Shendure</surname><given-names>Jay</given-names></name><name><surname>Gagnon</surname><given-names>James A</given-names></name><name><surname>Schier</surname><given-names>Alexander F</given-names></name></person-group><article-title>Simultaneous single-cell profiling of lineages and cell types in the vertebrate brain</article-title><source>Nature Biotechnology</source><year>2018</year><volume>36</volume><issue>5</issue><fpage>442</fpage><lpage>450</lpage><pub-id pub-id-type="pmcid">PMC5938111</pub-id><pub-id pub-id-type="pmid">29608178</pub-id><pub-id pub-id-type="doi">10.1038/nbt.4103</pub-id></element-citation></ref><ref id="R7"><label>[7]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Spanjaard</surname><given-names>Bastiaan</given-names></name><name><surname>Hu</surname><given-names>Bo</given-names></name><name><surname>Mitic</surname><given-names>Nina</given-names></name><name><surname>Olivares-Chauvet</surname><given-names>Pedro</given-names></name><name><surname>Janjuha</surname><given-names>Sharan</given-names></name><name><surname>Ninov</surname><given-names>Nikolay</given-names></name><name><surname>Junker</surname><given-names>Jan</given-names></name></person-group><article-title>Simultaneous lineage tracing and cell-type identification using crispr–cas9-induced genetic scars</article-title><source>Nature Biotechnology</source><year>2018</year><volume>36</volume><fpage>05</fpage><pub-id pub-id-type="pmcid">PMC5942543</pub-id><pub-id pub-id-type="pmid">29644996</pub-id><pub-id pub-id-type="doi">10.1038/nbt.4124</pub-id></element-citation></ref><ref id="R8"><label>[8]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wagner</surname><given-names>Daniel E</given-names></name><name><surname>Weinreb</surname><given-names>Caleb</given-names></name><name><surname>Collins</surname><given-names>Zach M</given-names></name><name><surname>Briggs</surname><given-names>James A</given-names></name><name><surname>Megason</surname><given-names>Sean G</given-names></name><name><surname>Klein</surname><given-names>Allon M</given-names></name></person-group><article-title>Single-cell mapping of gene expression landscapes and lineage in the zebrafish embryo</article-title><source>Science</source><year>2018</year><volume>360</volume><issue>6392</issue><fpage>981</fpage><lpage>987</lpage><pub-id pub-id-type="pmcid">PMC6083445</pub-id><pub-id pub-id-type="pmid">29700229</pub-id><pub-id pub-id-type="doi">10.1126/science.aar4362</pub-id></element-citation></ref><ref id="R9"><label>[9]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kalhor</surname><given-names>Reza</given-names></name><name><surname>Kalhor</surname><given-names>Kian</given-names></name><name><surname>Mejia</surname><given-names>Leo</given-names></name><name><surname>Leeper</surname><given-names>Kathleen</given-names></name><name><surname>Graveline</surname><given-names>Amanda</given-names></name><name><surname>Mali</surname><given-names>Prashant</given-names></name><name><surname>Church</surname><given-names>George M</given-names></name></person-group><article-title>Developmental barcoding of whole mouse via homing crispr</article-title><source>Science</source><year>2018</year><volume>361</volume><issue>6405</issue><elocation-id>eaat9804</elocation-id><pub-id pub-id-type="pmcid">PMC6139672</pub-id><pub-id pub-id-type="pmid">30093604</pub-id><pub-id pub-id-type="doi">10.1126/science.aat9804</pub-id></element-citation></ref><ref id="R10"><label>[10]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chan</surname><given-names>Michelle M</given-names></name><name><surname>Smith</surname><given-names>Zachary D</given-names></name><name><surname>Grosswendt</surname><given-names>Stefanie</given-names></name><name><surname>Kretzmer</surname><given-names>Helene</given-names></name><name><surname>Norman</surname><given-names>Thomas M</given-names></name><name><surname>Adamson</surname><given-names>Britt</given-names></name><name><surname>Jost</surname><given-names>Marco</given-names></name><name><surname>Quinn</surname><given-names>Jeffrey J</given-names></name><name><surname>Yang</surname><given-names>Dian</given-names></name><name><surname>Jones</surname><given-names>Matthew G</given-names></name><name><surname>Khodaverdian</surname><given-names>Alex</given-names></name><etal/></person-group><article-title>Molecular recording of mammalian embryogenesis</article-title><source>Nature</source><year>2019</year><month>Jun</month><volume>570</volume><issue>7759</issue><fpage>77</fpage><lpage>82</lpage><pub-id pub-id-type="pmcid">PMC7229772</pub-id><pub-id pub-id-type="pmid">31086336</pub-id><pub-id pub-id-type="doi">10.1038/s41586-019-1184-5</pub-id></element-citation></ref><ref id="R11"><label>[11]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Yang</surname><given-names>Z</given-names></name></person-group><article-title>A space-time process model for the evolution of DNA sequences</article-title><source>Genetics</source><year>1995</year><day>02</day><volume>139</volume><issue>2</issue><fpage>993</fpage><lpage>1005</lpage><pub-id pub-id-type="pmcid">PMC1206396</pub-id><pub-id pub-id-type="pmid">7713447</pub-id><pub-id pub-id-type="doi">10.1093/genetics/139.2.993</pub-id></element-citation></ref><ref id="R12"><label>[12]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Price</surname><given-names>Morgan N</given-names></name><name><surname>Dehal</surname><given-names>Paramvir S</given-names></name><name><surname>Arkin</surname><given-names>Adam P</given-names></name></person-group><article-title>Fasttree 2 – approximately maximum-likelihood trees for large alignments</article-title><source>PLoS ONE</source><year>2010</year><month>Mar</month><volume>5</volume><issue>3</issue><elocation-id>e9490</elocation-id><pub-id pub-id-type="pmcid">PMC2835736</pub-id><pub-id pub-id-type="pmid">20224823</pub-id><pub-id pub-id-type="doi">10.1371/journal.pone.0009490</pub-id></element-citation></ref><ref id="R13"><label>[13]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Guindon</surname><given-names>Stéphane</given-names></name><name><surname>Dufayard</surname><given-names>Jean-François</given-names></name><name><surname>Lefort</surname><given-names>Vincent</given-names></name><name><surname>Anisimova</surname><given-names>Maria O</given-names></name><name><surname>Hordijk</surname><given-names>Wim</given-names></name><name><surname>Gascuel</surname><given-names>Olivier</given-names></name></person-group><article-title>New algorithms and methods to estimate maximum-likelihood phylogenies: assessing the performance of phyml 3.0</article-title><source>Systematic biology</source><year>2010</year><volume>59</volume><issue>3</issue><fpage>307</fpage><lpage>21</lpage><pub-id pub-id-type="pmid">20525638</pub-id></element-citation></ref><ref id="R14"><label>[14]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Minh</surname><given-names>Bui Quang</given-names></name><name><surname>Schmidt</surname><given-names>Heiko A</given-names></name><name><surname>Chernomor</surname><given-names>Olga</given-names></name><name><surname>Schrempf</surname><given-names>Dominik</given-names></name><name><surname>Woodhams</surname><given-names>Michael D</given-names></name><name><surname>von Haeseler</surname><given-names>Arndt</given-names></name><name><surname>Lanfear</surname><given-names>Robert</given-names></name></person-group><article-title>IQ-TREE 2: New Models and Efficient Methods for Phylogenetic Inference in the Genomic Era</article-title><source>Molecular Biology and Evolution</source><year>2020</year><day>02</day><volume>37</volume><issue>5</issue><fpage>1530</fpage><lpage>1534</lpage><pub-id pub-id-type="pmcid">PMC7182206</pub-id><pub-id pub-id-type="pmid">32011700</pub-id><pub-id pub-id-type="doi">10.1093/molbev/msaa015</pub-id></element-citation></ref><ref id="R15"><label>[15]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stamatakis</surname><given-names>Alexandros</given-names></name></person-group><article-title>Raxml version 8: A tool for phylogenetic analysis and post-analysis of large phylogenies</article-title><source>Bioinformatics (Oxford, England)</source><year>2014</year><day>01</day><volume>30</volume><pub-id pub-id-type="pmcid">PMC3998144</pub-id><pub-id pub-id-type="pmid">24451623</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btu033</pub-id></element-citation></ref><ref id="R16"><label>[16]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bouckaert</surname><given-names>Remco</given-names></name><name><surname>Vaughan</surname><given-names>Timothy G</given-names></name><name><surname>Barido-Sottani</surname><given-names>Joëlle</given-names></name><name><surname>Duchêne</surname><given-names>Sebastián</given-names></name><name><surname>Fourment</surname><given-names>Mathieu</given-names></name><name><surname>Gavryushkina</surname><given-names>Alexandra</given-names></name><name><surname>Heled</surname><given-names>Joseph</given-names></name><name><surname>Jones</surname><given-names>Graham</given-names></name><name><surname>Kühnert</surname><given-names>Denise</given-names></name><name><surname>De Maio</surname><given-names>Nicola</given-names></name><name><surname>Matschiner</surname><given-names>Michael</given-names></name><etal/></person-group><article-title>Beast 2.5: An advanced software platform for bayesian evolutionary analysis</article-title><source>PLOS Computational Biology</source><year>2019</year><day>04</day><volume>15</volume><issue>4</issue><fpage>1</fpage><lpage>28</lpage><pub-id pub-id-type="pmcid">PMC6472827</pub-id><pub-id pub-id-type="pmid">30958812</pub-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1006650</pub-id></element-citation></ref><ref id="R17"><label>[17]</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Seidel</surname><given-names>Sophie</given-names></name><name><surname>Stadler</surname><given-names>Tanja</given-names></name></person-group><source>TiDeTree: a Bayesian phylogenetic framework to estimate single-cell trees and population dynamic parameters from genetic lineage tracing data</source><conf-name>Proceedings of the Royal Society B: Biological Sciences</conf-name><year>2022</year><month>November</month><volume>289</volume><issue>1986</issue><elocation-id>20221844</elocation-id></element-citation></ref><ref id="R18"><label>[18]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Feng</surname><given-names>Jean</given-names></name><name><surname>DeWitt</surname><given-names>William S</given-names><suffix>III</suffix></name><name><surname>McKenna</surname><given-names>Aaron</given-names></name><name><surname>Simon</surname><given-names>Noah</given-names></name><name><surname>Willis</surname><given-names>Amy D</given-names></name><name><surname>Matsen</surname><given-names>Frederick A</given-names><suffix>IV</suffix></name></person-group><article-title>Estimation of cell lineage trees by maximum-likelihood phylogenetics</article-title><source>The Annals of Applied Statistics</source><year>2021</year><volume>15</volume><issue>1</issue><fpage>343</fpage><lpage>362</lpage><pub-id pub-id-type="pmcid">PMC9387344</pub-id><pub-id pub-id-type="pmid">35990087</pub-id><pub-id pub-id-type="doi">10.1214/20-aoas1400</pub-id></element-citation></ref><ref id="R19"><label>[19]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Little</surname><given-names>Roderick J</given-names></name><name><surname>Rubin</surname><given-names>Donald B</given-names></name><name><surname>Zangeneh</surname><given-names>Sahar Z</given-names></name></person-group><article-title>Conditions for ignoring the missing-data mechanism in likelihood inferences for parameter subsets</article-title><source>Journal of the American Statistical Association</source><year>2017</year><volume>112</volume><issue>517</issue><fpage>314</fpage><lpage>320</lpage></element-citation></ref><ref id="R20"><label>[20]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mealli</surname><given-names>Fabrizia</given-names></name><name><surname>Rubin</surname><given-names>Donald B</given-names></name></person-group><article-title>Clarifying missing at random and related definitions, and implications when coupled with exchangeability</article-title><source>Biometrika</source><year>2015</year><day>09</day><volume>102</volume><issue>4</issue><fpage>995</fpage><lpage>1000</lpage></element-citation></ref><ref id="R21"><label>[21]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Varin</surname><given-names>Cristiano</given-names></name><name><surname>Reid</surname><given-names>Nancy</given-names></name><name><surname>Firth</surname><given-names>David</given-names></name></person-group><article-title>An overview of composite likelihood methods</article-title><source>Statistica Sinica</source><year>2011</year><volume>21</volume><issue>1</issue><fpage>5</fpage><lpage>42</lpage></element-citation></ref><ref id="R22"><label>[22]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Prillo</surname><given-names>Sebastian</given-names></name><name><surname>Deng</surname><given-names>Yun</given-names></name><name><surname>Boyeau</surname><given-names>Pierre</given-names></name><name><surname>Li</surname><given-names>Xingyu</given-names></name><name><surname>Chen</surname><given-names>Po-Yen</given-names></name><name><surname>Song</surname><given-names>Yun S</given-names></name></person-group><article-title>CherryML: scalable maximum likelihood estimation of phylogenetic models</article-title><source>Nature Methods</source><year>2023</year><month>August</month><volume>20</volume><issue>8</issue><fpage>1232</fpage><lpage>1236</lpage><pub-id pub-id-type="pmcid">PMC10644697</pub-id><pub-id pub-id-type="pmid">37386188</pub-id><pub-id pub-id-type="doi">10.1038/s41592-023-01917-9</pub-id></element-citation></ref><ref id="R23"><label>[23]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kalyaanamoorthy</surname><given-names>Subha</given-names></name><name><surname>Minh</surname><given-names>Bui</given-names></name><name><surname>Wong</surname><given-names>Thomas</given-names></name><name><surname>von Haeseler</surname><given-names>Arndt</given-names></name><name><surname>Jermiin</surname><given-names>Lars</given-names></name></person-group><article-title>Modelfinder: Fast model selection for accurate phylogenetic estimates</article-title><source>Nature Methods</source><year>2017</year><day>05</day><volume>14</volume><pub-id pub-id-type="pmcid">PMC5453245</pub-id><pub-id pub-id-type="pmid">28481363</pub-id><pub-id pub-id-type="doi">10.1038/nmeth.4285</pub-id></element-citation></ref><ref id="R24"><label>[24]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Minh</surname><given-names>Bui Quang</given-names></name><name><surname>Dang</surname><given-names>Cuong Cao</given-names></name><name><surname>Vinh</surname><given-names>Le Sy</given-names></name><name><surname>Lanfear</surname><given-names>Robert</given-names></name></person-group><article-title>QMaker: Fast and Accurate Method to Estimate Empirical Models of Protein Evolution</article-title><source>Systematic Biology</source><year>2021</year><day>02</day><volume>70</volume><issue>5</issue><fpage>1046</fpage><lpage>1060</lpage><pub-id pub-id-type="pmcid">PMC8357343</pub-id><pub-id pub-id-type="pmid">33616668</pub-id><pub-id pub-id-type="doi">10.1093/sysbio/syab010</pub-id></element-citation></ref><ref id="R25"><label>[25]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Whelan</surname><given-names>Simon</given-names></name><name><surname>Goldman</surname><given-names>Nick</given-names></name></person-group><article-title>A General Empirical Model of Protein Evolution Derived from Multiple Protein Families Using a Maximum-Likelihood Approach</article-title><source>Molecular Biology and Evolution</source><year>2001</year><day>05</day><volume>18</volume><issue>5</issue><fpage>691</fpage><lpage>699</lpage><pub-id pub-id-type="pmid">11319253</pub-id></element-citation></ref><ref id="R26"><label>[26]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rubin</surname><given-names>Donald B</given-names></name></person-group><article-title>Inference and missing data</article-title><source>Biometrika</source><year>1976</year><volume>63</volume><issue>3</issue><fpage>581</fpage><lpage>592</lpage></element-citation></ref><ref id="R27"><label>[27]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Diamond</surname><given-names>Steven</given-names></name><name><surname>Boyd</surname><given-names>Stephen</given-names></name></person-group><article-title>CVXPY: A Python-embedded modeling language for convex optimization</article-title><source>Journal of Machine Learning Research</source><year>2016</year><volume>17</volume><issue>83</issue><fpage>1</fpage><lpage>5</lpage><pub-id pub-id-type="pmcid">PMC4927437</pub-id><pub-id pub-id-type="pmid">27375369</pub-id></element-citation></ref><ref id="R28"><label>[28]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Agrawal</surname><given-names>Akshay</given-names></name><name><surname>Verschueren</surname><given-names>Robin</given-names></name><name><surname>Diamond</surname><given-names>Steven</given-names></name><name><surname>Boyd</surname><given-names>Stephen</given-names></name></person-group><article-title>A rewriting system for convex optimization problems</article-title><source>Journal of Control and Decision</source><year>2018</year><volume>5</volume><issue>1</issue><fpage>42</fpage><lpage>60</lpage></element-citation></ref><ref id="R29"><label>[29]</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Domahidi</surname><given-names>A</given-names></name><name><surname>Chu</surname><given-names>E</given-names></name><name><surname>Boyd</surname><given-names>S</given-names></name></person-group><source>ECOS: An SOCP solver for embedded systems</source><conf-name>European Control Conference (ECC)</conf-name><year>2013</year><fpage>3071</fpage><lpage>3076</lpage></element-citation></ref><ref id="R30"><label>[30]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>O’Donoghue</surname><given-names>Brendan</given-names></name><name><surname>Chu</surname><given-names>Eric</given-names></name><name><surname>Parikh</surname><given-names>Neal</given-names></name><name><surname>Boyd</surname><given-names>Stephen</given-names></name></person-group><article-title>Conic optimization via operator splitting and homogeneous self-dual embedding</article-title><source>Journal of Optimization Theory and Applications</source><year>2016</year><month>June</month><volume>169</volume><issue>3</issue><fpage>1042</fpage><lpage>1068</lpage></element-citation></ref><ref id="R31"><label>[31]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kim</surname><given-names>Junhyong</given-names></name><name><surname>Sanderson</surname><given-names>Michael</given-names></name></person-group><article-title>Penalized likelihood phylogenetic inference: Bridging the parsimony-likelihood gap</article-title><source>Systematic biology</source><year>2008</year><day>11</day><volume>57</volume><fpage>665</fpage><lpage>74</lpage><pub-id pub-id-type="pmid">18853355</pub-id></element-citation></ref><ref id="R32"><label>[32]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Neher</surname><given-names>Richard A</given-names></name><name><surname>Russell</surname><given-names>Colin A</given-names></name><name><surname>Shraiman</surname><given-names>Boris I</given-names></name></person-group><article-title>Predicting evolution from the shape of genealogical trees</article-title><source>eLife</source><year>2014</year><month>nov</month><volume>3</volume><elocation-id>e03568</elocation-id><pub-id pub-id-type="pmcid">PMC4227306</pub-id><pub-id pub-id-type="pmid">25385532</pub-id><pub-id pub-id-type="doi">10.7554/eLife.03568</pub-id></element-citation></ref><ref id="R33"><label>[33]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Yang</surname><given-names>Dian</given-names></name><name><surname>Jones</surname><given-names>Matthew G</given-names></name><name><surname>Naranjo</surname><given-names>Santiago</given-names></name><name><surname>Rideout</surname><given-names>William M</given-names></name><name><surname>Hoi (Joseph) Min</surname><given-names>Kyung</given-names></name><name><surname>Ho</surname><given-names>Raymond</given-names></name><name><surname>Wu</surname><given-names>Wei</given-names></name><name><surname>Replogle</surname><given-names>Joseph M</given-names></name><name><surname>Page</surname><given-names>Jennifer L</given-names></name><name><surname>Quinn</surname><given-names>Jeffrey J</given-names></name><name><surname>Horns</surname><given-names>Felix</given-names></name><etal/></person-group><article-title>Lineage tracing reveals the phylodynamics, plasticity, and paths of tumor evolution</article-title><source>Cell</source><year>2022</year><volume>185</volume><issue>11</issue><fpage>1905</fpage><lpage>1923</lpage><elocation-id>e25</elocation-id><pub-id pub-id-type="pmcid">PMC9452598</pub-id><pub-id pub-id-type="pmid">35523183</pub-id><pub-id pub-id-type="doi">10.1016/j.cell.2022.04.015</pub-id></element-citation></ref><ref id="R34"><label>[34]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Snir</surname><given-names>Sagi</given-names></name><name><surname>Rao</surname><given-names>Satish</given-names></name></person-group><article-title>Using max cut to enhance rooted trees consistency</article-title><source>IEEE/ACM Transactions on Computational Biology and Bioinformatics</source><year>2006</year><volume>3</volume><issue>4</issue><fpage>323</fpage><lpage>333</lpage><pub-id pub-id-type="pmid">17085842</pub-id></element-citation></ref><ref id="R35"><label>[35]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Quinn</surname><given-names>Jeffrey</given-names></name><name><surname>Jones</surname><given-names>Matthew</given-names></name><name><surname>Okimoto</surname><given-names>Ross</given-names></name><name><surname>Nanjo</surname><given-names>Shigeki</given-names></name><name><surname>Chan</surname><given-names>Michelle</given-names></name><name><surname>Yosef</surname><given-names>Nir</given-names></name><name><surname>Bivona</surname><given-names>Trever</given-names></name><name><surname>Weissman</surname><given-names>Jonathan</given-names></name></person-group><article-title>Single-cell lineages reveal the rates, routes, and drivers of metastasis in cancer xenografts</article-title><source>Science</source><year>2021</year><day>01</day><volume>371</volume><elocation-id>eabc1944</elocation-id><pub-id pub-id-type="pmcid">PMC7983364</pub-id><pub-id pub-id-type="pmid">33479121</pub-id><pub-id pub-id-type="doi">10.1126/science.abc1944</pub-id></element-citation></ref></ref-list></back><floats-group><fig id="F1" position="float"><label>Figure 1</label><caption><p>(A) A single-cell chronogram over 10 cells A-J. (B) The single-cell chronogram induced by leaves A, D, G, J. (C) CRISPR/Cas9 binds and cuts a target site, introducing an indel at that site. (D) The CRISPR/Cas9 lineage tracing system recording the lineage history of a cell population. We represent the uncut state with ‘0’, distinct indels with positive integers, and missing data with ‘− 1’. Note specifically our choice of representation of double-resection events. (E) Our approach to estimating single-cell chronograms from CRISPR/Cas9 lineage tracing data: A single-cell topology is first estimated using any of many available methods, such as those provided by the <monospace>cassiopeia</monospace> package [<xref ref-type="bibr" rid="R1">1</xref>] or otherwise [<xref ref-type="bibr" rid="R2">2</xref>]. Next, our novel branch length estimator is applied to estimate branch lengths for that topology. (F-H) Single-cell chronograms reveal the timing of events on the tree, single-cell fitness scores, and phenotypic transition rates, among other important applications.</p></caption><graphic xlink:href="EMS192531-f001"/></fig><fig id="F2" position="float"><label>Figure 2</label><caption><title>Performance of branch length estimation methods under the default parameter regime.</title><p>For each branch length estimation method, we show the performance both with and without access to the ground truth topology (in black and blue respectively). When the topology is not provided, it is reconstructed with the Maxcut solver from the Cassiopeia package [<xref ref-type="bibr" rid="R1">1</xref>]. Branch length estimators are evaluated on three tasks: (A) Estimation of the times of the internal nodes in the tree, (B) Estimation of the number of ancestral lineages midway through the experiment, (C) Estimation of the relative fitness of the cells in the population.</p></caption><graphic xlink:href="EMS192531-f002"/></fig><fig id="F3" position="float"><label>Figure 3</label><caption><title>Conservative maximum parsimony enables negligible bias.</title><p>By simulating a massive number of lineage tracing characters on a tree and performing MLE, we explored the bias of our conservative maximum parsimony approach as a function of the number of indel states. We can see that as the number of indel states increases, the bias quickly goes away, unlike for naive maximum parsimony. Because CRISPR/Cas9 lineage tracing systems are characterized by their large state space, this makes conservative maximum parsimony a powerful tool in this setting.</p></caption><graphic xlink:href="EMS192531-f003"/></fig><table-wrap id="T1" position="float" orientation="portrait"><label>Table 1</label><caption><p>Random variables used throughout. Upper case letters with tilde denote random matrices of size <inline-formula><mml:math id="M60"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>n</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula> × <italic>k</italic> with one row per node in the tree while capital letter without tilde denote the submatrix of size <italic>n</italic> × <italic>k</italic> corresponding to the leaf nodes.</p></caption><table frame="box" rules="cols"><thead><tr><th align="center" valign="middle">Random Variables</th><th align="center" valign="middle">Sizes</th><th align="center" valign="middle">Meaning</th></tr></thead><tbody><tr><td align="center" valign="middle"><inline-formula><mml:math id="M61"><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>Z</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:math></inline-formula>, <italic>Z</italic></td><td align="center" valign="middle"><inline-formula><mml:math id="M62"><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>n</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:math></inline-formula> × <italic>k, n</italic> × <italic>k</italic></td><td align="center" valign="middle">Lineage tracing states without missing data</td></tr><tr><td align="center" valign="middle"><inline-formula><mml:math id="M63"><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:math></inline-formula>, <italic>R</italic></td><td align="center" valign="middle"><inline-formula><mml:math id="M64"><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>n</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:math></inline-formula> × <italic>k, n</italic> × <italic>k</italic></td><td align="center" valign="middle">Binary response (1)/missingness (0) mask</td></tr><tr><td align="center" valign="middle"><inline-formula><mml:math id="M65"><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>X</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:math></inline-formula>, <italic>X</italic></td><td align="center" valign="middle"><inline-formula><mml:math id="M66"><mml:mstyle displaystyle="true"><mml:mrow><mml:mover><mml:mi>n</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:math></inline-formula> × <italic>k</italic>, <italic>n</italic> × <italic>k</italic></td><td align="center" valign="middle">Lineage tracing states with missing data</td></tr></tbody></table></table-wrap></floats-group></article>