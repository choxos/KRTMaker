<!DOCTYPE article
 PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2 20190208//EN" "JATS-archivearticle1.dtd">
<article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="preprint"><?all-math-mml yes?><?use-mml?><?origin ukpmcpa?><front><journal-meta><journal-id journal-id-type="nlm-ta">bioRxiv</journal-id><journal-title-group><journal-title>bioRxiv : the preprint server for biology</journal-title></journal-title-group><issn pub-type="ppub"/></journal-meta><article-meta><article-id pub-id-type="manuscript">EMS157437</article-id><article-id pub-id-type="doi">10.1101/2021.12.15.472871</article-id><article-id pub-id-type="archive">PPR433562</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Matchtigs: minimum plain text representation of kmer sets</article-title></title-group><contrib-group><contrib contrib-type="author"><contrib-id contrib-id-type="orcid">https://orcid.org/0000-0003-4878-2809</contrib-id><name><surname>Schmidt</surname><given-names>Sebastian</given-names></name><xref ref-type="aff" rid="A1">1</xref><xref ref-type="corresp" rid="CR1">*</xref></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid">https://orcid.org/0000-0001-9352-0088</contrib-id><name><surname>Khan</surname><given-names>Shahbaz</given-names></name><xref ref-type="aff" rid="A1">1</xref></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-8003-9225</contrib-id><name><surname>Alanko</surname><given-names>Jarno</given-names></name><xref ref-type="aff" rid="A1">1</xref><xref ref-type="aff" rid="A2">2</xref></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid">https://orcid.org/0000-0003-0724-7092</contrib-id><name><surname>Pibiri</surname><given-names>Giulio E.</given-names></name><xref ref-type="aff" rid="A3">3</xref><xref ref-type="aff" rid="A4">4</xref></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-5747-8350</contrib-id><name><surname>Tomescu</surname><given-names>Alexandru I.</given-names></name><xref ref-type="aff" rid="A1">1</xref><xref ref-type="corresp" rid="CR1">*</xref></contrib></contrib-group><aff id="A1"><label>1</label>Department of Computer Science, University of Helsinki, Helsinki, Finland</aff><aff id="A2"><label>2</label>Faculty of Computer Science, Dalhousie University, Halifax, Canada</aff><aff id="A3"><label>3</label>Department of Environmental Sciences, Informatics and Statistics, Ca’ Foscari University of Venice, Venice, Italy</aff><aff id="A4"><label>4</label>ISTI-CNR, Pisa, Italy</aff><author-notes><corresp id="CR1">
<label>*</label>Correspondence: <email>sebastian.schmidt@helsinki.fi</email>; <email>alexandru.tomescu@helsinki.fi</email></corresp></author-notes><pub-date pub-type="nihms-submitted"><day>22</day><month>11</month><year>2022</year></pub-date><pub-date pub-type="preprint"><day>21</day><month>11</month><year>2022</year></pub-date><permissions><ali:free_to_read/><license><ali:license_ref>https://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p>This work is licensed under a <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 International license</ext-link>.</license-p></license></permissions><abstract><p id="P1">We propose a polynomial algorithm computing a <italic>minimum</italic> plain-text representation of kmer sets, as well as an efficient near-minimum greedy heuristic. When compressing read sets of large model organisms or bacterial pangenomes, with only a minor runtime increase, we shrink the representation by up to 60% over unitigs and 27% over previous work. Additionally, the number of strings is decreased by up to 97% over unitigs and 91% over previous work. Finally, a small representation has advantages in downstream applications, as it speeds up SSHash-Lite queries by up to 4.26× over unitigs and 2.10× over previous work.</p></abstract><kwd-group><kwd>kmer sets</kwd><kwd>plain text compression</kwd><kwd>graph algorithm</kwd><kwd>sequence analysis</kwd><kwd>genomic sequences</kwd><kwd>minimum-cost flow</kwd><kwd>Chinese postman problem</kwd></kwd-group></article-meta></front><body><sec id="S1" sec-type="intro"><label>1</label><title>Background</title><sec id="S2"><title>Motivation</title><p id="P2">The field of kmer-based methods has seen a surge of publications in the last years. Examples include alignment-free sequence comparison [<xref ref-type="bibr" rid="R1">1</xref>, <xref ref-type="bibr" rid="R2">2</xref>, <xref ref-type="bibr" rid="R3">3</xref>], variant calling and genotyping [<xref ref-type="bibr" rid="R4">4</xref>, <xref ref-type="bibr" rid="R5">5</xref>, <xref ref-type="bibr" rid="R6">6</xref>, <xref ref-type="bibr" rid="R7">7</xref>, <xref ref-type="bibr" rid="R8">8</xref>], transcript abundance estimation [<xref ref-type="bibr" rid="R9">9</xref>], metagenomic classification [<xref ref-type="bibr" rid="R10">10</xref>, <xref ref-type="bibr" rid="R11">11</xref>, <xref ref-type="bibr" rid="R12">12</xref>, <xref ref-type="bibr" rid="R13">13</xref>], abundance profile inference [<xref ref-type="bibr" rid="R14">14</xref>], indexing of variation graphs [<xref ref-type="bibr" rid="R15">15</xref>, <xref ref-type="bibr" rid="R16">16</xref>], estimating the similarity between metagenomic datasets [<xref ref-type="bibr" rid="R17">17</xref>], species identification [<xref ref-type="bibr" rid="R18">18</xref>, <xref ref-type="bibr" rid="R19">19</xref>] and sequence alignment to de Bruijn graphs [<xref ref-type="bibr" rid="R20">20</xref>, <xref ref-type="bibr" rid="R21">21</xref>, <xref ref-type="bibr" rid="R22">22</xref>, <xref ref-type="bibr" rid="R23">23</xref>]. All these methods are based mainly on kmer sets, i.e. on the existence or non-existence of kmers. They ignore further information like for example predecessor and successor relations between kmers which are represented by the topology of a de Bruijn graph [<xref ref-type="bibr" rid="R24">24</xref>, <xref ref-type="bibr" rid="R25">25</xref>, <xref ref-type="bibr" rid="R26">26</xref>].</p><p id="P3">On the other hand, many classical methods such as genome assemblers [<xref ref-type="bibr" rid="R26">26</xref>, <xref ref-type="bibr" rid="R27">27</xref>, <xref ref-type="bibr" rid="R28">28</xref>, <xref ref-type="bibr" rid="R29">29</xref>, <xref ref-type="bibr" rid="R30">30</xref>, <xref ref-type="bibr" rid="R31">31</xref>, <xref ref-type="bibr" rid="R32">32</xref>, <xref ref-type="bibr" rid="R33">33</xref>, <xref ref-type="bibr" rid="R34">34</xref>, <xref ref-type="bibr" rid="R35">35</xref>] and related algorithms [<xref ref-type="bibr" rid="R36">36</xref>, <xref ref-type="bibr" rid="R37">37</xref>, <xref ref-type="bibr" rid="R38">38</xref>], are based on de Bruijn graphs and their topology. To increase the efficiency of these methods, the graphs are usually compacted by contracting all paths where all inner nodes have in- and outdegree one. These paths are commonly known as <italic>unitigs</italic>, and their first usage can be traced back to [<xref ref-type="bibr" rid="R39">39</xref>]. Since unitigs contain no branches in their inner nodes, they do not alter the topology of the graph, and in turn enable the exact same set of analyses. There are highly engineered solutions available to compute a compacted de Bruijn graph by computing unitigs from any set of strings in memory [<xref ref-type="bibr" rid="R23">23</xref>] or with external memory [<xref ref-type="bibr" rid="R33">33</xref>, <xref ref-type="bibr" rid="R40">40</xref>, <xref ref-type="bibr" rid="R41">41</xref>]. Incidentally, the set of unitigs computed from a set of strings is also a way to store a set of kmers without repetition, and thus in reasonably small space. However, the necessity to preserve the topology of the graph makes unitigs an inferior choice to represent kmer sets, as the sum of their length is still far from optimal, and they consist of many separate strings. The possibility to ignore the topology for kmer-based methods opens more leeway in their representation that can be exploited to reduce the resource consumption of existing and future bioinformatics tools.</p><p id="P4">The need for such representations becomes apparent when observing the amount of data available to bioinformaticians. For example, the number of complete bacterial genomes available in RefSeq [<xref ref-type="bibr" rid="R42">42</xref>] more than doubled between May 2020 and July 2021 from around 9000 [<xref ref-type="bibr" rid="R43">43</xref>] to around 21000<sup><xref ref-type="fn" rid="FN1">[1]</xref></sup>. And with the ready availability of modern sequencing technologies, the amount of genomic data will increase further in the next years. In turn, analysing this data requires an ever growing amount of computational resources. But this could be relieved through a smaller representation that reduces the RAM usage and speeds up the analysis tools, and thereby allows to run larger pipelines using less computational resources. To fulfil this goal, a <italic>plain text</italic> representation would be the most useful: if the representation has to be decompressed before usage, then this likely erases the savings in RAM and/or adds additional runtime overhead. Formally, a plain text representation is a set of strings that contains each kmer from the input strings (forward, reverse-complemented, or both) and no other kmer. We denote such a set as a <italic>spectrum preserving string set</italic> (SPSS), borrowing the naming from [<xref ref-type="bibr" rid="R44">44</xref>] and redefining it slightly <sup><xref ref-type="fn" rid="FN2">[2]</xref></sup>. Such a</p></sec><sec id="S3"><title>Related work</title><p id="P5">The concept of storing a set of kmers in plain text without repeating kmers to achieve a smaller and possibly simpler representation has recently been simultaneously discovered and named <italic>spectrum preserving string sets [without kmer repetition]</italic> by Rahman and Medvedev [<xref ref-type="bibr" rid="R44">44</xref>] as well as <italic>simplitigs</italic> by Břinda, Baym and Kucherov [<xref ref-type="bibr" rid="R43">43</xref>]. To avoid confusion with our redefinition of the SPSS, we call this concept <italic>simplitigs</italic> in our work. Both Rahman and Medvedev and Brinda, Baym and Kucherov propose an implementation that greedily joins consecutive unitigs to compute such a representation. The UST algorithm by Rahman and Medvedev works on the node-centric de Bruijn graph of the input strings and finds arbitrary paths in the graph starting from arbitrary nodes. Each node is visited exactly by one path, and whenever a path cannot be extended forwards (because a dead-end was found, or all successor nodes have been visited already), then a new path is started from a new random node. Before a new path is started this way, if any successor node of the finished path marks the start of a different path, then the two paths are joined. During the traversal, the unitigs of the visited nodes are concatenated (without repeating the <italic>k</italic> – 1 overlapping characters) and those strings are the final output. Brinda, Baym and Kucherov’s greedy algorithm to compute simplitigs (for which the authors provide an implementation under the name ProphAsm [<xref ref-type="bibr" rid="R43">43</xref>]) does not construct a de Bruijn graph, but instead collects all kmers into a hash table. Then it extends arbitrary kmers both forwards and backwards arbitrarily until they cannot be extended anymore, without repeating any kmers. The extended kmers are the final output.</p><p id="P6">Both heuristics greatly reduce the number of strings (<italic>string count</italic>, SC) as well as the total amount of characters in the strings (<italic>cumulative length</italic>, CL) required to store a kmer set. The reduction in CL directly relates to a lower memory consumption for storing a set of strings, but also the reduction in SC is very useful. When storing a set of strings, not only the strings need to be stored, but also some index structure telling where they start and end. This structure can be smaller if less strings exist<sup><xref ref-type="fn" rid="FN3">[3]</xref></sup>. Břinda, Baym and Kucherov show that both SC and CL are greatly reduced for very tangled de Bruijn graphs, like graphs for single large genomes with small kmer length and pangenome graphs with many genomes. Additionally they show merits of using heuristic simplitigs in downstream applications like an improvement in run time of kmer queries using BWA [<xref ref-type="bibr" rid="R46">46</xref>], as well as a reduction in space a set of kmers contains each kmer at most once, this implies that kmers must be unique in such a definition of an SPSS. However, the spectrum is usually defined as a set and not a multiset, hence we use the term SPSS to describe a set of strings that contains the same set of kmers as the input, allowing repetitions.</p><p id="P7">The authors of both papers also give a lower bound on the cumulative length of simplitigs, and show that their heuristics achieve representations with a cumulative length very close to the lower bound for typical values of <italic>k</italic> (31 for bacterial genomes and 51 for eukaryotic genomes). Břinda, Baym and Kucherov also experiment with lower values of <italic>k</italic> (&lt; 20 for bacterial genomes and &lt; 30 for eukaryotic genomes) which make the de Bruijn graph more dense to almost complete, and show that in these cases, their heuristic does not get as close to the lower bound as for larger values of k. Further, the authors of both papers consider whether computing minimum simplitigs without repeating kmers might be NP-hard. This has recently been disproven by Schmidt and Alanko [<xref ref-type="bibr" rid="R47">47</xref>], and in fact simplitigs with minimum cumulative length can be computed in linear time<sup><xref ref-type="fn" rid="FN4">[4]</xref></sup>. Their algorithm constructs a bidirected arc-centric de Bruijn graph in linear time using a suffix tree, and then Eulerises it by inserting <italic>breaking arcs</italic>. It then computes a bidirected Eulerian circuit in the Eulerised graph and breaks it at all breaking arcs. The strings spelled by the resulting walks are the optimal simplitigs, named <italic>Eulertigs</italic>. Specifically, they leave out all parts from the matchtigs algorithm that relate to concatenating unitigs by repeating kmers, and instead only concatenate consecutive unitigs in an optimal way. In line with the previous results about the lower bounds [<xref ref-type="bibr" rid="R44">44</xref>, <xref ref-type="bibr" rid="R43">43</xref>], Eulertigs are only marginally smaller than the strings computed by previous heuristics. All these suggest that no further progress is possible when kmer repetitions are not allowed in a plain text representation.</p><p id="P8">There are already tools available that use simplitigs. The compacted de Bruijn graph builder cuttlefish2 [<xref ref-type="bibr" rid="R40">40</xref>] has an option to output simplitigs instead of maximal unitigs. A recent proposal for a standardised file format for kmer sets explicitly supports simplitigs [<xref ref-type="bibr" rid="R48">48</xref>]. Also the kmer dictionary SSHash [<xref ref-type="bibr" rid="R45">45</xref>] uses simplitigs to achieve a smaller representation and to answer queries more efficiently. Here, the higher efficiency is achieved both by reducing the space required to store the kmers themselves, but also due to the lower string count reducing the size of the index data structures on top. Further, a recent proposal to index genomic sequences as opposed to kmer sets works with simplitigs without modification [<xref ref-type="bibr" rid="R49">49</xref>], and with minor extra book-keeping also for general SPSSs. In that work, the size of the SPSS is very minor compared to the size of the index, however, major components of the index may be smaller if the SPSS contains less strings, which can be achieved by using greedy matchtigs. Our algorithms were also integrated into the external-memory de Bruijn graph compactor GGCAT [<xref ref-type="bibr" rid="R41">41</xref>], which was easy to do<sup><xref ref-type="fn" rid="FN5">[5]</xref></sup>.</p><p id="P9">In the wider field of finding small representations of kmer sets that are not necessarily in plain text, there exists for example ESSCompress [<xref ref-type="bibr" rid="R50">50</xref>], which uses an extended DNA alphabet to encode similar kmers in smaller space. Another nonplain text representation is REINDEER [<xref ref-type="bibr" rid="R51">51</xref>], which uses substrings of unitigs with kmers of similar abundance to not just store the existence of kmers, but also their abundance in each single genome of a pangenome. Lastly, in [<xref ref-type="bibr" rid="R52">52</xref>] the authors use an algorithm similar to ProphAsm and UST to compress multiple kmer sets by separating the unique kmer content of each set from the kmer content shared with other sets.</p></sec><sec id="S4"><title>Our contribution</title><p id="P10">In this paper we propose the first algorithm to find an SPSS of <italic>minimum</italic> size (CL). Moreover, we show that a minimum SPSS with repeated kmers is polynomially solvable, based on a many-to-many min-cost path query and a min-cost perfect matching approach. We further propose a faster and more memoryefficient greedy heuristic to compute a small SPSS that skips the optimal matching step, but still produces close to optimal results in CL, and even better results in terms of SC.</p><p id="P11">Our experiments over references and read datasets of large model organisms and bacterial pangenomes show that the CL decreases by up to 27% and the SC by up to 91% over UST<sup><xref ref-type="fn" rid="FN6">[6]</xref></sup>. Compared to unitigs, the CL decreases by up to 60% and SC by up to 97%. These improvements come often at just minor costs, as computing our small representation (which includes a run of BCALM2) takes less than twice as long than computing unitigs with BCALM2, and takes less than 35% longer in most cases. Even if the memory requirements for large read datasets increase, they stay within the limits of a modern server.</p><p id="P12">Finally we show that besides the smaller size of a minimum SPSS, it also has advantages in downstream applications. As an example of a kmer-based method, we query our compressed representation with the tools SSHash [<xref ref-type="bibr" rid="R45">45</xref>] and Bifrost [<xref ref-type="bibr" rid="R23">23</xref>]. These are state-of-the-art tools supporting kmer-based queries in genomic sequences, using a representation of a kmer set as a set of unitigs. By simply replacing unitigs with the strings produced by our greedy heuristic, and without modifications to Bifrost and a minor modification to SSHash disabling features that require unique kmers, we get a speedup of up to 4.26× over unitigs, and up to 2.10× over strings computed by UST and ProphAsm. We call the modified version of SSHash “SSHash-Lite”.</p></sec></sec><sec id="S5" sec-type="results"><label>2</label><title>Results</title><sec id="S6"><label>2.1</label><title>Basic graph notation</title><p id="P13">We give detailed definitions for our notation below in <xref ref-type="sec" rid="S14">Section 5.1</xref>, but give an intuition about the required notation for the results section here already. Note that our notation deviates from standard mathematical bidirected graph notations, but it is useful in practice as it allows to implement bidirected graphs on top of standard graph libraries. We assume that the reader is familiar with the general concept of de Bruijn graphs.</p><p id="P14">Our bidirected graphs are <italic>arc-centric bidirected de Bruijn graphs</italic>. Arc-centric de Bruijn graph means that kmers are on the arcs, and nodes represent <italic>k</italic> – 1 overlaps between kmers. We represent the bidirected graph as doubled graph, i.e. by having a separate forward and reverse arc for each kmer and a separate forward and reverse node for each <italic>k</italic> – 1 overlap. In this graph, <italic>binodes</italic> are ordered pairs (υ, υ<sup>–1</sup>) of nodes that are reverse complements of each other, and <italic>biarcs</italic> are ordered pairs (e, e<sup>–1</sup>) of arcs that are reverse complements of each other. Two biarcs (e, e<sup>–1</sup>) and (<italic>f,f</italic><sup>–1</sup>) are consecutive if the normal arcs e and <italic>f</italic> are consecutive, i.e. the <italic>f</italic> leaves the node entered by e. A <italic>biwalk</italic> is a sequence of consecutive biarcs. If a biwalk visits a biarc, then it is considered to be covering both directions of the biarc. See <xref ref-type="fig" rid="F3">Figure 3a</xref> for an example.</p></sec><sec id="S7"><label>2.2</label><title>Matchtigs as a minimum plain text representation of kmer sets</title><p id="P15">We introduce the <italic>matchtig algorithm</italic> that computes a character-minimum SPSS for a set of genomic sequences. While former heuristics (ProphAsm, UST) did not allow to repeat kmers, our algorithm explicitly searches for all opportunities to reduce the character count in the SPSS by repeating kmers. Consider for example the arc-centric de Bruijn graph in <xref ref-type="fig" rid="F1">Figure 1a</xref>. When representing its kmers without repetition as in <xref ref-type="fig" rid="F1">Figure 1b</xref>, we need 43 characters and 7 strings. But if we allow to repeat kmers as in <xref ref-type="fig" rid="F1">Figure 1d</xref>, we require only 39 characters and 5 strings. It turns out that structures similar to this example occur often enough in real genome graphs to yield significant improvements in both character and string count of an SPSS.</p><p id="P16">Similar to previous heuristics, our algorithm works on the compacted bidirected de Bruijn graph of the input sequences. However, we require an arc-centric de Bruijn graph, but this can be easily constructed from the node-centric variant (see <xref ref-type="sec" rid="S16">Section 5.3</xref>). In this graph we find a min-cost circular biwalk that visits each biarc at least once, and that can jump between arbitrary nodes at a cost of <italic>k</italic> – 1. This formulation is very similar to the classic Chinese postman problem [<xref ref-type="bibr" rid="R53">53</xref>], formulated as follows: find a min-cost circular walk in a directed graph that visits each arc at least once. This similarity allows us to adapt a classic algorithm from Edmonds and Johnson that solves the Chinese postman problem [<xref ref-type="bibr" rid="R54">54</xref>] (the same principle was applied in [<xref ref-type="bibr" rid="R55">55</xref>]). They first reduce the problem to finding a min-cost Eulerisation via a min-cost flow formulation, and then further reduce that to min-cost perfect matching using a many-to-many min-cost path query between unbalanced nodes. In a similar work [<xref ref-type="bibr" rid="R56">56</xref>], the authors solve the Chinese postman problem in a bidirected de Bruijn graph by finding a min-cost Eulerisation via a min-cost flow formulation. As opposed to [<xref ref-type="bibr" rid="R54">54</xref>, <xref ref-type="bibr" rid="R55">55</xref>] and us, in [<xref ref-type="bibr" rid="R56">56</xref>] the authors propose to solve the min-cost flow problem directly with a min-cost flow solver. We believe this to be infeasible for our problem, since the arbitrary jumps between nodes require the graph in the flow formulation to have a number of arcs quadratic in the number of nodes.</p><p id="P17">Our resulting algorithm is polynomial but while it runs fast for large bacterial pangenomes, it proved practically infeasible to build the matching instance for very large genomes (≥ 500Mbp). This is because each of the min-cost paths found translates into roughly one edge in the matching graph, and the number of min-cost paths raises quadratically if the graph gets denser. Thus, our algorithm ran out of memory when constructing it for larger genomes, and for those where we were able to construct the matching instance, the matcher itself suffered from integer overflows, since it uses 32-bit integers to store the instance. Hence, for practical purposes, we introduce a greedy heuristic to compute approximate matchtigs. This heuristic does not build the complete instance of the matching problem, but just greedily chooses the shortest path from each unbalanced node to Eulerise the graph. This reduces the amount of paths per node to at most one, and as a result, the heuristic uses significantly less memory, runs much faster, and achieves near optimal speedups when run with multiple threads (see <xref ref-type="supplementary-material" rid="SD5">Additional file 5</xref>). While it can in theory produce suboptimal results as in <xref ref-type="fig" rid="F1">Figure 1c</xref>, in practice, the size of the greedily computed strings is very close to that of matchtigs, and the number of strings is always smaller.</p><p id="P18">Moreover, the minimality of matchtigs allows us to exactly compare, for the first time, how close heuristic algorithms to compute simplitigs are to optimal SPSS (on smaller genomes and on bacterial pangenomes, due to the resource-intensiveness of optimal matchtigs).</p><p id="P19">Our implementations are availablet<sup><xref ref-type="fn" rid="FN7">[7]</xref></sup> as both a library and a command line tool, both written in Rust. They support both GFA and fasta file formats with special optimisations for fasta files produced by BCALM2 or GGCAT. Additionally, our implementations support gzip-compressed input and output, as well as outputting an ASCII-encoded bitvector of duplicate kmers.</p></sec><sec id="S8"><label>2.3</label><title>Compression of model organisms</title><p id="P20">We evaluate the performance of our proposed algorithms on three model organisms: <italic>C. elegans, B. mori</italic> and <italic>H. sapiens</italic>. We benchmark the algorithms on both sets of short reads (average length 300 for C. elegans and B. mori, and 296 for H. sapiens) and reference genomes of these organisms. On human reads, we filter the data during processing so that we keep only kmers that occur at least 10 times (min abundance = 10).</p><p id="P21">We use the metrics cumulative length (CL) and string count (SC) as in [<xref ref-type="bibr" rid="R43">43</xref>]. The CL is the total number of characters in all strings in the SPSS, and the SC is the number of strings. We evaluate our algorithms against the same large genomes as in [<xref ref-type="bibr" rid="R43">43</xref>], using both the reference genome and a full set of short reads of the respective species (see <xref ref-type="table" rid="T1">Table 1</xref> for the results). Since UST as well as matchtigs and greedy matchtigs require unitigs as input, and specifically UST needs some extra information in a format only output by BCALM2 [<xref ref-type="bibr" rid="R33">33</xref>], we run BCALM2 to compute unitigs from the input strings. We chose <italic>k</italic> = 31, as it is commonly used in kmer-based methods. While for larger genomes, larger <italic>k</italic> are used as well, we use the value <italic>k</italic> = 31 throughout the main matter to allow for easier comparison between results. Further, for all data sets but the C. elegans reference the matchtigs algorithm ran out of the given 256GiB memory, so we only compute greedy matchtigs for those.</p><p id="P22">On read data sets where we keep all kmers, our greedy heuristic achieves an improvement of up to 27% CL and 82% SC over the best competitor (UST-tigs). The human read data set has smaller improvements, however it was processed with a min abundance of 10, yielding longer unitigs with less potential for compression. On reference genomes the improvement in CL is smaller with up to 7%, however the improvement in SC is much larger with up to 91%.</p><p id="P23">For C. elegans, where computing matchtigs is feasible as well, we observe that they yield no significant improvement in CL, but are even slightly worse in SC than the greedy heuristic. The greedy heuristic actually optimises SC more than the optimal matchtigs algorithm. That is because the matching instance in the optimal algorithm is built to optimise CL, and whenever joining two strings does not alter CL, the choice is made arbitrarily. On the other hand, the greedy heuristic makes as many joins as possible, as long as a join does not worsen the CL. This way, the greedy heuristic actually prioritises joining two strings even if it does not alter the CL. For more details, see <xref ref-type="sec" rid="S25">Sections 5.6</xref> and <xref ref-type="sec" rid="S27">5.8</xref>. See <xref ref-type="supplementary-material" rid="SD1">Additional file 1</xref> for more quality measurements with different kmer size and min. abundance.</p><p id="P24">We assume that the improvements correlate inversely with the average length of maximal unitigs of the data set. Our approach achieves a smaller representation by joining unitigs with overlapping ends, avoiding the repetition of those characters. This has a natural limit of saving at most <italic>k</italic> – 1 characters per pair of unitigs joint together, so at most <italic>k</italic> – 1 characters per unitig. In turn, the maximum fraction of characters saved is bound by <italic>k</italic> – 1 divided by the average length of unitigs. In <xref ref-type="supplementary-material" rid="SD1">Additional file 1</xref> we have varied the kmer size and min. abundance for our data sets to vary the average length of unitigs. This gives us visual evidence for a correlation between average unitig length and decrease in CL.</p><p id="P25">Our improvements come at often negligible costs in terms of time and memory. Even for read sets, the run time at most doubles compared to BCALM2 in the worst case. However, the memory consumption rises significantly for read sets. This is due to the high number of unitigs in those graphs and the distance array of Dijkstra’s algorithm, whose size is linear in the number of nodes and the number of threads. See <xref ref-type="supplementary-material" rid="SD2">Additional file 2</xref> for more performance measurements with different kmer size and min. abundance.</p></sec><sec id="S9"><label>2.4</label><title>Compression of pangenomes</title><p id="P26">In addition to model organisms with large genomes, we evaluate our algorithms on bacterial pangenomes of <italic>N. gonorrhoeae</italic>, <italic>S. pneumoniae</italic>, <italic>E. coli</italic> and <italic>Salmonella</italic>, as well as a <italic>human</italic> pangenome. We use the same metrics as for model organisms. For the bacterial genomes, we choose <italic>k</italic> = 31, but also for the human genome for the reasons argued above, and also for easier comparability of the results on the different genomes. We show the results in <xref ref-type="table" rid="T2">Table 2</xref>. See <xref ref-type="supplementary-material" rid="SD3">Additional file 3</xref> for more quality measurements with different kmer size and min. abundance, and <xref ref-type="supplementary-material" rid="SD4">Additional file 4</xref> for more performance measurements with different kmer size and min. abundance. In neither of them we have included Salmonella or human, as they take too much time.</p><p id="P27">Our algorithms improve CL up to 19% (using greedy matchtigs) over the best competitor and SC up to 70% (using greedy matchtigs). Matchtigs always achieve a slightly lower CL and slightly higher SC than greedy matchtigs, but the CL of greedy matchtigs is always at most 2% worse than that of matchtigs. We again assume that the improvements are correlated inversely to the average size of unitigs, as suggested by the experiments in <xref ref-type="supplementary-material" rid="SD3">Additional file 3</xref>. These improvements come at negligible costs, using at most 23% more time and 11% more memory than BCALM2 when computing greedy matchtigs, except for the large salmonella pangenome, which took 50% more memory. The higher memory consumption is due to the graph being more tangled due to the high number of genomes in the pangenome. For matchtigs, the time increases by less than a factor of two and memory by at most 12% compared to BCALM2.</p></sec><sec id="S10"><label>2.5</label><title>Kmer-based short read queries</title><p id="P28">Matchtigs have further applications beyond merely reducing the size required to store a set of kmers. Due to their smaller size and lower string count, they can make downstream applications more efficient. To make a concrete example, in this section we focus on <italic>membership queries</italic>. As already explained, each SPSS (unitigs, UST-tigs, matchtigs, etc.) can be considered as a (multi-) set of kmers. Given a kmer, a membership query is to verify whether the kmer belongs to the set or not. We focus on <italic>exact</italic> queries, rather than approximate, i.e., if a kmer does not belong to the set then the answer to the query <italic>must</italic> be “false”. Assessing the membership to the set for a string <italic>Q</italic> longer than <italic>k</italic> symbols is based on the answers to its constituent kmers: only if <italic>at least</italic> ⎣θ × (|Q| – <italic>k</italic> + 1⎦ kmers of Q belongs to the set, then Q is considered to be present in the set. The threshold <italic>θ</italic> is therefore an “inclusion” rate, which we fix to 0.8 for the experiments in this section.</p><p id="P29">To support fast membership queries in compressed space, we build an SSHash-Lite<sup><xref ref-type="fn" rid="FN8">[8]</xref></sup> dictionary over each SPSS. SSHash-Lite is a relaxation of SSHash [<xref ref-type="bibr" rid="R45">45</xref>, <xref ref-type="bibr" rid="R57">57</xref>] in that it supports membership queries <italic>without</italic> requiring each kmer to appear once in the underlying SPSS. In short, SSHash is a compressed dictionary for kmers – based on minimal perfect hashing [<xref ref-type="bibr" rid="R58">58</xref>] and minimizers [<xref ref-type="bibr" rid="R59">59</xref>] – which, for an input SPSS without duplicates and having <italic>n</italic> (distinct) kmers, assigns to each kmer in the input a unique integer number from 0 to <italic>n</italic> – 1 by means of a Lookup query. The result of Lookup for any kmer that is <italic>not</italic> contained in the input SPSS is – 1. Therefore, SSHash serves the same purpose of a minimal perfect hash function over a SPSS but it is also able to reject alien kmers. Two variants of SSHash were proposed – a <italic>regular</italic> and a <italic>canonical</italic> one. The canonical variant uses some extra space compared to the regular one but queries are faster to answer. (For all further details, we point the reader to the original papers [<xref ref-type="bibr" rid="R45">45</xref>, <xref ref-type="bibr" rid="R57">57</xref>].)</p><p id="P30">Now, to let SSHash be able to query SPSSs with possible duplicate kmers (e.g., matchtigs), it was only necessary to modify the return value of the Lookup query to just return “true” if a kmer if found in the dictionary rather than its unique integer identifier (respectively, “false” if a kmer is not found instead of –1). Therefore, SSHash-Lite can be directly used to index and query the unitigs, UST-tigs, and matchtigs as well.</p><p id="P31">We compare the performance of SSHash-Lite when indexing unitigs, UST-tigs, and matchtigs in <xref ref-type="table" rid="T3">Table 3</xref>. We build the SPSSs from three datasets: a ~309kx Salmonella Enterica pangenome; a 300× coverage human short read dataset filtered to exclude kmers with an abundance lower than 10; and a 2505x human pangenome. The Salmonalla pangenome was queried with 3 million random Salmonella short reads with lengths between 70 and 502, and an N75 of 302. The human queries for both the human read dataset and the human pangenome are 3 million random short reads (296 bases each) from the human read dataset.</p><p id="P32">We see that matchtigs improve the performance of membership queries in <italic>both space and time</italic> compared to unitigs and UST-tigs. While the difference is more evident when compared to unitigs, matchtigs also consistently outperform UST-tigs – achieving the lowest space usage and faster query time across almost all combinations of dataset and index variant (regular/canonical).</p><p id="P33">Note again that the speed up in searching time is more evident on the human reads dataset since it is much larger than the Salmonella pan-genome and it is generally less evident for the canonical index variant of SSHash-Lite because it is approximately 2× faster to query than the regular one. Remarkably, regular SSHash-Lite over matchtigs achieves 27 – 60% reduction in space over unitigs while being also 4.26× faster to query on the human reads datasets. Compared to UST-tigs instead, matchtigs still retain 2.10× faster query time while improving space by up to 8%. These results were achieved on a typical bioinformatics compute node with many logical cores (256) and a large amount of RAM (2TB). In <xref ref-type="supplementary-material" rid="SD10">Additional file 10</xref> we performed the same experiment on a server with focus on single-thread performance, achieving slightly smaller improvements.</p><p id="P34">The reduction in index space when indexing matchtigs is to be attributed to the lower string count and fewer nucleotides in the collection. The speedups achieved by SSHash-Lite when indexing matchtigs instead of unitigs can be explained as follows. When querying, SSHash-Lite streams through the kmers of the query. At the beginning, the tig containing the first kmer of the query is determined using a minimal perfect hash function over the minimizers of the input SPSS, as well as the position of the kmer in the tig. For the subsequent kmers of the query, SSHash-Lite attempts to “extend” the matching of the kmer against the identified tig by just comparing the single nucleotide following the previous kmer in the tig. Extending a match in this way is extremely fast not only because just a single nucleotide needs to be compared but also because it is a very cache-friendly algorithm, dispensing random accesses to the index entirely. However, each time an extension is not possible (either because we have a mismatch or we have reached the end of the current tig) a “full” new search is made in the index. The search consists in evaluating the minimal perfect hash function and locating the kmer inside another tig. Clearly, a search is much more expensive due to cache misses compared to an extension. Now, using longer tigs with a lower tig count - the case for the matchtigs - increases the chance of extension, or equivalently, decreases the number of full searches in the index. Compared to UST-tig, matchtigs can be faster to query exactly because allowing repeated kmers to appear in the tigs further helps in creating opportunities for extension. Therefore, by reducing the number of full searches, we can reduce the overall runtime of the query.</p></sec></sec><sec id="S11" sec-type="discussion"><label>3</label><title>Discussion</title><p id="P35">Kmer-based methods have found wide-spread use in many areas of bioinformatics over the past years. However, they usually rely on unitigs to represent the kmer sets, since they can be computed efficiently with standard tools [<xref ref-type="bibr" rid="R33">33</xref>, <xref ref-type="bibr" rid="R23">23</xref>, <xref ref-type="bibr" rid="R40">40</xref>, <xref ref-type="bibr" rid="R41">41</xref>]. Unitigs have the additional property that the de Bruijn graph topology can easily be reconstructed from them, since they do not contain branching nodes other than on their first and last kmer. However, this property is not usually required by kmer-based methods, which has opened the question if a smaller set of strings other than unitigs can be used to represent the kmer sets. If such a representation was in plain text, it should be usable in most kmer-based tools, by simply feeding it to the tool instead of unitigs.</p><p id="P36">Previous work has relaxed the unitig requirement of the representation of the kmer sets to arbitrary strings without kmer repetitions. This resulted in a smaller representation, leading to improvements in downstream applications. Additionally, previous work considered whether that finding an optimal representation without repeated kmers is NP-hard, which was then disproven and shown to be linear-time solvable. We have shown that by allowing repetitions, there is a polynomial optimal algorithm that achieves better compression and improvements in downstream applications.</p></sec><sec id="S12" sec-type="conclusions"><label>4</label><title>Conclusions</title><p id="P37">Our <italic>optimum</italic> algorithm compresses the representation significantly more than previous work. For practical purposes we also propose a greedy heuristic that achieves near-optimum results, while being suitable for practical purposes in runtime and memory. Specifically, our algorithms achieve a decrease of 27% in size and 91% in string count over UST. Additionally we have shown that our greedy representation speeds up downstream applications, giving an example with a factor of 2.10 compared to previous compressed representations.</p><p id="P38">Our implementation is available as a stand-alone command-line tool and as a library. We hope that our efficient algorithms result in a wide-spread adoption of near-minimum plain-text representations of kmer sets in kmer-based methods, resulting in more efficient bioinformatics tools.</p></sec><sec id="S13" sec-type="methods"><label>5</label><title>Methods</title><p id="P39">We first give some preliminary definitions in <xref ref-type="sec" rid="S14">Section 5.1</xref> and define our problem in <xref ref-type="sec" rid="S15">Section 5.2</xref>. Note that to stay closer to our implementation, our definitions of bidirected de Bruijn graphs differ from those in e.g. [<xref ref-type="bibr" rid="R56">56</xref>]. However, the concepts are fundamentally the same. Then in <xref ref-type="sec" rid="S16">Sections 5.3</xref> to <xref ref-type="sec" rid="S26">5.7</xref> we describe how to compute matchtigs. The whole algorithm is summarised by an example in <xref ref-type="fig" rid="F2">Figure 2</xref>. For simplicity, we describe the algorithm using an uncompacted de Bruijn graph. However, in practice it is much more efficient to use a compacted de Bruijn graph, but our algorithm can be adapted easily: simply replace the costs of 1 for each original arc with the number of uncompacted arcs it represents. In <xref ref-type="sec" rid="S27">Section 5.8</xref> we describe the greedy heuristic.</p><sec id="S14"><label>5.1</label><title>Preliminaries</title><p id="P40">We are given an alphabet Γ and all strings in this work have only characters in Γ. Further, we are given a bijection comp : Γ → Γ. The <italic>reverse complement</italic> of a string <italic>s</italic> is <italic>s</italic><sup>–1</sup> := rev(comp*(<italic>S</italic>)) where rev denotes the reversal of a string and comp* the character-wise application of comp. For an integer k, a string of length <italic>k</italic> is called a <italic>kmer</italic>. From here on, we only consider strings of lengths at least k, i.e. strings that have at least one kmer as substring. We denote the prefix of length <italic>k</italic> – 1 of a kmer <italic>s</italic> by pre(<italic>s</italic>) and its suffix of length <italic>k</italic> – 1 by suf(<italic>s</italic>). The <italic>spectrum</italic> of a set of strings <italic>S</italic> is defined as the set of all kmers and their reverse complements that occur in at least one string <italic>s</italic> ∈ <italic>S</italic>, formally spec<sub><italic>k</italic></sub> (<italic>s</italic>) := <italic>{r</italic> ∈ Γ<sup><italic>k</italic></sup> | ∃<italic>s</italic> ∈ <italic>s</italic> : <italic>r</italic> or <italic>r<sup>–1</sup></italic> is substring of <italic>s</italic>}.</p><p id="P41">An <italic>arc-centric de-Bruijn graph</italic> (or short <italic>de-Bruijn graph</italic>) DBG½ (<italic>s</italic>) = (V, <italic>E</italic>) of order <italic>k</italic> of a set of strings <italic>s</italic> is defined as a standard directed graph with nodes V := {<italic>s</italic> | <italic>s</italic> ∈ spec<sub><italic>k</italic>–1</sub>(<italic>s</italic>)} and arcs E := {(pre(<italic>s</italic>),suf(<italic>s</italic>)) | <italic>s</italic> ∈ spec<sub><italic>k</italic></sub>(<italic>s</italic>)}. On top of this, we use the following notions of bidirectedness. An ordered pair of reverse-complementary nodes [<italic>υ, υ<sup>–1</sup></italic>] ∈ <italic>V × V</italic> is called a <italic>binode</italic> and an ordered pair of reverse-complementary arcs <italic>[(a, b), (b<sup>–1</sup>, a<sup>–1</sup>)] ∈</italic> <italic>E ×E</italic> is called a <italic>biarc</italic>. Even though these pairs are ordered, reversing the order still represents the same binode/biarc, just in the other direction. A node <italic>υ</italic> is called <italic>canonical</italic> if <italic>υ</italic> is lexicographically smaller than <italic>υ</italic><sup>–1</sup>, and an arc (<italic>a, b</italic>) is called <italic>canonical</italic> if the kmer corresponding to (<italic>a, b</italic>) is lexicographically smaller or equal to the kmer corresponding to (<italic>b<sup>–1</sup>, a<sup>–1</sup></italic>). If an arc or a node is its own reverse-complement (called <italic>self-complemental</italic>), then it is written as biarc [(<italic>a, b</italic>)] or binode [<italic>υ</italic>]. See <xref ref-type="fig" rid="F3">Figure 3</xref> for examples of different bigraphs.</p><p id="P42">Since de Bruijn graphs are defined as standard directed graphs, we use the following standard definitions. The set of incoming (outgoing) arcs of a node is denoted by <italic>E<sup>–</sup>(υ) (E<sup>+</sup>(υ)</italic>), and the indegree (outdegree) is <italic>d<sup>–</sup>(υ) := |E<sup>–</sup>(υ)| (d<sup>+</sup>(υ) := |E<sup>+</sup>(υ)|</italic>). A <italic>walk</italic> in a de Bruijn graph is a sequence of adjacent arcs (followed in the forward direction) and a <italic>unitig</italic> is a wal<italic>k</italic> in which all inner nodes (nodes with at least two incident walk-arcs) have exactly one incoming and one outgoing arc. The length |<italic>w</italic>| of a walk <italic>w</italic> is the length of the sequence of its arcs (counting repeated arcs as often as they are repeated). A <italic>compacted de-Bruijn graph</italic> is a de Bruijn graph in which all maximal unitigs have been replaced by a single arc. A <italic>circular walk</italic> is a walk that starts and ends in the same node, and a <italic>Eulerian circuit</italic> is a circular walk that contains each arc exactly once. A graph that admits a Eulerian circuit is <italic>Eulerian</italic>.</p><p id="P43">Assuming the complemental pairing of nodes and arcs defined above, we can define the following bidirected notions of walks and standard de Bruijn graph concepts. <italic>Biwalks</italic> and <italic>circular biwalks</italic> are defined equivalently to walks, except that they are sequences of biarcs. A biwalk <italic>w</italic> in a de Bruijn graph spells a string spell(<italic>w</italic>) of overlapping visited kmers. That is, spell(<italic>w</italic>) is constructed by concatenating the string <italic>a</italic> from w’s first biarc [(<italic>a, b), (b<sup>–1</sup>,a<sup>–1</sup></italic>)] (or [(<italic>a, b</italic>)]) with the last character of <italic>b</italic> of the first and all following biarcs. See <xref ref-type="fig" rid="F3">Figure 3</xref> for examples of bidirected de Bruijn graphs and notable special cases.</p><p id="P44">A bidirected graph is <italic>connected</italic>, if between each pair of distinct binodes [<italic>u, u<sup>–1</sup></italic>], [<italic>υ,υ<sup>–1</sup></italic>] that are not reverse complements of each other, there is a biwalk from [<italic>u,u<sup>–1</sup></italic>] to [<italic>υ,υ<sup>–1</sup></italic>], or from <italic>[u,u<sup>–1</sup>]</italic> to [<italic>υ<sup>–1</sup>,υ</italic>]. We assume that our graph is connected, as on multiple disconnected components, our algorithm can be executed on each component, yielding a minimum result.</p></sec><sec id="S15"><label>5.2</label><title>Problem overview</title><p id="P45">We are given a set of input strings <italic>I</italic> where each string has length at least k, and we want to compute a minimum spectrum preserving string set, defined as follows.</p><p id="P46"><bold>Definition 1</bold> (SPSS) <italic>A</italic> spectrum preserving string set <italic>(or</italic> SPSS) <italic>of I is a set</italic> S <italic>of strings of length at least</italic> <italic>k</italic> <italic>such that</italic> <italic>spec<sub>k</sub> (I) = spec<sub>k</sub> (<italic>S</italic></italic>), <italic>i.e. both sets of strings contain the same kmers, either directly or as reverse complement</italic>.</p><p id="P47">Note that our definition allows kmers and their reverse complements to be repeated in the SPSS, both in the same string and in different strings. This is the only difference to the definition of Rahman and Medvedev [<xref ref-type="bibr" rid="R44">44</xref>] and simplitigs [<xref ref-type="bibr" rid="R43">43</xref>], which can be formalised as a set of strings <italic>S<sub>s</sub>i<sub>mp</sub>n<sub>t</sub>i<sub>gs</sub></italic> of length at least <italic>k</italic> such that for each kmer in the spectrum, either itself or its reverse complement (but <italic>not both</italic>) occurs <italic>exactly once</italic> in <italic>exactly one</italic> string in <italic>S<sub>simplitigs</sub></italic>.</p><p id="P48"><bold>Definition 2</bold> (Minimum SPSS) <italic>The</italic> size ||S|| <italic>of an SPSS</italic> <italic>S is defined as</italic> <disp-formula id="FD1"><mml:math id="M1"><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mi>S</mml:mi><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
<italic>where |s| denotes the length of string s. A</italic> minimum <italic>SPSS is an SPSS of minimum size</italic>.</p><p id="P49">On a high level, our algorithm works as follows (see also <xref ref-type="fig" rid="F2">Figure 2</xref>). <list list-type="order" id="L1"><list-item><p id="P50">Create a bidirected de Bruijn graph from the input strings (see <xref ref-type="sec" rid="S16">Section 5.3</xref>).</p></list-item><list-item><p id="P51">Compute the <italic>bi-imbalances</italic> of each node (see <xref ref-type="sec" rid="S18">Section 5.5</xref>).</p></list-item><list-item><p id="P52">Compute the min-cost bipaths of length at most <italic>k</italic> – 1 from all nodes with negative bi-imbalance to all nodes with positive bi-imbalance (see <xref ref-type="sec" rid="S26">Section 5.7</xref>).</p></list-item><list-item><p id="P53">Solve a min-cost matching instance with costs for unmatched nodes to choose a set of shortest bipaths with minimum cost by reduction to min-cost perfect matching (see <xref ref-type="sec" rid="S25">Section 5.6</xref>).</p></list-item><list-item><p id="P54"><italic>BiEulerise</italic> the graph with the set of bipaths as well as arbitrary arcs between unmatched nodes.</p></list-item><list-item><p id="P55">Compute a <italic>biEulerian circuit</italic> in the resulting graph (see <xref ref-type="sec" rid="S18">Section 5.5</xref>).</p></list-item><list-item><p id="P56">Break the circuit into a set of biwalks and translate them into a set of strings, which is the output minimum SPSS (see <xref ref-type="sec" rid="S17">Section 5.4</xref>).</p></list-item></list>
</p><p id="P57">Note that in our implementation, a substantial difference is that we do not build the de Bruijn graph ourselves, but we expect the input to be a de Bruijn graph already. For our experiments, we use a compacted de Bruijn graph computed with BCALM2. We motivate the reasons for optimality while explaining our algorithm, but also give a formal proof in <xref ref-type="supplementary-material" rid="SD8">Additional file 8</xref>.</p></sec><sec id="S16"><label>5.3</label><title>Building a compacted bidirected arc-centric de Bruijn graph from a set of strings</title><p id="P58">When building the graph we first compute unitigs from the input strings using BCALM2. Then we initialise an empty graph and do the following for each unitig: <list list-type="order" id="L2"><list-item><p id="P59">We insert the unitig’s first <italic>k</italic> – 1-mer and its reverse complement as binode by inserting the two nodes separately and marking them as a bidirected pair, if it does not already exist. The existence is tracked with a hashmap, storing the two nodes corresponding to a kmer and its reverse complement if it exists.</p></list-item><list-item><p id="P60">We do the same for the last <italic>k</italic> – 1-mer of the unitig.</p></list-item><list-item><p id="P61">We add a biarc between the two binodes by inserting one forward arc between the forward nodes of the binodes, and one reverse arc between the reverse complement nodes of the binodes. The forward arc is labelled with the unitig, and the reverse arc is labelled with its reverse complement.</p></list-item></list>
</p><p id="P62">To save memory, we store the unitigs in a single large array, where each character is encoded as two-bit number. The keys of the hashmap and the labels of the arcs are pointers into the array, together with a flag for the reverse complement. Nodes do not need a label, as their label can be inferred from any of its incident arcs’ label. Recall that in the description of our algorithm, we use an uncompacted graph only for simplicity.</p></sec><sec id="S17"><label>5.4</label><title>Reduction to the bidirected partial-coverage Chinese postman problem</title><p id="P63">We first compute the arc-centric de-Bruijn graph DBG<sub>k</sub> (<italic>I</italic>) of the given input string set I as described in <xref ref-type="sec" rid="S16">Section 5.3</xref>. In DBG<sub>k</sub>(I), an SPSS <italic>S</italic> is represented by a <italic>biarccovering</italic> set of biwalks <italic>W</italic> (the reverse direction of a biarc does not need to be covered separately). That is a set of biwalks such that each biarc is element of at least one biwalk (see <xref ref-type="fig" rid="F3">Figure 3a</xref>). According to the definition of spell, the size of <italic>s</italic> is related to <italic>w</italic> as follows: <disp-formula id="FD2"><label>(1)</label><mml:math id="M2"><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mi>S</mml:mi><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>w</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mtext>spell(w)</mml:mtext></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>=</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>W</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>w</mml:mi><mml:mo>∈</mml:mo><mml:mi>W</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>w</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P64">Each walk costs <italic>k</italic> – 1 characters because it contains the node <italic>a</italic> from its first biarc [(<italic>a, b), (b<sup>–1</sup>, a<sup>–1</sup></italic>)] (or [(<italic>a, b)]</italic>), and it additionally costs one character per arc.</p><p id="P65">To minimise <italic>||S||</italic>, we transform the graph as follows:</p><p id="P66"><bold>Definition 3</bold> (Graph transformation) <italic>Given an arc-centric de-Bruijn graph DBG<sub>k</sub>(I</italic>) = (<italic>V,E), the</italic> transformed graph <italic>is defined as <inline-formula><mml:math id="M3"><mml:mrow><mml:mi>D</mml:mi><mml:mi>B</mml:mi><mml:msub><mml:msup><mml:mi>G</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>E</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where E′ is a multiset defined as E′</italic> := E ∪ (<italic>V × V). In E′, arcs from E are marked as</italic> non-breaking, <italic>and arcs from V × V are marked as</italic> breaking <italic>arcs. The</italic> cost function <italic>c(e</italic>), <italic>e ∈ E′</italic> <italic>assigns all non-breaking arcs the costs</italic> 1 and all breaking arcs the costs <italic>k</italic> – 1.</p><p id="P67">The reverse complements of breaking arcs are breaking as well, and the same holds for non-breaking arcs. This means that biarcs always are either a pair of reverse complemental breaking arcs, in which case we call them <italic>breaking biarcs</italic>, or a pair of reverse complemental non-breaking arcs, in which case we call them <italic>nonbreaking biarcs</italic>. By the same pattern, self-complemental biarcs are defined to be <italic>breaking biarcs</italic> or <italic>non-breaking biarcs</italic> depending on their underlying arc. Breaking arcs have the costs <italic>k</italic> – 1 because each breaking arc corresponds to starting a new walk, which by <xref ref-type="disp-formula" rid="FD2">Equation (1)</xref> costs <italic>k</italic> – 1.</p><p id="P68">In the transformed graph we find a circular biwalk <italic>w*</italic> of minimum cost that covers at least all original biarcs (to cover a biarc it is enough to traverse it once in one of its directions), as well as at least one breaking biarc. The reason for having at least one breaking biarc is that later we break the circular original-biarc-covering biwalk at all breaking biarcs to get a set of strings. If there was no breaking biarc, then we would get a circular string. Simply breaking a circular string at an arbitrary binode or a repeated non-breaking biarc does not produce a minimum solution in general <sup><xref ref-type="fn" rid="FN9">[9]</xref></sup>, hence we make it a part of the optimisation problem to find an optimal breaking point. We define such a walk as:</p><p id="P69"><bold>Definition 4</bold> (Circular original-biarc-covering biwalk) <italic>Given a transformed graph</italic> <inline-formula><mml:math id="M4"><mml:mrow><mml:mi>D</mml:mi><mml:mi>B</mml:mi><mml:msub><mml:msup><mml:mi>G</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width="0.2em"/></mml:mrow></mml:math></inline-formula>, <italic>a circular original-biarc-covering biwalk is a circular biwalk <italic>w</italic> such that for each non-breaking arc (a, b) ∈ E there is a biarc [(<italic>a, b), (b<sup>–1</sup>,a<sup>–1</sup></italic>)], [(<italic>b<sup>–1</sup>,a<sup>–1</sup>), (a, b</italic>)] or [(<italic>a, b</italic>)] in w. Additionally, <italic>w</italic> needs to contain at least one breaking biarc</italic>.</p><p id="P70"><bold>Definition 5</bold> (Costs of a circular original-biarc-covering biwalk) <italic>Given a transformed graph</italic> <inline-formula><mml:math id="M5"><mml:mrow><mml:mi>D</mml:mi><mml:mi>B</mml:mi><mml:msub><mml:msup><mml:mi>G</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width="0.2em"/></mml:mrow></mml:math></inline-formula> <italic>and a circular original-biarc-covering walk</italic> <italic>w</italic> possibly consisting of biarcs [(<italic>a, b), (b<sup>–1</sup>,a<sup>–1</sup></italic>)] and self-complemental biarcs [(<italic>a, b</italic>)]. The costs <italic>c(w</italic>) of <italic>w</italic> are the sum of the costs of each biarc and self-complemental biarc, where the costs of a biarc [(<italic>a, b), (b<sup>–1</sup>,a<sup>–1</sup></italic>)] are <italic>c((a,b)</italic>), and the costs of a self-complemental biarc [(<italic>a, b</italic>)] are <italic>c((a,b)</italic>).</p><p id="P71">This is similar to the directed Chinese postman problem (DCPP). In the DCPP, the task is to find a circular min-cost arc-covering walk in a directed graph. It is a classical problem, known to be solvable in <italic>O(n<sup>3</sup></italic>) time [<xref ref-type="bibr" rid="R60">60</xref>] with a flow-based algorithm using e.g. [<xref ref-type="bibr" rid="R61">61</xref>] to compute min-cost flows. The partial coverage variant of the DCPP (requiring to cover only a subset of the arcs) is also known as the rural postman problem [<xref ref-type="bibr" rid="R62">62</xref>]. Further, the bidirected variant of the DCPP was discussed before in [<xref ref-type="bibr" rid="R56">56</xref>], and the authors also solved it using min-cost flow in <italic>O(n<sup>2</sup> log<sup>2</sup>(n)</italic>) time.</p><p id="P72">We break the resulting min-cost circular original-biarc-covering biwalk w* at all breaking arcs (hence we require it to contain at least one breaking biarc, otherwise we would get a circular string). The returned SPSS is minimum, because the metric optimised when finding w* matches <xref ref-type="disp-formula" rid="FD2">Equation (1)</xref>.</p></sec><sec id="S18"><label>5.5</label><title>Solving the bidirected partial-coverage Chinese postman problem with min-cost integer flows</title><p id="P73">Edmonds and Johnson [<xref ref-type="bibr" rid="R54">54</xref>] introduced a polynomial-time flow-based approach that is adaptable to solve our variant of the DCPP. They show that finding a minimum circular arc-covering walk in a directed graph is equivalent to finding a minimum <italic>Eulerisation</italic> of the graph, and then any Eulerian circuit in the Eulerised graph. A Eulerisation is a multiset of arc-copies from the graph that makes the graph Eulerian if added<sup><xref ref-type="fn" rid="FN10">[10]</xref></sup>, and a minimum Eulerisation is one whose sum of arc costs is minimum among all such multisets. To find such a minimum cost set of arcs, they formulate a min-cost flow problem as an integer linear program as follows: <disp-formula id="FD3"><label>(2)</label><mml:math id="M6"><mml:mrow><mml:mi>min</mml:mi><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mspace width="0.2em"/><mml:mtext>s</mml:mtext><mml:mo>.</mml:mo><mml:mtext>t</mml:mtext><mml:mspace width="0.2em"/></mml:mrow></mml:math></disp-formula> <disp-formula id="FD4"><label>(3)</label><mml:math id="M7"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mspace width="0.2em"/><mml:mtext>are</mml:mtext><mml:mspace width="0.2em"/><mml:mtext>non-negative</mml:mtext><mml:mspace width="0.2em"/><mml:mtext>integers</mml:mtext><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mtext>and</mml:mtext></mml:mrow></mml:math></disp-formula> <disp-formula id="FD5"><label>(4)</label><mml:math id="M8"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo>:</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>E</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>−</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>E</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>=</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P74">The variable <italic>x<sub>e</sub></italic> is interpreted as the amount of flow through arc e, and the variable c<sub>e</sub> denotes the cost for assigning flow to an arc e. The costs are equivalent to the arc costs in the weighted graph specified by the DCPP instance. Objective (2) minimises the costs of inserted arcs as required. To ensure that the resulting flow can be directly translated into added arcs, Condition (3) ensures that the resulting flow is non-negative and integral. Lastly, <xref ref-type="disp-formula" rid="FD5">Equation (4)</xref> is the <italic>balance constraint</italic>, ensuring that the resulting flow is a valid Eulerisation of the graph. This constraint makes nodes with missing outgoing arcs into <italic>sources</italic>, and nodes with missing incoming arcs into <italic>sinks</italic>, with demands matching the number of missing arcs. Note that in contrast to classic flow problems, this formulation contains no capacity constraint. For a solution of this linear program, the corresponding Eulerisation contains <italic>x<sub>e</sub></italic> copies of each arc <italic>e</italic>.</p><p id="P75">To adapt this formulation to our variant of the DCPP, we need to make modifications, namely: <list list-type="bullet" id="L3"><list-item><p id="P76">compute the costs while treating self-complemental biarcs the same as other biarcs,</p></list-item><list-item><p id="P77">allow for partial coverage,</p></list-item><list-item><p id="P78">force cover at least one breaking arc (one of the arcs that are not required to be covered),</p></list-item><list-item><p id="P79">adjust the balance constraint for biwalks and</p></list-item><list-item><p id="P80">ensure that the resulting flow is <italic>bidirected</italic>, i.e. the flow of each arc equals the flow of its reverse complement.</p></list-item></list>
</p><sec id="S19"><title>Bidirected costs</title><p id="P81">If we would simply count the costs of each arc separately, then self-complemental biarcs would cost 1 for each repetition, while other biarcs would cost 2 for each repetition, since other biarcs consist for two arcs. To circumvent this, we only count arcs corresponding to canonical kmers in the cost function: <disp-formula id="FD6"><label>(5)</label><mml:math id="M9"><mml:mrow><mml:mi>min</mml:mi><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mi>e</mml:mi><mml:mspace width="0.2em"/><mml:mtext>is</mml:mtext><mml:mspace width="0.2em"/><mml:mtext>canonical</mml:mtext><mml:mspace width="0.2em"/></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mspace width="0.2em"/><mml:mtext>s</mml:mtext><mml:mo>.</mml:mo><mml:mtext>t</mml:mtext><mml:mspace width="0.2em"/></mml:mrow></mml:math></disp-formula></p></sec><sec id="S20"><title>Partial coverage</title><p id="P82">In the partial coverage Chinese postman problem, we are additionally given a set <italic>F ⊆ E</italic> of arcs to be covered. In contrast to the standard DCPP, a solution walk only needs to cover all the arcs in <italic>F</italic>. In our case, the set <italic>F</italic> is the set of original arcs of the graph before Eulerisation. To solve the partial coverage Chinese postman problem we define outgoing covered arcs <italic>F<sup>+</sup> (υ) := F ⋂ E<sup>+</sup>(υ</italic>), and incoming covered arcs <italic>F<sup>–</sup>(υ) := F ⋂ E<sup>–</sup>(υ</italic>) for a node <italic>υ</italic>, as well as the covered outdegree <inline-formula><mml:math id="M10"><mml:mrow><mml:msubsup><mml:mi>d</mml:mi><mml:mi>F</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>υ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mi>F</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>υ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> and the covered indegree <inline-formula><mml:math id="M11"><mml:mrow><mml:msubsup><mml:mi>d</mml:mi><mml:mi>F</mml:mi><mml:mo>−</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>υ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mi>F</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>υ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. Then we reformulate the balance constraint as: <disp-formula id="FD7"><mml:math id="M12"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo>:</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>E</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>−</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>E</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>=</mml:mo><mml:msubsup><mml:mi>d</mml:mi><mml:mi>F</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msubsup><mml:mi>d</mml:mi><mml:mi>F</mml:mi><mml:mo>−</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P83">The resulting set of arcs is a minimum Eulerisation of the graph (V, F), and a Eulerian walk in this graph is equivalent to a minimum circular F-covering walk in the original graph.</p></sec><sec id="S21"><title>Cover one breaking arc</title><p id="P84">Next to the partial coverage condition, we additionally require to cover at least one of the arcs that is not required to be covered. Since we forbid negative flows, we can express this as: <disp-formula id="FD8"><label>(6)</label><mml:math id="M13"><mml:mrow><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo>\</mml:mo><mml:mi>F</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mn>1.</mml:mn></mml:mrow></mml:math></disp-formula></p></sec><sec id="S22"><title>Bidirected balance</title><p id="P85">In contrast to Edmonds and Johnson, we are interested in a minimum circular <italic>bi</italic>walk that covers each original <italic>bi</italic>arc. Analogue to the formulation for directed graphs, we make the following definitions:</p><p id="P86"><bold>Definition 6</bold> (BiEulerian circuits and graphs) <italic>A</italic> biEulerian circuit <italic>in a bidirected graph is a bidirected circuit that visits each biarc exactly once. A</italic> biEulerian graph <italic>is a graph that admits a biEulerian circuit. A</italic> biEulerisation <italic>is a multiset of biarc-copies from the graph that makes a graph biEulerian if added. A</italic> minimum biEulerisation <italic>is one whose sum of arc costs is minimum among all biEulerisations of the same graph</italic>.</p><p id="P87">We can compute a biEulerisation in the same way as we compute a Eulerisation, the only change is in the balance constraint. Observe that for a Eulerian graph, the <italic>imbalance i<sub>υ</sub></italic> := d<sup>–</sup>(<italic>υ</italic>) – d<sup>+</sup>(<italic>υ</italic>) is zero for each node [<xref ref-type="bibr" rid="R63">63</xref>], because each node is entered exactly as often as it is exited. For binodes, the definition of the <italic>bi-imbalance bi<sub>υ</sub></italic> of a binode [υ, υ<sup>–1</sup>] or [υ] follows the same idea. However, in contrast to directed graphs, there are two (mutual exclusive<sup><xref ref-type="fn" rid="FN11">[11]</xref></sup>) special cases.</p><p id="P88">Binodes [<italic>υ, υ<sup>–1</sup></italic>] ∈ <italic>V</italic> × <italic>V</italic> with <italic>υ = υ<sup>–1</sup></italic> may have incident self-complemental arcs [(<italic>υ,υ<sup>–1</sup></italic>)] and/or [(<italic>υ<sup>–1</sup>,υ</italic>)] (see <xref ref-type="fig" rid="F3">Figure 3c</xref> for an example). If e.g. only [(<italic>υ,υ<sup>–1</sup></italic>)] exists, then to traverse it, a biwalk needs to enter υ twice. First, it needs to reach [<italic>υ, υ<sup>–1</sup></italic>] via some biarc, and after traversing [(<italic>υ, υ<sup>–1</sup></italic>)], it needs to leave [<italic>υ<sup>–1</sup>, υ</italic>] via a different biarc, whose reverse complement enters [<italic>υ, υ<sup>–1</sup></italic>]. Hence, a self-complemental biarc alters the bi-imbalance of a node by two. See <xref ref-type="fig" rid="F4">Figure 4</xref> for an example of this situation. If only [(<italic>υ<sup>–1</sup>, υ</italic>)] exists, then the situation is symmetric. Therefore, for balance of [<italic>υ, υ<sup>–1</sup></italic>], the self-complemental biarc [(<italic>υ, υ<sup>–1</sup></italic>)] requires two biarcs entering [<italic>υ, υ<sup>–1</sup></italic>] and the self-complemental biarc [(<italic>υ<sup>–1</sup>, υ</italic>)] requires two biarcs leaving [<italic>υ, υ<sup>–1</sup></italic>]. If both self-complemental arcs exist (e.g. both [(<italic>ATA, TAT</italic>)] and [(<italic>TAT, ATA</italic>)] for a binode [<italic>ATA, TAT</italic>]), then a biwalk can traverse them consecutively from e.g. [<italic>υ, υ<sup>–1</sup></italic>] by traversing first [(<italic>υ, υ<sup>–1</sup></italic>)] and then [(<italic>υ<sup>–1</sup>, υ</italic>)], ending up in [<italic>υ, υ<sup>–1</sup></italic>] again, such that the self-complemental arcs have a neutral contribution to the bi-imbalance. Resulting, the bi-imbalance of [<italic>υ, υ<sup>–1</sup></italic>] is <disp-formula id="FD9"><mml:math id="M14"><mml:mrow><mml:mi>b</mml:mi><mml:msub><mml:mi>i</mml:mi><mml:mi>v</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mi>E</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>v</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mi>E</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula> where is <italic>1<sub>P</sub></italic> if the predicate <italic>P</italic> is true and 0 otherwise.</p><p id="P89">For self-complemental binodes [<italic>υ</italic>] ∈ <italic>V</italic>, there is no concept of incoming or outgoing biarcs, since any biarc can be used to either enter or leave [<italic>υ</italic>] (see <xref ref-type="fig" rid="F3">Figure 3b</xref> for an example). Therefore, for balance, biarcs need to be paired arbitrarily, for which to be possible there needs to be an even amount of biarcs. If there is an odd amount, then there is one unpaired biarc, hence the bi-imbalance is 1. The following condition exerts this behaviour (using mod as the remainder operator): <disp-formula id="FD10"><mml:math id="M15"><mml:mrow><mml:mi>b</mml:mi><mml:msub><mml:mi>i</mml:mi><mml:mi>v</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width="0.2em"/><mml:mi>mod</mml:mi><mml:mspace width="0.2em"/><mml:mn>2.</mml:mn></mml:mrow></mml:math></disp-formula></p><p id="P90">Finally, we include partial coverage to above bi-imbalance formulations by limiting the incoming and outgoing arcs to <italic>F</italic>. Further, to distinguish between self-complemental nodes and others, we denote the set of self-complemental nodes as</p><p id="P91"><italic>S</italic> ⊆ <italic>V</italic> and the set of binodes that are not self-complemental as <italic>T := V \ S</italic>. If self-complemental biarcs are included in the flow, then these alter the bi-imbalance by two, in the same way as they do in the equation of the bi-imbalance. We encode this on the left side of the equation. Then we get the following modified coverage constraint: <disp-formula id="FD11"><label>(7)</label><mml:math id="M16"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mo>∀</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi><mml:mo>:</mml:mo><mml:mtext> </mml:mtext><mml:mspace width="0.2em"/><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>E</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>E</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>=</mml:mo><mml:mspace width="0.2em"/><mml:msubsup><mml:mi>d</mml:mi><mml:mi>F</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msubsup><mml:mi>d</mml:mi><mml:mi>F</mml:mi><mml:mo>−</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mi>F</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mi>F</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mtext>and</mml:mtext></mml:mrow></mml:math></disp-formula> <disp-formula id="FD12"><label>(8)</label><mml:math id="M17"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi><mml:mo>:</mml:mo><mml:mtext> </mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>d</mml:mi><mml:mi>F</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>E</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.2em"/><mml:mi>mod</mml:mi><mml:mspace width="0.2em"/><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:mn>0.</mml:mn></mml:mrow></mml:math></disp-formula></p></sec><sec id="S23"><title>Valid bidirected flow</title><p id="P92">To adapt Edmonds’ and Johnson’s formulation to biwalks, we additionally need to ensure that the resulting flow yields a set of biarcs, i.e. that each arc has the same flow as its reverse complement: <disp-formula id="FD13"><label>(9)</label><mml:math id="M18"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:math></disp-formula></p></sec><sec id="S24"><title>Adapted flow formulation</title><p id="P93">With the modifications above, we can adapt the formulation of Edmonds and Johnson to solve the bidirected partial-coverage Chinese postman problem. We define <italic>F</italic> to be the arcs in the original graph, and set <italic>E := V × V</italic>. We further set <italic>c<sub>e</sub> = 1</italic> for <italic>e ∈ F</italic> and <italic>c<sub>e</sub> = k – 1</italic> otherwise. Lastly we define <italic>s</italic> and T as above. Then we get the following modified formulation: <disp-formula id="FD14"><label>(5)</label><mml:math id="M19"><mml:mrow><mml:mi>min</mml:mi><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mspace width="0.2em"/><mml:mtext>is</mml:mtext><mml:mspace width="0.2em"/><mml:mtext>canonical</mml:mtext><mml:mspace width="0.2em"/></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mspace width="0.2em"/><mml:mtext>s</mml:mtext><mml:mo>.</mml:mo><mml:mtext>t</mml:mtext><mml:mspace width="0.2em"/></mml:mrow></mml:math></disp-formula> <disp-formula id="FD15"><label>(3)</label><mml:math id="M20"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mspace width="0.2em"/><mml:mtext>are</mml:mtext><mml:mspace width="0.2em"/><mml:mtext>non-negative</mml:mtext><mml:mspace width="0.2em"/><mml:mtext>integers</mml:mtext><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mtext>and</mml:mtext></mml:mrow></mml:math></disp-formula> <disp-formula id="FD16"><label>(6)</label><mml:math id="M21"><mml:mrow><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo>\</mml:mo><mml:mi>F</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mtext>and</mml:mtext></mml:mrow></mml:math></disp-formula> <disp-formula id="FD17"><label>(7)</label><mml:math id="M22"><mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mi>d</mml:mi><mml:mi>F</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msubsup><mml:mi>d</mml:mi><mml:mi>F</mml:mi><mml:mo>−</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mi>F</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>v</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mi>F</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mtext>and</mml:mtext></mml:mrow></mml:math></disp-formula> <disp-formula id="FD18"><label>(8)</label><mml:math id="M23"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi><mml:mo>:</mml:mo><mml:mtext> </mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>d</mml:mi><mml:mi>F</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>E</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.2em"/><mml:mi>mod</mml:mi><mml:mspace width="0.2em"/><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mtext>and</mml:mtext></mml:mrow></mml:math></disp-formula> <disp-formula id="FD19"><label>(9)</label><mml:math id="M24"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo>:</mml:mo><mml:mtext> </mml:mtext><mml:msub><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:math></disp-formula></p><p id="P94">In this min-cost integer flow formulation<sup><xref ref-type="fn" rid="FN12">[12]</xref></sup> of the bidirected partial-coverage Chinese postman problem, analogue to the formulation of Edmonds and Johnson, sources and sinks are nodes with missing outgoing or incoming arcs with demands matching the number of missing arcs in <italic>F</italic>. Our formulation would not be solvable for practical de-Bruijn graphs because inserting a quadratic amount of arcs into the graph is infeasible. However, most of the breaking arcs are not needed, since in a minimum solution they can only carry flow if they directly connect a source to a sink, by the following argument: Imagine a breaking arc that carries flow but is connected to a source or sink with at most one end. We can trace one unit of flow on the arc to a source and a sink, creating a path of flow one. By removing the flow from the path, and adding it to a breaking arc directly connecting the source to the sink, we get a valid flow. This flow has lower costs than the original, because it contains the same amount of breaking arcs, but a lower number of non-breaking arcs. This can be repeated until only breaking arcs that directly connect sources to sinks are left.</p><p id="P95">But even reducing the number of breaking arcs like this might not be enough if the graph contains too many sources and sinks. We therefore reduce the linear program to a min-cost matching instance, similar to Edmonds and Johnson.</p></sec></sec><sec id="S25"><label>5.6</label><title>Solving the min-cost integer flow formulation with min-cost matching</title><p id="P96">To solve the bidirected partial-coverage Chinese postman problem with min-cost matching, we observe that flow traverses the graph from a source to a sink only via min-cost paths, since all arcs have infinite capacity. Due to the existence of the breaking arcs with low cost (<italic>k</italic> – 1), we can further restrict the flow to use only paths of length at most <italic>k</italic> – 2 without affecting minimality. However, since we are also interested in a low number of strings in our minimum SPSS, we also allow paths of length <italic>k</italic> – 1. We can precompute these min-cost paths efficiently in parallel (see <xref ref-type="sec" rid="S26">Section 5.7</xref> below). Then it remains to decide which combination of min-cost paths and breaking arcs yield a minimum solution.</p><p id="P97">To simplify this problem, observe that the pairing of sources and sinks that are connected via breaking arcs does not matter. Any pairing uses the same amount of breaking arcs, and therefore has the same costs. It only matters that these nodes are not connected by a lower-cost path that does not use any breaking arcs, and that there is at least one breaking arc. As a result, we can ignore breaking arcs when searching a minimum solution, and instead introduce costs for unmatched nodes. However, we still need to enforce that there is at least one pair of unmatched nodes. We do this using a special construction described below. Note though, that there can only be unmatched nodes if there are unbalanced binodes, i.e. the graph was not biEulerian in the beginning. However, if the graph is biEulerian already, the whole matching step can be left out, and instead a biEulerian circuit with one arbitrarily inserted breaking biarc can be returned. So we can safely assume here that the graph contains at least one pair of unbalanced binodes<sup><xref ref-type="fn" rid="FN13">[13]</xref></sup>.</p><p id="P98">We formulate a min-cost matching problem with penalty costs for unmatched nodes, which can be reduced to a min-cost perfect matching problem. For the construction of our undirected matching graph <italic>M</italic> we define the set of sources <italic>A</italic> ⊆ <italic>T</italic> as all nodes with negative bi-imbalance, and the set of sinks <italic>B ⊆ T</italic> as all nodes with positive bi-imbalance. Then we add |bi<sub>v</sub> | (absolute value of the bi-imbalance of v) copies of each node from <italic>A</italic>, <italic>B</italic> and <italic>s</italic> to <italic>M</italic>. Further, for each min-cost path from a node a ∈ <italic>A</italic> ∪ <italic>S</italic> to a node <italic>b</italic> ∈ <italic>B</italic> ∪ <italic>S</italic> we add an edge (undirected arc) from each copy of <italic>a</italic> to each copy of <italic>b</italic> in <italic>M</italic> with costs equal to the costs of the path. We ignore self loops at nodes in <italic>s</italic> since they do not alter the imbalance, and nodes in <italic>A</italic> and <italic>B</italic> cannot have self loops.</p><p id="P99">Then, to fulfil Condition (9) (valid bidirected flow) and to reduce the size of the matching problem, we merge all nodes and arcs with their reverse complement (the unmerged graph is built here to simplify our explanations, in our implementation we directly build the merged graph). This additionally results in self-complemental biarcs forming self-loops in the merged graph, thus making them not chooseable by by the matcher. But this is correct, as self-complemental biarcs alter the biimbalance of a binode by two, and therefore they can only be chosen by matching two different copies of the same binode in <italic>M</italic>.</p><p id="P100">Additionally, to fulfil Condition (6) (cover one bidirected arc), we add a pair of nodes <italic>u</italic>, <italic>w</italic> to <italic>M</italic>. We connect <italic>u</italic> and <italic>w</italic> to each node in <italic>M</italic> (but do not add an edge between <italic>u</italic> and <italic>w</italic>) and assign costs 0 to all those edges. This forces <italic>u</italic> and <italic>w</italic> to be matched to other nodes <italic>u′</italic>, <italic>w′</italic>, which means that when biEulerising, the bi-imbalances of <italic>u′</italic> and <italic>w′</italic> need to be fixed with at least one breaking arc.</p><p id="P101">Lastly, we assign each node other than <italic>u</italic> and <italic>w</italic> penalty costs of (<italic>k</italic> – 1)/2 for staying unmatched, as each pair of unmatched nodes produces costs <italic>k</italic> – 1 for using a breaking arc.</p><p id="P102">We reduce <italic>M</italic> to an instance of the min-cost perfect matching problem using the reduction described in [<xref ref-type="bibr" rid="R64">64</xref>]. For that we duplicate the graph, and add an edge with costs <italic>k – 1</italic> <sup><xref ref-type="fn" rid="FN14">[14]</xref></sup> between each node and its copy, but not between <italic>v</italic> and <italic>w</italic> and their respective copies.</p><p id="P103">After this reduction, we use Blossom V [<xref ref-type="bibr" rid="R65">65</xref>] to compute a solution. Since all nodes were doubled in the reduction, we actually get two solutions that might even differ, however both of them are minimum. We arbitrarily choose one of the solutions. This gives us a multiset of arcs that we complete with the breaking arcs required to balance the unmatched nodes to create a biEulerisation of the input graph. Following the approach from Edmonds and Johnson, we find a biEulerian circuit in the resulting graph which is a solution to the bidirected partial-coverage Chinese postman problem as required.</p><p id="P104">Note that our matching formulation only optimises CL, but does not optimise SC. It indirectly optimises SC because it decreases CL by joining strings, which also decreases SC by one each time. However, when joining two strings would not alter CL, Blossom V may output both variants, with joining the strings and without, while staying optimal. It then chooses an arbitrary option.</p></sec><sec id="S26"><label>5.7</label><title>Efficient computation of many-to-many min-cost paths</title><p id="P105">Apart from solving the matching problem, finding the min-cost paths between sources and sinks is the most computationally heavy part of our algorithm.</p><p id="P106">We solve it using Dijkstra’s shortest path algorithm [<xref ref-type="bibr" rid="R66">66</xref>] in a one-to-many variant and execute it in parallel for all sources. To be efficient, we create a queue with blocks of source nodes, and the threads process one block at a time. A good block size balances between threads competing for access to the queue, and threads receiving a very imbalanced workload. Since our min-cost paths are short (at most <italic>k</italic> – 1 arcs), in most executions of Dijkstra’s algorithm only a tiny fraction of the nodes in the graph are visited. But the standard variant of Dijkstra’s algorithm wastefully allocates an array for all nodes to store their distance from the source node (the <italic>distance array</italic>). To save space, we instead use a hashmap, mapping from node_index to distance from source. This turned out to be faster than using a distance array, even if the distance array uses an epoch system<sup><xref ref-type="fn" rid="FN15">[15]</xref></sup> to only do a full reset every 2<sup>32</sup> queries. As another optimisation, we abort the execution early when Dijkstra reaches costs greater than <italic>k</italic> – 1, since we are only interested in paths up to costs <italic>k</italic> – 1.</p><p id="P107">Finally, in our implementation, we do not compute the actual sequences of arcs of the paths. Instead of copying the path arcs when biEulerising the graph, we insert special dummy arcs with a length equal to the length of the path. When breaking the final biEulerian circuit, if there are no breaking arcs but dummy arcs, then we break at a longest dummy arc to produce a minimum solution. If there are neither breaking nor dummy arcs, we proceed as described above. Then, when reporting the final set of strings, we define spell(⋅) to append the last t characters of b when encountering a dummy biarc [(<italic>a, b), (b<sup>–1</sup>, a<sup>–1</sup></italic>)] (or [(<italic>a, b</italic>)]) of length l.</p></sec><sec id="S27"><label>5.8</label><title>Efficient computation of the greedy heuristic</title><p id="P108">The greedy heuristic biEulerises the graph by greedily adding min-cost paths between unbalanced nodes, as opposed to choosing an optimal set via min-cost matching like our main algorithm. It then continues like the main algorithm, finding a biEulerian circuit, breaking it into walks and spelling out the strings.</p><p id="P109">To be efficient, the min-cost paths are again computed in parallel, and we apply all optimisations from <xref ref-type="sec" rid="S26">Section 5.7</xref>. The parallelism however poses a problem for the greedy computation: if a binode with one missing incoming biarc is reached by two min-cost paths in parallel, then if both threads add their respective biarcs, we would overshoot the bi-imbalance of that binode. To prevent that, we introduce a lock for each node, and before inserting a biarc into the graph we lock all (up to) four incident nodes. By locking the nodes in order of their ids we ensure that no deadlock can occur. Since the number of threads is many orders of magnitude lower than the number of nodes, we assume that threads almost never need to wait for each other. In addition to the parallelisation, we abort Dijkstra’s algorithm early when we have enough paths to fix the imbalance for the binode. This sometimes requires to execute Dijkstra’s algorithm again if a potential sink node was used by a different thread in parallel. But again, since the number of threads is many orders of magnitude lower than the number of nodes, we assume that this case almost never occurs.</p><p id="P110">In practice, the greedy heuristic achieves better results in terms of SC than the optimal matchtigs algorithm (see the Results sections). This is because the greedy heuristics always joins two strings if it does not alter CL, while the optimal algorithm does not, as explained in <xref ref-type="sec" rid="S25">Section 5.6</xref>.</p></sec><sec id="S28"><label>5.9</label><title>Minimising string count</title><p id="P111">In the paper we studied SPSSes of minimum total length (minimum CL). In this section we note that an SPSS with a minimum number of strings (minimum SC), and with no constraint on the total length, is also computable in polynomial time.</p><p id="P112">The high-level idea, ignoring reverse complements, is as follows. Given the arccentric de Bruijn graph <italic>G</italic>, construct the directed acyclic graph <italic>G</italic>* of strongly connected components (SCCs) of <italic>G</italic>. In <italic>G</italic>*, every SCC is a node, and we have as many arcs between two SCCs as there are pairs of nodes in the two SCCs with an arc between them. Clearly, all arcs in a single SCC are coverable by a single walk. Moreover, for two SCCs connected by an arc, their two covering walks can be connected via this arc into a single walk covering all arcs of both SCCs. Thus, the minimum number of walks needed to cover all arcs of <italic>G</italic>* (i.e., minimum SC SPSS) equals the minimum number of paths needed to cover all arcs of the acyclic graph <italic>G</italic>*. This is a classic problem solvable in polynomial time with network flows (see e.g. [<xref ref-type="bibr" rid="R67">67</xref>] among many).</p><p id="P113">However, such an SPSS of minimum SC very likely has a large CL, because covering an SCC with a single walk might repeat quadratically many arcs, and connecting the covering walks of two adjacent SCCs might additionally require to repeat many arcs to reach the arc between them.</p></sec><sec id="S29"><label>5.10</label><title>Experimental evaluation</title><p id="P114">We ran our experiments on a server running Linux with two 64-core AMD EPYC 7H12 processors with 2 logical cores per physical core, 1.96TiB RAM and an SSD. We downloaded the genomes of the model organisms from RefSeq [<xref ref-type="bibr" rid="R42">42</xref>]: Caenorhabditis elegans with accession GCF_000002985.6, Bombyx mori with accession GCF_000151625.1 and Homo sapiens with accession GCF_000001405.39. These are the same genomes as in [<xref ref-type="bibr" rid="R43">43</xref>], except that we downloaded HG38 from RefSeq for citability. The short reads were downloaded from the sequence read archive [<xref ref-type="bibr" rid="R68">68</xref>]: Caenorhabditis elegans with accession SRR14447868.1, Bombyx mori with accession DRR064025.1 and Homo sapiens with accessions SRR2052337.1 to SRR2052425.1.</p><p id="P115">For the pangenomes we downloaded the 616 Streptococcus pneumoniae genomes from the sequence read archive, using the accession codes provided in <xref ref-type="table" rid="T1">Table 1</xref> in [<xref ref-type="bibr" rid="R69">69</xref>]. We downloaded the 1102 Neisseria gonorrhoeae genomes from [<xref ref-type="bibr" rid="R70">70</xref>]. Up to here the pangenomes are retrieved in the same way as in [<xref ref-type="bibr" rid="R43">43</xref>]. We additionally used grep to select 3682 Escherichia coli genomes from <ext-link ext-link-type="ftp" xlink:href="ftp://ftp.ncbi.nlm.nih.gov/genomes/genbank/bacteria/assembly_summary.txt">ftp://ftp.ncbi.nlm.nih.gov/genomes/genbank/bacteria/assembly_summary.txt</ext-link>. The ~309<italic>k</italic> salmonella genome sequences were downloaded from the EnteroBase database [<xref ref-type="bibr" rid="R71">71</xref>], gzipped<sup><xref ref-type="fn" rid="FN16">[16]</xref></sup>. The 2505x human pangenome is from the 1000 genomes project [<xref ref-type="bibr" rid="R72">72</xref>], created by downloading a variant of GRCh37 from <ext-link ext-link-type="ftp" xlink:href="ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/reference/phase2_reference_assembly_sequence/hs37d5.fa.gz">ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/reference/phase2_reference_assembly_sequence/hs37d5.fa.gz</ext-link> and downloading variant files for chromosomes 1-22 from <ext-link ext-link-type="uri" xlink:href="http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/">http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/</ext-link>. We then converted chromosomes 1-22 in the reference into 2505 sequences each using the tool vcf2multialign published in [<xref ref-type="bibr" rid="R73">73</xref>].</p><p id="P116">For querying the human read dataset, we used 3 million reads randomly drawn from the reads used to construct the dataset. For querying the Salmonella pangenome, we used 3 million randomly drawn short reads from 10 read data sets from the sequence read archive with the accessions listed in <xref ref-type="supplementary-material" rid="SD9">Additional file 9</xref>. For querying the human pangenome, we used 3 million randomly drawn short reads from one file of the sequence read archive with accession SRR2052337.1. This is one of the files from the human short read dataset described above. For querying the E.coli pangenome (in <xref ref-type="supplementary-material" rid="SD6">Additional file 6</xref>) we used 30 short read data sets from the sequence read archive with the accessions listed in <xref ref-type="supplementary-material" rid="SD7">Additional file 7</xref>.</p><p id="P117">We used snakemake [<xref ref-type="bibr" rid="R74">74</xref>] and the bioconda software repository [<xref ref-type="bibr" rid="R75">75</xref>] to craft our experiment pipeline. The tigs were checked for correctness by checking the kmer sets against unitigs. The bifrost queries in <xref ref-type="supplementary-material" rid="SD6">Additional file 6</xref> were checked for correctness by checking that the query results are equivalent for those with unitigs. The SSHash queries were not checked for correctness, as SSHash was modified by the author himself. Whenever we measured runtime of queries and builds for <xref ref-type="supplementary-material" rid="SD5">Additional file 5</xref> (Performance with different amounts of threads), we only let a single experiment run, even if the experiment used only one core. When running the other builds we ran multiple processes at the same time, but never using more threads than the processor has physical cores (thus avoiding any effects introduced by sharing logical cores). When running a tool we copied its input to the SSD, and copied the results back to our main network storage, to prevent the network storage’s varying workload to affect our runtime measurements. For experiments running on input reads or references as opposed to unitigs (BCALM2, ProphAsm), we copied the inputs to a RAID of HDDs instead, due to their large size. The copying was not part of the measurements. We made sure that the server is undisturbed, except that we monitored the experiment status and progress with htop and less. We limited each run to 256GiB of RAM per process, which prevented us from running matchtigs on larger inputs. Further, ProphAsm supports only <italic>k</italic> ≤ 32, so it was not run for <italic>k</italic> larger than that.</p><p id="P118">For an overview of our experiment pipeline for computing tigs, see <xref ref-type="fig" rid="F5">Figure 5</xref>. We run ProphAsm on the input data, as it was introduced to do [<xref ref-type="bibr" rid="R43">43</xref>]. All other tools require unitigs to be computed first. UST specifically requires unitigs computed by BCALM2, as BCALM2 adds additional annotations to the fasta unitig file. Our tool matchtigs also can make use of these annotations to speed up the construction of the arc-centric de Bruijn graph. On the human pangenome, BCALM2 crashed due to the input being too large. Hence we used Cuttlefish 2 [<xref ref-type="bibr" rid="R40">40</xref>] to compute unitigs, and since UST only runs on unitigs computed by BCALM2, we then ran ProphAsm to compute heuristic simplitigs.</p><p id="P119">For queries, we executed Bifrost or SSHash-Lite on the different tigs. The Bifrost query command handles both building the index and executing the query, while SSHash-Lite requires to run a separate command to build the index first.</p><p id="P120">See Section <italic>Availability of data and materials</italic> for availability of our implementation and experiment code, which includes all the concrete commands we have used to execute our experiments.</p></sec></sec><sec sec-type="supplementary-material" id="SM"><title>Supplementary Material</title><supplementary-material content-type="local-data" id="SD1"><label>Additional file 1</label><media xlink:href="EMS157437-supplement-Additional_file_1.pdf" mimetype="application" mime-subtype="pdf" id="d32aAdFbB" position="anchor"/></supplementary-material><supplementary-material content-type="local-data" id="SD2"><label>Additional file 2</label><media xlink:href="EMS157437-supplement-Additional_file_2.pdf" mimetype="application" mime-subtype="pdf" id="d32aAdFcB" position="anchor"/></supplementary-material><supplementary-material content-type="local-data" id="SD3"><label>Additional file 3</label><media xlink:href="EMS157437-supplement-Additional_file_3.pdf" mimetype="application" mime-subtype="pdf" id="d32aAdFdB" position="anchor"/></supplementary-material><supplementary-material content-type="local-data" id="SD4"><label>Additional file 4</label><media xlink:href="EMS157437-supplement-Additional_file_4.pdf" mimetype="application" mime-subtype="pdf" id="d32aAdFeB" position="anchor"/></supplementary-material><supplementary-material content-type="local-data" id="SD5"><label>Additional file 5</label><media xlink:href="EMS157437-supplement-Additional_file_5.pdf" mimetype="application" mime-subtype="pdf" id="d32aAdFfB" position="anchor"/></supplementary-material><supplementary-material content-type="local-data" id="SD6"><label>Additional file 6</label><media xlink:href="EMS157437-supplement-Additional_file_6.pdf" mimetype="application" mime-subtype="pdf" id="d32aAdFgB" position="anchor"/></supplementary-material><supplementary-material content-type="local-data" id="SD7"><label>Additional file 7</label><media xlink:href="EMS157437-supplement-Additional_file_7.txt" mimetype="text" mime-subtype="plain; charset=utf-8" id="d32aAdFhB" position="anchor"/></supplementary-material><supplementary-material content-type="local-data" id="SD8"><label>Additional file 8</label><media xlink:href="EMS157437-supplement-Additional_file_8.pdf" mimetype="application" mime-subtype="pdf" id="d32aAdFiB" position="anchor"/></supplementary-material><supplementary-material content-type="local-data" id="SD9"><label>Additional file 9</label><media xlink:href="EMS157437-supplement-Additional_file_9.txt" mimetype="text" mime-subtype="plain; charset=utf-8" id="d32aAdFjB" position="anchor"/></supplementary-material><supplementary-material content-type="local-data" id="SD10"><label>Additional file 10</label><media xlink:href="EMS157437-supplement-Additional_file_10.pdf" mimetype="application" mime-subtype="pdf" id="d32aAdFkB" position="anchor"/></supplementary-material></sec></body><back><ack id="S30"><title>Acknowledgements</title><p>We are very grateful to Paul Medvedev and Amatur Rahman for helpful initial discussions on this problem. We further wish to thank the Finnish Computing Competence Infrastructure (FCCI) for supporting this project with computational and data storage resources. We also wish to thank Andrea Cracco for providing us with the <sub>~</sub>309kx Salmonella pangenome. We further wish to thank the anonymous reviewers for there useful constructive feedback, which improved the presentation of the paper, the implementation and the experimental results. Finally we wish to thank the Rust community (<ext-link ext-link-type="uri" xlink:href="https://users.rust-lang.org">https://users.rust-lang.org</ext-link>) for explanations about language-specific details of parallel implementations.</p><sec id="S31"><title>Funding</title><p>This work was partially funded by the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement No. 851093, SAFEBIO), and by the Academy of Finland (grants No. 322595, 328877). This work was also partially supported by the project MobiDataLab (EU H2020 RIA, grant agreement N_101006879).</p></sec></ack><sec id="S32" sec-type="data-availability"><title>Availability</title><p id="P121">matchtigs: <ext-link ext-link-type="uri" xlink:href="https://github.com/algbio/matchtigs">https://github.com/algbio/matchtigs</ext-link></p><p id="P122">SSHash-Lite: <ext-link ext-link-type="uri" xlink:href="https://github.com/jermp/sshash-lite">https://github.com/jermp/sshash-lite</ext-link></p></sec><sec id="S33" sec-type="data-availability"><title>Availability of data and materials</title><p id="P123">The implementation of the matchtigs and greedy matchtigs algorithms is available on github at <ext-link ext-link-type="uri" xlink:href="https://github.com/algbio/matchtigs">https://github.com/algbio/matchtigs</ext-link>. The name of the project is <italic>matchtigs</italic>. It is platform independent, and can be compiled locally or installed from bioconda as described in the README of the project. It is licensed under the 2-clause BSD license. The version used for our experiments is available at <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.7275977">https://doi.org/10.5281/zenodo.7275977</ext-link>, and the implementation together with all code to reproduce the experiments is available at <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.7275990">https://doi.org/10.5281/zenodo.7275990</ext-link>. The experiment code is also licensed under the 2-clause BSD license. SSHash-Lite is available at <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.7277145">https://doi.org/10.5281/zenodo.7277145</ext-link> and licensed under the MIT license. See <xref ref-type="sec" rid="S29">Section 5.10</xref> for the availability of the non-original data used for our experiments.</p></sec><fn-group><fn id="FN1"><label>[1]</label><p id="P124">Our own observation.</p></fn><fn id="FN2"><label>[2]</label><p id="P125">In [<xref ref-type="bibr" rid="R44">44</xref>], an SPSS is defined for a given set of kmers as a set of strings that contains the same spectrum of kmers, where the spectrum is defined as a multiset. Since plain text representation has the great advantage that some tools (like e.g. Bifrost’s query [<xref ref-type="bibr" rid="R23">23</xref>]) can use it without modification. We expect that even those tools that require modifications would not be hard to modify (like e.g. SSHash [<xref ref-type="bibr" rid="R45">45</xref>] which we modified here as an example).</p></fn><fn id="FN3"><label>[3]</label><p id="P126">There might even be cases where by increasing CL and decreasing SC, the overall size of the representation of the string set (strings + index structure) can be decreased. To stay independent of any specific data structure we only optimise CL. required when storing heuristic simplitigs compressed with general-purpose compressors over storing unitigs compressed in the same way. Rahman and Medvedev show a significant reduction in SC and CL on various data sets as well, and also show a reduction in space required to store heuristic simplitigs over unitigs when compressed with general-purpose compressors.</p></fn><fn id="FN4"><label>[4]</label><p id="P127">While this paper was under review, Schmidt and Alanko realised that the algorithm to compute matchtigs can also be used to compute optimal simplitigs, by leaving out all parts related to repeating kmers. The matchtig algorithm can hence be seen as an extension to the Eulertig algorithm, even if the former was discovered first.</p></fn><fn id="FN5"><label>[5]</label><p id="P128">Personal communication by Andrea Cracco.</p></fn><fn id="FN6"><label>[6]</label><p id="P129">ProphAsm supports only <italic>k</italic> ≤ 32 such that a comparison is often impossible. But where it is possible, it performs only slightly better than UST in terms of CL and SC.</p></fn><fn id="FN7"><label>[7]</label><p id="P130"><ext-link ext-link-type="uri" xlink:href="https://github.com/algbio/matchtigs">https://github.com/algbio/matchtigs</ext-link></p></fn><fn id="FN8"><label>[8]</label><p id="P131">The code is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/jermp/sshash-lite">https://github.com/jermp/sshash-lite</ext-link>.</p></fn><fn id="FN9"><label>[9]</label><p id="P132">This is because there may be multiple circular original-biarc-covering biwalks with minimum costs, but with different repeated kmers. When breaking the walk by removing a longer sequence of repeated kmers, the resulting string gets shorter, the more repeated kmers get removed.</p></fn><fn id="FN10"><label>[10]</label><p id="P133">Either by connecting nodes with missing outgoing arcs directly to nodes with missing incoming arcs, or by connecting them via a path of multiple arcs.</p></fn><fn id="FN11"><label>[11]</label><p id="P134">Since the labels of an arc are of length <italic>k</italic> and those of a node are of length k-1, only one can have even length, so only one can be self-complemental for DNA alphabets.</p></fn><fn id="FN12"><label>[12]</label><p id="P135">It is conceptually similar to that proposed in [<xref ref-type="bibr" rid="R56">56</xref>], however different because the basic definitions differ, and we further allow for special arcs of which only one needs to be covered.</p></fn><fn id="FN13"><label>[13]</label><p id="P136">It cannot contain a single unbalanced binode, see e.g.[<xref ref-type="bibr" rid="R47">47</xref>]</p></fn><fn id="FN14"><label>[14]</label><p id="P137">By duplicating the graph, virtually each edge’s costs are doubled, since each edge exists twice afterwards. However, the edges between nodes and their duplicate exist only once, so their costs require doubling.</p></fn><fn id="FN15"><label>[15]</label><p id="P138">An epoch system stores a second value for each entry in the distance array indicating in what execution of Dijkstra’s algorithm that value is valid. The execution counter gets incremented each execution, and only when it wraps around, the distance array is reset normally. Whenever an entry in the distance array is read, the value infinity is returned if the execution counter does not match the execution saved for the entry in the distance array. Whenever an entry in the distance array is written, the corresponding execution value is set to the current value of the execution counter.</p></fn><fn id="FN16"><label>[16]</label><p id="P139">Downloaded in February 2022.</p></fn><fn id="FN17" fn-type="conflict"><p id="P140"><bold>Competing interests</bold></p><p id="P141">The authors declare that they have no competing interests.</p></fn><fn id="FN18" fn-type="con"><p id="P142"><bold>Authors’ contributions</bold></p><p id="P143">SK and AIT formulated the problem. AIT and SK designed an optimal algorithm and SK implemented and evaluated its prototype. Thereafter, SS improved the algorithm’s design to its current form and provided the final implementation as well as optimisations required to make it practically relevant. SS developed the greedy heuristic and implemented it. JA, SS and AIT designed the experiments and interpreted the results. SS performed all experiments, and developed all further code published in the context of this work. SS wrote the manuscript under the supervision of the other authors, except for <xref ref-type="sec" rid="S10">Section 2.5</xref>. GEP created and described SSHash-Lite in <xref ref-type="sec" rid="S10">Section 2.5</xref> and ran the query experiments on the machine with focus on single-core performance. All authors reviewed and approved the final version of the manuscript.</p></fn></fn-group><ref-list><ref id="R1"><label>1</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zielezinski</surname><given-names>A</given-names></name><name><surname>Vinga</surname><given-names>S</given-names></name><name><surname>Almeida</surname><given-names>J</given-names></name><name><surname>Karlowski</surname><given-names>WM</given-names></name></person-group><article-title>Alignment-free sequence comparison: benefits, applications, and tools</article-title><source>Genome Biology</source><year>2017</year><volume>18</volume><issue>1</issue><fpage>1</fpage><lpage>17</lpage><pub-id pub-id-type="pmcid">PMC5627421</pub-id><pub-id pub-id-type="pmid">28974235</pub-id><pub-id pub-id-type="doi">10.1186/s13059-017-1319-7</pub-id></element-citation></ref><ref id="R2"><label>2</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zielezinski</surname><given-names>A</given-names></name><name><surname>Girgis</surname><given-names>HZ</given-names></name><name><surname>Bernard</surname><given-names>G</given-names></name><name><surname>Leimeister</surname><given-names>C-A</given-names></name><name><surname>Tang</surname><given-names>K</given-names></name><name><surname>Dencker</surname><given-names>T</given-names></name><name><surname>Lau</surname><given-names>AK</given-names></name><name><surname>Rohling</surname><given-names>S</given-names></name><name><surname>Choi</surname><given-names>JJ</given-names></name><name><surname>Waterman</surname><given-names>MS</given-names></name><etal/></person-group><article-title>Benchmarking of alignment-free sequence comparison methods</article-title><source>Genome Biology</source><year>2019</year><volume>20</volume><issue>1</issue><fpage>1</fpage><lpage>18</lpage><pub-id pub-id-type="pmcid">PMC6659240</pub-id><pub-id pub-id-type="pmid">31345254</pub-id><pub-id pub-id-type="doi">10.1186/s13059-019-1755-7</pub-id></element-citation></ref><ref id="R3"><label>3</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Luhmann</surname><given-names>N</given-names></name><name><surname>Holley</surname><given-names>G</given-names></name><name><surname>Achtman</surname><given-names>M</given-names></name></person-group><article-title>Blastfrost: fast querying of 100,000 s of bacterial genomes in bifrost graphs</article-title><source>Genome Biology</source><year>2021</year><volume>22</volume><issue>1</issue><fpage>1</fpage><lpage>15</lpage><pub-id pub-id-type="pmcid">PMC7798312</pub-id><pub-id pub-id-type="pmid">33430919</pub-id><pub-id pub-id-type="doi">10.1186/s13059-020-02237-3</pub-id></element-citation></ref><ref id="R4"><label>4</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Iqbal</surname><given-names>Z</given-names></name><name><surname>Caccamo</surname><given-names>M</given-names></name><name><surname>Turner</surname><given-names>I</given-names></name><name><surname>Flicek</surname><given-names>P</given-names></name><name><surname>McVean</surname><given-names>G</given-names></name></person-group><article-title>De novo assembly and genotyping of variants using colored de Bruijn graphs</article-title><source>Nature Genetics</source><year>2012</year><volume>44</volume><issue>2</issue><fpage>226</fpage><lpage>232</lpage><pub-id pub-id-type="pmcid">PMC3272472</pub-id><pub-id pub-id-type="pmid">22231483</pub-id><pub-id pub-id-type="doi">10.1038/ng.1028</pub-id></element-citation></ref><ref id="R5"><label>5</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nordstrom</surname><given-names>KJ</given-names></name><name><surname>Albani</surname><given-names>MC</given-names></name><name><surname>James</surname><given-names>GV</given-names></name><name><surname>Gutjahr</surname><given-names>C</given-names></name><name><surname>Hartwig</surname><given-names>B</given-names></name><name><surname>Turck</surname><given-names>F</given-names></name><name><surname>Paszkowski</surname><given-names>U</given-names></name><name><surname>Coupland</surname><given-names>G</given-names></name><name><surname>Schneeberger</surname><given-names>K</given-names></name></person-group><article-title>Mutation identification by direct comparison of whole-genome sequencing data from mutant and wild-type individuals using k-mers</article-title><source>Nature Biotechnology</source><year>2013</year><volume>31</volume><issue>4</issue><fpage>325</fpage><lpage>330</lpage><pub-id pub-id-type="pmid">23475072</pub-id></element-citation></ref><ref id="R6"><label>6</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bradley</surname><given-names>P</given-names></name><name><surname>Gordon</surname><given-names>NC</given-names></name><name><surname>Walker</surname><given-names>TM</given-names></name><name><surname>Dunn</surname><given-names>L</given-names></name><name><surname>Heys</surname><given-names>S</given-names></name><name><surname>Huang</surname><given-names>B</given-names></name><name><surname>Earle</surname><given-names>S</given-names></name><name><surname>Pankhurst</surname><given-names>LJ</given-names></name><name><surname>Anson</surname><given-names>L</given-names></name><name><surname>De Cesare</surname><given-names>M</given-names></name><etal/></person-group><article-title>Rapid antibiotic-resistance predictions from genome sequence data for staphylococcus aureus and mycobacterium tuberculosis</article-title><source>Nature Communications</source><year>2015</year><volume>6</volume><issue>1</issue><fpage>1</fpage><lpage>15</lpage><pub-id pub-id-type="pmcid">PMC4703848</pub-id><pub-id pub-id-type="pmid">26686880</pub-id><pub-id pub-id-type="doi">10.1038/ncomms10063</pub-id></element-citation></ref><ref id="R7"><label>7</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Shajii</surname><given-names>A</given-names></name><name><surname>Yorukoglu</surname><given-names>D</given-names></name><name><surname>William Yu</surname><given-names>Y</given-names></name><name><surname>Berger</surname><given-names>B</given-names></name></person-group><article-title>Fast genotyping of known snps through approximate k-mer matching</article-title><source>Bioinformatics</source><year>2016</year><volume>32</volume><issue>17</issue><fpage>538</fpage><lpage>544</lpage><pub-id pub-id-type="pmcid">PMC5013917</pub-id><pub-id pub-id-type="pmid">27587672</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btw460</pub-id></element-citation></ref><ref id="R8"><label>8</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sun</surname><given-names>C</given-names></name><name><surname>Medvedev</surname><given-names>P</given-names></name></person-group><article-title>Toward fast and accurate snp genotyping from whole genome sequencing data for bedside diagnostics</article-title><source>Bioinformatics</source><year>2019</year><volume>35</volume><issue>3</issue><fpage>415</fpage><lpage>420</lpage><pub-id pub-id-type="pmid">30032192</pub-id></element-citation></ref><ref id="R9"><label>9</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bray</surname><given-names>NL</given-names></name><name><surname>Pimentel</surname><given-names>H</given-names></name><name><surname>Melsted</surname><given-names>P</given-names></name><name><surname>Pachter</surname><given-names>L</given-names></name></person-group><article-title>Near-optimal probabilistic rna-seq quantification</article-title><source>Nature Biotechnology</source><year>2016</year><volume>34</volume><issue>5</issue><fpage>525</fpage><lpage>527</lpage><pub-id pub-id-type="pmid">27043002</pub-id></element-citation></ref><ref id="R10"><label>10</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ames</surname><given-names>SK</given-names></name><name><surname>Hysom</surname><given-names>DA</given-names></name><name><surname>Gardner</surname><given-names>SN</given-names></name><name><surname>Lloyd</surname><given-names>GS</given-names></name><name><surname>Gokhale</surname><given-names>MB</given-names></name><name><surname>Allen</surname><given-names>JE</given-names></name></person-group><article-title>Scalable metagenomic taxonomy classification using a reference genome database</article-title><source>Bioinformatics</source><year>2013</year><volume>29</volume><issue>18</issue><fpage>2253</fpage><lpage>2260</lpage><pub-id pub-id-type="pmcid">PMC3753567</pub-id><pub-id pub-id-type="pmid">23828782</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btt389</pub-id></element-citation></ref><ref id="R11"><label>11</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wood</surname><given-names>DE</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name></person-group><article-title>Kraken: ultrafast metagenomic sequence classification using exact alignments</article-title><source>Genome Biology</source><year>2014</year><volume>15</volume><issue>3</issue><fpage>1</fpage><lpage>12</lpage><pub-id pub-id-type="pmcid">PMC4053813</pub-id><pub-id pub-id-type="pmid">24580807</pub-id><pub-id pub-id-type="doi">10.1186/gb-2014-15-3-r46</pub-id></element-citation></ref><ref id="R12"><label>12</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Břinda</surname><given-names>K</given-names></name><name><surname>Salikhov</surname><given-names>K</given-names></name><name><surname>Pignotti</surname><given-names>S</given-names></name><name><surname>Kucherov</surname><given-names>G</given-names></name></person-group><article-title>Prophyle: a phylogeny-based metagenomic classifier using the burrows-wheeler transform</article-title><source>Poster at HiTSeq</source><year>2017</year><issue>2017</issue></element-citation></ref><ref id="R13"><label>13</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Corvelo</surname><given-names>A</given-names></name><name><surname>Clarke</surname><given-names>WE</given-names></name><name><surname>Robine</surname><given-names>N</given-names></name><name><surname>Zody</surname><given-names>MC</given-names></name></person-group><article-title>taxmaps: comprehensive and highly accurate taxonomic classification of short-read data in reasonable time</article-title><source>Genome Research</source><year>2018</year><volume>28</volume><issue>5</issue><fpage>751</fpage><lpage>758</lpage><pub-id pub-id-type="pmcid">PMC5932614</pub-id><pub-id pub-id-type="pmid">29588360</pub-id><pub-id pub-id-type="doi">10.1101/gr.225276.117</pub-id></element-citation></ref><ref id="R14"><label>14</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Simon</surname><given-names>HY</given-names></name><name><surname>Siddle</surname><given-names>KJ</given-names></name><name><surname>Park</surname><given-names>DJ</given-names></name><name><surname>Sabeti</surname><given-names>PC</given-names></name></person-group><article-title>Benchmarking metagenomics tools for taxonomic classification</article-title><source>Cell</source><year>2019</year><volume>178</volume><issue>4</issue><fpage>779</fpage><lpage>794</lpage><pub-id pub-id-type="pmcid">PMC6716367</pub-id><pub-id pub-id-type="pmid">31398336</pub-id><pub-id pub-id-type="doi">10.1016/j.cell.2019.07.010</pub-id></element-citation></ref><ref id="R15"><label>15</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Sirén</surname><given-names>J</given-names></name></person-group><source>Indexing variation graphs</source><conf-name>2017 Proceedings of the Ninteenth Workshop on Algorithm Engineering and Experiments (ALENEX)</conf-name><conf-sponsor>SIAM</conf-sponsor><year>2017</year><fpage>13</fpage><lpage>27</lpage></element-citation></ref><ref id="R16"><label>16</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Garrison</surname><given-names>E</given-names></name><name><surname>Sirén</surname><given-names>J</given-names></name><name><surname>Novak</surname><given-names>AM</given-names></name><name><surname>Hickey</surname><given-names>G</given-names></name><name><surname>Eizenga</surname><given-names>JM</given-names></name><name><surname>Dawson</surname><given-names>ET</given-names></name><name><surname>Jones</surname><given-names>W</given-names></name><name><surname>Garg</surname><given-names>S</given-names></name><name><surname>Markello</surname><given-names>C</given-names></name><name><surname>Lin</surname><given-names>MF</given-names></name><etal/></person-group><article-title>Variation graph toolkit improves read mapping by representing genetic variation in the reference</article-title><source>Nature Biotechnology</source><year>2018</year><volume>36</volume><issue>9</issue><fpage>875</fpage><lpage>879</lpage><pub-id pub-id-type="pmcid">PMC6126949</pub-id><pub-id pub-id-type="pmid">30125266</pub-id><pub-id pub-id-type="doi">10.1038/nbt.4227</pub-id></element-citation></ref><ref id="R17"><label>17</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Benoit</surname><given-names>G</given-names></name></person-group><article-title>Simka: fast kmer-based method for estimating the similarity between numerous metagenomic datasets</article-title><source>RCAM</source><year>2015</year></element-citation></ref><ref id="R18"><label>18</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>David</surname><given-names>S</given-names></name><name><surname>Mentasti</surname><given-names>M</given-names></name><name><surname>Tewolde</surname><given-names>R</given-names></name><name><surname>Aslett</surname><given-names>M</given-names></name><name><surname>Harris</surname><given-names>SR</given-names></name><name><surname>Afshar</surname><given-names>B</given-names></name><name><surname>Underwood</surname><given-names>A</given-names></name><name><surname>Fry</surname><given-names>NK</given-names></name><name><surname>Parkhill</surname><given-names>J</given-names></name><name><surname>Harrison</surname><given-names>TG</given-names></name></person-group><article-title>Evaluation of an optimal epidemiological typing scheme for legionella pneumophila with whole-genome sequence data using validation guidelines</article-title><source>Journal of clinical microbiology</source><year>2016</year><volume>54</volume><issue>8</issue><fpage>2135</fpage><lpage>2148</lpage><pub-id pub-id-type="pmcid">PMC4963484</pub-id><pub-id pub-id-type="pmid">27280420</pub-id><pub-id pub-id-type="doi">10.1128/JCM.00432-16</pub-id></element-citation></ref><ref id="R19"><label>19</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chattaway</surname><given-names>MA</given-names></name><name><surname>Schaefer</surname><given-names>U</given-names></name><name><surname>Tewolde</surname><given-names>R</given-names></name><name><surname>Dallman</surname><given-names>TJ</given-names></name><name><surname>Jenkins</surname><given-names>C</given-names></name></person-group><article-title>Identification of escherichia coli and shigella species from whole-genome sequences</article-title><source>Journal of clinical microbiology</source><year>2017</year><volume>55</volume><issue>2</issue><fpage>616</fpage><lpage>623</lpage><pub-id pub-id-type="pmcid">PMC5277532</pub-id><pub-id pub-id-type="pmid">27974538</pub-id><pub-id pub-id-type="doi">10.1128/JCM.01790-16</pub-id></element-citation></ref><ref id="R20"><label>20</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Clausen</surname><given-names>PT</given-names></name><name><surname>Aarestrup</surname><given-names>FM</given-names></name><name><surname>Lund</surname><given-names>O</given-names></name></person-group><article-title>Rapid and precise alignment of raw reads against redundant databases with kma</article-title><source>BMC bioinformatics</source><year>2018</year><volume>19</volume><issue>1</issue><fpage>1</fpage><lpage>8</lpage><pub-id pub-id-type="pmcid">PMC6116485</pub-id><pub-id pub-id-type="pmid">30157759</pub-id><pub-id pub-id-type="doi">10.1186/s12859-018-2336-6</pub-id></element-citation></ref><ref id="R21"><label>21</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pandey</surname><given-names>P</given-names></name><name><surname>Almodaresi</surname><given-names>F</given-names></name><name><surname>Bender</surname><given-names>MA</given-names></name><name><surname>Ferdman</surname><given-names>M</given-names></name><name><surname>Johnson</surname><given-names>R</given-names></name><name><surname>Patro</surname><given-names>R</given-names></name></person-group><article-title>Mantis: A fast, small, and exact large-scale sequence-search index</article-title><source>Cell systems</source><year>2018</year><volume>7</volume><issue>2</issue><fpage>201</fpage><lpage>207</lpage><pub-id pub-id-type="pmid">29936185</pub-id></element-citation></ref><ref id="R22"><label>22</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Marchet</surname><given-names>C</given-names></name><name><surname>Kerbiriou</surname><given-names>M</given-names></name><name><surname>Limasset</surname><given-names>A</given-names></name></person-group><source>Indexing De Bruijn graphs with minimizers</source><conf-name>Recomb-Seq 2019-9th RECOMB Satellite Workshop on Massively Parallel Sequencing</conf-name><year>2019</year><fpage>1</fpage><lpage>16</lpage></element-citation></ref><ref id="R23"><label>23</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Holley</surname><given-names>G</given-names></name><name><surname>Melsted</surname><given-names>P</given-names></name></person-group><article-title>Bifrost: highly parallel construction and indexing of colored and compacted de Bruijn graphs</article-title><source>Genome Biology</source><year>2020</year><volume>21</volume><issue>1</issue><fpage>1</fpage><lpage>20</lpage><pub-id pub-id-type="pmcid">PMC7499882</pub-id><pub-id pub-id-type="pmid">32943081</pub-id><pub-id pub-id-type="doi">10.1186/s13059-020-02135-8</pub-id></element-citation></ref><ref id="R24"><label>24</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pevzner</surname><given-names>PA</given-names></name></person-group><article-title>l-Tuple DNA sequencing: computer analysis</article-title><source>Journal of Biomolecular structure and dynamics</source><year>1989</year><volume>7</volume><issue>1</issue><fpage>63</fpage><lpage>73</lpage><pub-id pub-id-type="pmid">2684223</pub-id></element-citation></ref><ref id="R25"><label>25</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Idury</surname><given-names>RM</given-names></name><name><surname>Waterman</surname><given-names>MS</given-names></name></person-group><article-title>A new algorithm for DNA sequence assembly</article-title><source>Journal of Computational Biology</source><year>1995</year><volume>2</volume><issue>2</issue><fpage>291</fpage><lpage>306</lpage><pub-id pub-id-type="pmid">7497130</pub-id></element-citation></ref><ref id="R26"><label>26</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pevzner</surname><given-names>PA</given-names></name><name><surname>Tang</surname><given-names>H</given-names></name><name><surname>Waterman</surname><given-names>MS</given-names></name></person-group><article-title>An Eulerian path approach to DNA fragment assembly</article-title><source>Proceedings of the National Academy of Sciences</source><year>2001</year><volume>98</volume><issue>17</issue><fpage>9748</fpage><lpage>9753</lpage><pub-id pub-id-type="pmcid">PMC55524</pub-id><pub-id pub-id-type="pmid">11504945</pub-id><pub-id pub-id-type="doi">10.1073/pnas.171285098</pub-id></element-citation></ref><ref id="R27"><label>27</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chaisson</surname><given-names>MJ</given-names></name><name><surname>Pevzner</surname><given-names>PA</given-names></name></person-group><article-title>Short read fragment assembly of bacterial genomes</article-title><source>Genome Research</source><year>2008</year><volume>18</volume><issue>2</issue><fpage>324</fpage><lpage>330</lpage><pub-id pub-id-type="pmcid">PMC2203630</pub-id><pub-id pub-id-type="pmid">18083777</pub-id><pub-id pub-id-type="doi">10.1101/gr.7088808</pub-id></element-citation></ref><ref id="R28"><label>28</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Simpson</surname><given-names>JT</given-names></name><name><surname>Wong</surname><given-names>K</given-names></name><name><surname>Jackman</surname><given-names>SD</given-names></name><name><surname>Schein</surname><given-names>JE</given-names></name><name><surname>Jones</surname><given-names>SJ</given-names></name><name><surname>Birol</surname><given-names>I</given-names></name></person-group><article-title>Abyss: a parallel assembler for short read sequence data</article-title><source>Genome Research</source><year>2009</year><volume>19</volume><issue>6</issue><fpage>1117</fpage><lpage>1123</lpage><pub-id pub-id-type="pmcid">PMC2694472</pub-id><pub-id pub-id-type="pmid">19251739</pub-id><pub-id pub-id-type="doi">10.1101/gr.089532.108</pub-id></element-citation></ref><ref id="R29"><label>29</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>R</given-names></name><name><surname>Zhu</surname><given-names>H</given-names></name><name><surname>Ruan</surname><given-names>J</given-names></name><name><surname>Qian</surname><given-names>W</given-names></name><name><surname>Fang</surname><given-names>X</given-names></name><name><surname>Shi</surname><given-names>Z</given-names></name><name><surname>Li</surname><given-names>Y</given-names></name><name><surname>Li</surname><given-names>S</given-names></name><name><surname>Shan</surname><given-names>G</given-names></name><name><surname>Kristiansen</surname><given-names>K</given-names></name><etal/></person-group><article-title>De novo assembly of human genomes with massively parallel short read sequencing</article-title><source>Genome Research</source><year>2010</year><volume>20</volume><issue>2</issue><fpage>265</fpage><lpage>272</lpage><pub-id pub-id-type="pmcid">PMC2813482</pub-id><pub-id pub-id-type="pmid">20019144</pub-id><pub-id pub-id-type="doi">10.1101/gr.097261.109</pub-id></element-citation></ref><ref id="R30"><label>30</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bankevich</surname><given-names>A</given-names></name><name><surname>Nurk</surname><given-names>S</given-names></name><name><surname>Antipov</surname><given-names>D</given-names></name><name><surname>Gurevich</surname><given-names>AA</given-names></name><name><surname>Dvorkin</surname><given-names>M</given-names></name><name><surname>Kulikov</surname><given-names>AS</given-names></name><name><surname>Lesin</surname><given-names>VM</given-names></name><name><surname>Nikolenko</surname><given-names>SI</given-names></name><name><surname>Pham</surname><given-names>S</given-names></name><name><surname>Prjibelski</surname><given-names>AD</given-names></name><name><surname>Pyshkin</surname><given-names>AV</given-names></name><etal/></person-group><article-title>SPAdes: A New Genome Assembly Algorithm and Its Applications to Single-Cell Sequencing</article-title><source>Journal of Computational Biology</source><year>2012</year><volume>19</volume><issue>5</issue><fpage>455</fpage><pub-id pub-id-type="pmcid">PMC3342519</pub-id><pub-id pub-id-type="pmid">22506599</pub-id><pub-id pub-id-type="doi">10.1089/cmb.2012.0021</pub-id></element-citation></ref><ref id="R31"><label>31</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Luo</surname><given-names>R</given-names></name><name><surname>Liu</surname><given-names>B</given-names></name><name><surname>Xie</surname><given-names>Y</given-names></name><name><surname>Li</surname><given-names>Z</given-names></name><name><surname>Huang</surname><given-names>W</given-names></name><name><surname>Yuan</surname><given-names>J</given-names></name><name><surname>He</surname><given-names>G</given-names></name><name><surname>Chen</surname><given-names>Y</given-names></name><name><surname>Pan</surname><given-names>Q</given-names></name><name><surname>Liu</surname><given-names>Y</given-names></name><etal/></person-group><article-title>Soapdenovo2: an empirically improved memory-efficient short-read de novo assembler</article-title><source>Gigascience</source><year>2012</year><volume>1</volume><issue>1</issue><fpage>2047</fpage><lpage>217</lpage><pub-id pub-id-type="pmcid">PMC3626529</pub-id><pub-id pub-id-type="pmid">23587118</pub-id><pub-id pub-id-type="doi">10.1186/2047-217X-1-18</pub-id></element-citation></ref><ref id="R32"><label>32</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chikhi</surname><given-names>R</given-names></name><name><surname>Rizk</surname><given-names>G</given-names></name></person-group><article-title>Space-efficient and exact de Bruijn graph representation based on a Bloom filter</article-title><source>Algorithms for Molecular Biology</source><year>2013</year><volume>8</volume><issue>1</issue><fpage>22</fpage><pub-id pub-id-type="pmcid">PMC3848682</pub-id><pub-id pub-id-type="pmid">24040893</pub-id><pub-id pub-id-type="doi">10.1186/1748-7188-8-22</pub-id></element-citation></ref><ref id="R33"><label>33</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chikhi</surname><given-names>R</given-names></name><name><surname>Limasset</surname><given-names>A</given-names></name><name><surname>Medvedev</surname><given-names>P</given-names></name></person-group><article-title>Compacting de Bruijn graphs from sequencing data quickly and in low memory</article-title><source>Bioinformatics</source><year>2016</year><volume>32</volume><issue>12</issue><fpage>201</fpage><lpage>208</lpage><pub-id pub-id-type="pmcid">PMC4908363</pub-id><pub-id pub-id-type="pmid">27307618</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btw279</pub-id></element-citation></ref><ref id="R34"><label>34</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jackman</surname><given-names>SD</given-names></name><name><surname>Vandervalk</surname><given-names>BP</given-names></name><name><surname>Mohamadi</surname><given-names>H</given-names></name><name><surname>Chu</surname><given-names>J</given-names></name><name><surname>Yeo</surname><given-names>S</given-names></name><name><surname>Hammond</surname><given-names>SA</given-names></name><name><surname>Jahesh</surname><given-names>G</given-names></name><name><surname>Khan</surname><given-names>H</given-names></name><name><surname>Coombe</surname><given-names>L</given-names></name><name><surname>Warren</surname><given-names>RL</given-names></name><name><surname>Birol</surname><given-names>I</given-names></name></person-group><article-title>ABySS 2.0: resource-efficient assembly of large genomes using a Bloom filter</article-title><source>Genome Research</source><year>2017</year><volume>27</volume><issue>5</issue><fpage>768</fpage><lpage>777</lpage><pub-id pub-id-type="pmcid">PMC5411771</pub-id><pub-id pub-id-type="pmid">28232478</pub-id><pub-id pub-id-type="doi">10.1101/gr.214346.116</pub-id></element-citation></ref><ref id="R35"><label>35</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ruan</surname><given-names>J</given-names></name><name><surname>Li</surname><given-names>H</given-names></name></person-group><article-title>Fast and accurate long-read assembly with wtdbg2</article-title><source>Nature Methods</source><year>2020</year><volume>17</volume><issue>2</issue><fpage>155</fpage><lpage>158</lpage><pub-id pub-id-type="pmcid">PMC7004874</pub-id><pub-id pub-id-type="pmid">31819265</pub-id><pub-id pub-id-type="doi">10.1038/s41592-019-0669-3</pub-id></element-citation></ref><ref id="R36"><label>36</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Tomescu</surname><given-names>AI</given-names></name><name><surname>Medvedev</surname><given-names>P</given-names></name></person-group><article-title>Safe and Complete Contig Assembly Through Omnitigs</article-title><source>Journal of Computational Biology</source><year>2017</year><volume>24</volume><issue>6</issue><fpage>590</fpage><lpage>602</lpage><pub-id pub-id-type="pmid">27749096</pub-id></element-citation></ref><ref id="R37"><label>37</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Acosta</surname><given-names>NO</given-names></name><name><surname>Mӓkinen</surname><given-names>V</given-names></name><name><surname>Tomescu</surname><given-names>AI</given-names></name></person-group><article-title>A safe and complete algorithm for metagenomic assembly</article-title><source>Algorithms for Molecular Biology</source><year>2018</year><volume>13</volume><issue>1</issue><fpage>1</fpage><lpage>12</lpage><pub-id pub-id-type="pmcid">PMC5802251</pub-id><pub-id pub-id-type="pmid">29445416</pub-id><pub-id pub-id-type="doi">10.1186/s13015-018-0122-7</pub-id></element-citation></ref><ref id="R38"><label>38</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cairo</surname><given-names>M</given-names></name><name><surname>Khan</surname><given-names>S</given-names></name><name><surname>Rizzi</surname><given-names>R</given-names></name><name><surname>Schmidt</surname><given-names>S</given-names></name><name><surname>Tomescu</surname><given-names>AI</given-names></name><name><surname>Zirondelli</surname><given-names>EC</given-names></name></person-group><article-title>The hydrostructure: a universal framework for safe and complete algorithms for genome assembly</article-title><source>arXiv preprint</source><year>2020</year><elocation-id>arXiv:2011.12635</elocation-id></element-citation></ref><ref id="R39"><label>39</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kececioglu</surname><given-names>JD</given-names></name><name><surname>Myers</surname><given-names>EW</given-names></name></person-group><article-title>Combinatorial algorithms for DNA sequence assembly</article-title><source>Algorithmica</source><year>1995</year><volume>13</volume><issue>1</issue><fpage>7</fpage><lpage>51</lpage></element-citation></ref><ref id="R40"><label>40</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Khan</surname><given-names>J</given-names></name><name><surname>Kokot</surname><given-names>M</given-names></name><name><surname>Deorowicz</surname><given-names>S</given-names></name><name><surname>Patro</surname><given-names>R</given-names></name></person-group><article-title>Scalable, ultra-fast, and low-memory construction of compacted de bruijn graphs with cuttlefish 2</article-title><source>Genome biology</source><year>2022</year><volume>23</volume><issue>1</issue><fpage>1</fpage><lpage>32</lpage><pub-id pub-id-type="pmcid">PMC9454175</pub-id><pub-id pub-id-type="pmid">36076275</pub-id><pub-id pub-id-type="doi">10.1186/s13059-022-02743-6</pub-id></element-citation></ref><ref id="R41"><label>41</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cracco</surname><given-names>A</given-names></name><name><surname>Tomescu</surname><given-names>AI</given-names></name></person-group><article-title>Extremely-fast construction and querying of compacted and colored de Bruijn graphs with GGCAT</article-title><source>bioRxiv</source><year>2022</year><comment><ext-link ext-link-type="uri" xlink:href="https://www.biorxiv.org/content/early/2022/10/25/2022.10.24.513174.full.pdf">https://www.biorxiv.org/content/early/2022/10/25/2022.10.24.513174.full.pdf</ext-link></comment><pub-id pub-id-type="doi">10.1101/2022.10.24.513174</pub-id></element-citation></ref><ref id="R42"><label>42</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>O’Leary</surname><given-names>NA</given-names></name><name><surname>Wright</surname><given-names>MW</given-names></name><name><surname>Brister</surname><given-names>JR</given-names></name><name><surname>Ciufo</surname><given-names>S</given-names></name><name><surname>Haddad</surname><given-names>D</given-names></name><name><surname>McVeigh</surname><given-names>R</given-names></name><name><surname>Rajput</surname><given-names>B</given-names></name><name><surname>Robbertse</surname><given-names>B</given-names></name><name><surname>Smith-White</surname><given-names>B</given-names></name><name><surname>Ako-Adjei</surname><given-names>D</given-names></name><etal/></person-group><article-title>Reference sequence (refseq) database at ncbi: current status, taxonomic expansion, and functional annotation</article-title><source>Nucleic Acids Research</source><year>2016</year><volume>44</volume><issue>D1</issue><fpage>733</fpage><lpage>745</lpage><pub-id pub-id-type="pmcid">PMC4702849</pub-id><pub-id pub-id-type="pmid">26553804</pub-id><pub-id pub-id-type="doi">10.1093/nar/gkv1189</pub-id></element-citation></ref><ref id="R43"><label>43</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Břinda</surname><given-names>K</given-names></name><name><surname>Baym</surname><given-names>M</given-names></name><name><surname>Kucherov</surname><given-names>G</given-names></name></person-group><article-title>Simplitigs as an efficient and scalable representation of de Bruijn graphs</article-title><source>Genome Biology</source><year>2021</year><volume>22</volume><issue>1</issue><fpage>1</fpage><lpage>24</lpage><pub-id pub-id-type="pmcid">PMC8025321</pub-id><pub-id pub-id-type="pmid">33823902</pub-id><pub-id pub-id-type="doi">10.1186/s13059-021-02297-z</pub-id></element-citation></ref><ref id="R44"><label>44</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rahman</surname><given-names>A</given-names></name><name><surname>Medevedev</surname><given-names>P</given-names></name></person-group><article-title>Representation of k-mer sets using spectrum-preserving string sets</article-title><source>Journal of Computational Biology</source><year>2021</year><volume>28</volume><issue>4</issue><fpage>381</fpage><lpage>394</lpage><pub-id pub-id-type="pmcid">PMC8066325</pub-id><pub-id pub-id-type="pmid">33290137</pub-id><pub-id pub-id-type="doi">10.1089/cmb.2020.0431</pub-id></element-citation></ref><ref id="R45"><label>45</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pibiri</surname><given-names>GE</given-names></name></person-group><article-title>Sparse and skew hashing of k-mers</article-title><source>Bioinformatics</source><year>2022</year><volume>38</volume><issue>Supplement_1</issue><fpage>185</fpage><lpage>194</lpage><pub-id pub-id-type="pmcid">PMC9235479</pub-id><pub-id pub-id-type="pmid">35758794</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btac245</pub-id></element-citation></ref><ref id="R46"><label>46</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H</given-names></name></person-group><article-title>Aligning sequence reads, clone sequences and assembly contigs with bwa-mem</article-title><source>arXiv preprint</source><year>2013</year><elocation-id>arXiv:1303.3997</elocation-id></element-citation></ref><ref id="R47"><label>47</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Schmidt</surname><given-names>S</given-names></name><name><surname>Alanko</surname><given-names>JN</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Boucher</surname><given-names>C</given-names></name><name><surname>Rahmann</surname><given-names>S</given-names></name></person-group><source>Eulertigs: Minimum Plain Text Representation of k-mer Sets Without Repetitions in Linear Time</source><edition>22n</edition><conf-name>International Workshop on Algorithms in Bioinformatics (WABI 2022). Leibniz International Proceedings in Informatics (LIPIcs)</conf-name><conf-sponsor>Schloss Dagstuhl – Leibniz-Zentrum fur Informatik</conf-sponsor><conf-loc>Dagstuhl, Germany</conf-loc><year>2022</year><volume>242</volume><fpage>1</fpage><lpage>21</lpage><comment><ext-link ext-link-type="uri" xlink:href="https://drops.dagstuhl.de/opus/volltexte/2022/17036">https://drops.dagstuhl.de/opus/volltexte/2022/17036</ext-link></comment><pub-id pub-id-type="doi">10.4230/LIPIcs.WABI.2022.2</pub-id></element-citation></ref><ref id="R48"><label>48</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dufresne</surname><given-names>Y</given-names></name><name><surname>Lemane</surname><given-names>T</given-names></name><name><surname>Marijon</surname><given-names>P</given-names></name><name><surname>Peterlongo</surname><given-names>P</given-names></name><name><surname>Rahman</surname><given-names>A</given-names></name><name><surname>Kokot</surname><given-names>M</given-names></name><name><surname>Medvedev</surname><given-names>P</given-names></name><name><surname>Deorowicz</surname><given-names>S</given-names></name><name><surname>Chikhi</surname><given-names>R</given-names></name></person-group><article-title>The k-mer file format: a standardized and compact disk representation of sets of k-mers</article-title><source>Bioinformatics</source><year>2022</year><volume>38</volume><issue>18</issue><fpage>4423</fpage><lpage>4425</lpage><pub-id pub-id-type="pmcid">PMC9477520</pub-id><pub-id pub-id-type="pmid">35904548</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btac528</pub-id></element-citation></ref><ref id="R49"><label>49</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fan</surname><given-names>J</given-names></name><name><surname>Khan</surname><given-names>J</given-names></name><name><surname>Pibiri</surname><given-names>GE</given-names></name><name><surname>Patro</surname><given-names>R</given-names></name></person-group><article-title>Spectrum preserving tilings enable sparse and modular reference indexing</article-title><source>bioRxiv</source><year>2022</year><comment><ext-link ext-link-type="uri" xlink:href="https://www.biorxiv.org/content/early/2022/10/28/2022.10.27.513881.full.pdf">https://www.biorxiv.org/content/early/2022/10/28/2022.10.27.513881.full.pdf</ext-link></comment><pub-id pub-id-type="doi">10.1101/2022.10.27.513881</pub-id></element-citation></ref><ref id="R50"><label>50</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rahman</surname><given-names>A</given-names></name><name><surname>Chikhi</surname><given-names>R</given-names></name><name><surname>Medvedev</surname><given-names>P</given-names></name></person-group><article-title>Disk compression of k-mer sets</article-title><source>Algorithms for Molecular Biology</source><year>2021</year><volume>16</volume><issue>1</issue><fpage>1</fpage><lpage>14</lpage><pub-id pub-id-type="pmcid">PMC8218509</pub-id><pub-id pub-id-type="pmid">34154632</pub-id><pub-id pub-id-type="doi">10.1186/s13015-021-00192-7</pub-id></element-citation></ref><ref id="R51"><label>51</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Marchet</surname><given-names>C</given-names></name><name><surname>Iqbal</surname><given-names>Z</given-names></name><name><surname>Gautheret</surname><given-names>D</given-names></name><name><surname>Salson</surname><given-names>M</given-names></name><name><surname>Chikhi</surname><given-names>R</given-names></name></person-group><article-title>REINDEER: efficient indexing of k-mer presence and abundance in sequencing datasets</article-title><source>Bioinformatics</source><year>2020</year><volume>36</volume><issue>Supplement_1</issue><fpage>177</fpage><lpage>185</lpage><comment><ext-link ext-link-type="uri" xlink:href="https://academic.oup.com/bioinformatics/article-pdf/36/SupplemenL1/i177/33860751/btaa487.pdf">https://academic.oup.com/bioinformatics/article-pdf/36/SupplemenL1/i177/33860751/btaa487.pdf</ext-link></comment><pub-id pub-id-type="pmcid">PMC7355249</pub-id><pub-id pub-id-type="pmid">32657392</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btaa487</pub-id></element-citation></ref><ref id="R52"><label>52</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Kitaya</surname><given-names>K</given-names></name><name><surname>Shibuya</surname><given-names>T</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Carbone</surname><given-names>A</given-names></name><name><surname>El-Kebir</surname><given-names>M</given-names></name></person-group><source>Compression of Multiple k-Mer Sets by Iterative SPSS Decomposition</source><edition>21s</edition><conf-name>International Workshop on Algorithms in Bioinformatics (WABI 2021). Leibniz International Proceedings in Informatics (LIPIcs)</conf-name><conf-sponsor>Schloss Dagstuhl – Leibniz-Zentrum für Informatik</conf-sponsor><conf-loc>Dagstuhl, Germany</conf-loc><year>2021</year><volume>201</volume><fpage>12</fpage><lpage>11217</lpage><comment><ext-link ext-link-type="uri" xlink:href="https://drops.dagstuhl.de/opus/volltexte/2021/14365">https://drops.dagstuhl.de/opus/volltexte/2021/14365</ext-link></comment><pub-id pub-id-type="doi">10.4230/LIPIcs.WABI.2021.12</pub-id></element-citation></ref><ref id="R53"><label>53</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kwan</surname><given-names>M-k</given-names></name></person-group><article-title>Graphic programming using odd or even points</article-title><source>Chinese Mathematics</source><year>1962</year><volume>1</volume><fpage>273</fpage><lpage>277</lpage></element-citation></ref><ref id="R54"><label>54</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Edmonds</surname><given-names>J</given-names></name><name><surname>Johnson</surname><given-names>EL</given-names></name></person-group><article-title>Matching, euler tours and the chinese postman</article-title><source>Mathematical programming</source><year>1973</year><volume>5</volume><issue>1</issue><fpage>88</fpage><lpage>124</lpage></element-citation></ref><ref id="R55"><label>55</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Kundeti</surname><given-names>V</given-names></name><name><surname>Rajasekaran</surname><given-names>S</given-names></name><name><surname>Dinh</surname><given-names>H</given-names></name></person-group><chapter-title>An efficient algorithm for chinese postman walk on bi-directed de bruijn graphs</chapter-title><person-group person-group-type="editor"><name><surname>Wu</surname><given-names>W</given-names></name><name><surname>Daescu</surname><given-names>O</given-names></name></person-group><source>Combinatorial Optimization and Applications</source><publisher-name>Springer</publisher-name><publisher-loc>Berlin, Heidelberg</publisher-loc><year>2010</year><fpage>184</fpage><lpage>196</lpage><pub-id pub-id-type="pmcid">PMC4215799</pub-id><pub-id pub-id-type="pmid">25364472</pub-id><pub-id pub-id-type="doi">10.1007/978-3-642-17458-2_16</pub-id></element-citation></ref><ref id="R56"><label>56</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Medvedev</surname><given-names>P</given-names></name><name><surname>Georgiou</surname><given-names>K</given-names></name><name><surname>Myers</surname><given-names>G</given-names></name><name><surname>Brudno</surname><given-names>M</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Giancarlo</surname><given-names>R</given-names></name><name><surname>Hannenhalli</surname><given-names>S</given-names></name></person-group><source>Computability of models for sequence assembly</source><conf-name>Algorithms in Bioinformatics, 7th International Workshop, WABI 2007, Philadelphia, PA, USA, September 8-9, 2007, Proceedings. Lecture Notes in Computer Science</conf-name><conf-sponsor>Springer</conf-sponsor><conf-loc>Berlin, Heidelberg</conf-loc><year>2007</year><volume>4645</volume><fpage>289</fpage><lpage>301</lpage><pub-id pub-id-type="doi">10.1007/978-3-540-74126-8_27</pub-id></element-citation></ref><ref id="R57"><label>57</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Pibiri</surname><given-names>GE</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Boucher</surname><given-names>C</given-names></name><name><surname>Rahmann</surname><given-names>S</given-names></name></person-group><source>On Weighted k-mer Dictionaries</source><edition>22n</edition><conf-name>International Workshop on Algorithms in Bioinformatics (WABI 2022). Leibniz International Proceedings in Informatics (LIPIcs)</conf-name><conf-sponsor>Schloss Dagstuhl – Leibniz-Zentrum für Informatik</conf-sponsor><conf-loc>Dagstuhl, Germany</conf-loc><year>2022</year><volume>242</volume><fpage>1</fpage><lpage>20</lpage><comment><ext-link ext-link-type="uri" xlink:href="https://drops.dagstuhl.de/opus/volltexte/2022/17043">https://drops.dagstuhl.de/opus/volltexte/2022/17043</ext-link></comment><pub-id pub-id-type="doi">10.4230/LIPIcs.WABI.2022.9</pub-id></element-citation></ref><ref id="R58"><label>58</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Pibiri</surname><given-names>GE</given-names></name><name><surname>Trani</surname><given-names>R</given-names></name></person-group><source>PTHash: Revisiting FCH Minimal Perfect Hashing</source><conf-name>The 44th International ACM SIGIR Conference on Research and Development in Information Retrieval</conf-name><year>2021</year><fpage>1339</fpage><lpage>1348</lpage></element-citation></ref><ref id="R59"><label>59</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Roberts</surname><given-names>M</given-names></name><name><surname>Hayes</surname><given-names>W</given-names></name><name><surname>Hunt</surname><given-names>BR</given-names></name><name><surname>Mount</surname><given-names>SM</given-names></name><name><surname>Yorke</surname><given-names>JA</given-names></name></person-group><article-title>Reducing storage requirements for biological sequence comparison</article-title><source>Bioinformatics</source><year>2004</year><volume>20</volume><issue>18</issue><fpage>3363</fpage><lpage>3369</lpage><pub-id pub-id-type="pmid">15256412</pub-id></element-citation></ref><ref id="R60"><label>60</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lenstra</surname><given-names>JK</given-names></name><name><surname>Kan</surname><given-names>AR</given-names></name></person-group><article-title>Complexity of vehicle routing and scheduling problems</article-title><source>Networks</source><year>1981</year><volume>11</volume><issue>2</issue><fpage>221</fpage><lpage>227</lpage></element-citation></ref><ref id="R61"><label>61</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Edmonds</surname><given-names>J</given-names></name><name><surname>Karp</surname><given-names>RM</given-names></name></person-group><article-title>Theoretical improvements in algorithmic efficiency for network flow problems</article-title><source>Journal of the ACM (JACM)</source><year>1972</year><volume>19</volume><issue>2</issue><fpage>248</fpage><lpage>264</lpage></element-citation></ref><ref id="R62"><label>62</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Christofides</surname><given-names>N</given-names></name><name><surname>Campos</surname><given-names>V</given-names></name><name><surname>Corberán</surname><given-names>A</given-names></name><name><surname>Mota</surname><given-names>E</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Gallo</surname><given-names>G</given-names></name><name><surname>Sandi</surname><given-names>C</given-names></name></person-group><source>An algorithm for the Rural Postman problem on a directed graph</source><publisher-name>Springer</publisher-name><publisher-loc>Berlin, Heidelberg</publisher-loc><year>1986</year><fpage>155</fpage><lpage>166</lpage><pub-id pub-id-type="doi">10.1007/BFb0121091</pub-id></element-citation></ref><ref id="R63"><label>63</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Even</surname><given-names>S</given-names></name></person-group><source>Graph Algorithms</source><publisher-name>Computer Science Press</publisher-name><publisher-loc>Rockville, MD</publisher-loc><year>1979</year></element-citation></ref><ref id="R64"><label>64</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Scháfer</surname><given-names>G</given-names></name></person-group><source>Weighted matchings in general graphs</source><publisher-name>Master’s thesis, Saarland University</publisher-name><year>2000</year></element-citation></ref><ref id="R65"><label>65</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kolmogorov</surname><given-names>V</given-names></name><name><surname>Blossom</surname><given-names>V</given-names></name></person-group><article-title>a new implementation of a minimum cost perfect matching algorithm</article-title><source>Mathematical Programming Computation</source><year>2009</year><volume>1</volume><issue>1</issue><fpage>43</fpage><lpage>67</lpage></element-citation></ref><ref id="R66"><label>66</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dijkstra</surname><given-names>EW</given-names></name></person-group><article-title>A note on two problems in connexion with graphs</article-title><source>Numerische mathematik</source><year>1959</year><volume>1</volume><issue>1</issue><fpage>269</fpage><lpage>271</lpage></element-citation></ref><ref id="R67"><label>67</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Cáceres</surname><given-names>M</given-names></name><name><surname>Cairo</surname><given-names>M</given-names></name><name><surname>Mumey</surname><given-names>B</given-names></name><name><surname>Rizzi</surname><given-names>R</given-names></name><name><surname>Tomescu</surname><given-names>AI</given-names></name></person-group><source>Sparsifying, shrinking and splicing for minimum path cover in parameterized linear time arXiv preprint</source><conf-name>To appear in the Proceedings of the 2022 ACM-SIAM Symposium on Discrete Algorithms (SODA 2022)</conf-name><year>2021</year><elocation-id>arXiv:2107.05717</elocation-id></element-citation></ref><ref id="R68"><label>68</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Leinonen</surname><given-names>R</given-names></name><name><surname>Sugawara</surname><given-names>H</given-names></name><name><surname>Shumway</surname><given-names>M</given-names></name></person-group><article-title>The sequence read archive</article-title><source>Nucleic Acids Research</source><year>2010</year><volume>39</volume><issue>suppl_1</issue><fpage>19</fpage><lpage>21</lpage><pub-id pub-id-type="pmcid">PMC3013647</pub-id><pub-id pub-id-type="pmid">21062823</pub-id><pub-id pub-id-type="doi">10.1093/nar/gkq1019</pub-id></element-citation></ref><ref id="R69"><label>69</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Croucher</surname><given-names>NJ</given-names></name><name><surname>Finkelstein</surname><given-names>JA</given-names></name><name><surname>Pelton</surname><given-names>SI</given-names></name><name><surname>Parkhill</surname><given-names>J</given-names></name><name><surname>Bentley</surname><given-names>SD</given-names></name><name><surname>Lipsitch</surname><given-names>M</given-names></name><name><surname>Hanage</surname><given-names>WP</given-names></name></person-group><article-title>Population genomic datasets describing the post-vaccine evolutionary epidemiology of streptococcus pneumoniae</article-title><source>Scientific data</source><year>2015</year><volume>2</volume><issue>1</issue><fpage>1</fpage><lpage>9</lpage><pub-id pub-id-type="pmcid">PMC4622223</pub-id><pub-id pub-id-type="pmid">26528397</pub-id><pub-id pub-id-type="doi">10.1038/sdata.2015.58</pub-id></element-citation></ref><ref id="R70"><label>70</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Grad</surname><given-names>YH</given-names></name><name><surname>Harris</surname><given-names>SR</given-names></name><name><surname>Kirkcaldy</surname><given-names>RD</given-names></name><name><surname>Green</surname><given-names>AG</given-names></name><name><surname>Marks</surname><given-names>DS</given-names></name><name><surname>Bentley</surname><given-names>SD</given-names></name><name><surname>Trees</surname><given-names>D</given-names></name><name><surname>Lipsitch</surname><given-names>M</given-names></name></person-group><article-title>Genomic epidemiology of gonococcal resistance to extended-spectrum cephalosporins, macrolides, and fluoroquinolones in the united states, 2000-2013</article-title><source>The Journal of infectious diseases</source><year>2016</year><volume>214</volume><issue>10</issue><fpage>1579</fpage><lpage>1587</lpage><pub-id pub-id-type="pmcid">PMC5091375</pub-id><pub-id pub-id-type="pmid">27638945</pub-id><pub-id pub-id-type="doi">10.1093/infdis/jiw420</pub-id></element-citation></ref><ref id="R71"><label>71</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zhou</surname><given-names>Z</given-names></name><name><surname>Alikhan</surname><given-names>N-F</given-names></name><name><surname>Mohamed</surname><given-names>K</given-names></name><name><surname>Fan</surname><given-names>Y</given-names></name><name><surname>Achtman</surname><given-names>M</given-names></name></person-group><article-title>The user’s guide to comparative genomics with EnteroBase, including case studies on transmissions of micro-clades of Salmonella, the phylogeny of ancient and modern Yersinia pestis genomes, and the core genomic diversity of all Escherichia</article-title><source>bioRxiv</source><year>2019</year><comment><ext-link ext-link-type="uri" xlink:href="https://www.biorxiv.org/content/early/2019/11/25/613554.full.pdf">https://www.biorxiv.org/content/early/2019/11/25/613554.full.pdf</ext-link></comment><pub-id pub-id-type="doi">10.1101/613554</pub-id></element-citation></ref><ref id="R72"><label>72</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Consortium</surname><given-names>GP</given-names></name><etal/></person-group><article-title>A global reference for human genetic variation</article-title><source>Nature</source><year>2015</year><volume>526</volume><issue>7571</issue><fpage>68</fpage><pub-id pub-id-type="pmcid">PMC4750478</pub-id><pub-id pub-id-type="pmid">26432245</pub-id><pub-id pub-id-type="doi">10.1038/nature15393</pub-id></element-citation></ref><ref id="R73"><label>73</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Norri</surname><given-names>T</given-names></name><name><surname>Cazaux</surname><given-names>B</given-names></name><name><surname>Donges</surname><given-names>S</given-names></name><name><surname>Valenzuela</surname><given-names>D</given-names></name><name><surname>Mökinen</surname><given-names>V</given-names></name></person-group><article-title>Founder reconstruction enables scalable and seamless pangenomic analysis</article-title><source>Bioinformatics</source><year>2021</year><volume>37</volume><issue>24</issue><fpage>4611</fpage><lpage>4619</lpage><pub-id pub-id-type="pmcid">PMC8665761</pub-id><pub-id pub-id-type="pmid">34260702</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btab516</pub-id></element-citation></ref><ref id="R74"><label>74</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Koster</surname><given-names>J</given-names></name><name><surname>Rahmann</surname><given-names>S</given-names></name></person-group><article-title>Snakemake—a scalable bioinformatics workflow engine</article-title><source>Bioinformatics</source><year>2012</year><volume>28</volume><issue>19</issue><fpage>2520</fpage><lpage>2522</lpage><pub-id pub-id-type="pmid">22908215</pub-id></element-citation></ref><ref id="R75"><label>75</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Grüning</surname><given-names>B</given-names></name><name><surname>Dale</surname><given-names>R</given-names></name><name><surname>Sjödin</surname><given-names>A</given-names></name><name><surname>Chapman</surname><given-names>BA</given-names></name><name><surname>Rowe</surname><given-names>J</given-names></name><name><surname>Tomkins-Tinch</surname><given-names>CH</given-names></name><name><surname>Valieris</surname><given-names>R</given-names></name><name><surname>Koster</surname><given-names>J</given-names></name></person-group><article-title>Bioconda: sustainable and comprehensive software distribution for the life sciences</article-title><source>Nature Methods</source><year>2018</year><volume>15</volume><issue>7</issue><fpage>475</fpage><lpage>476</lpage><pub-id pub-id-type="pmid">29967506</pub-id></element-citation></ref></ref-list></back><floats-group><fig id="F1" position="float"><label>Figure 1</label><caption><p><italic>k</italic> = 5. For simplicity, the reverse complements of all nodes and arcs are omitted. <bold>a:</bold> the original de Bruijn graph in compacted form has 13 unitigs with 70 total characters. <bold>b:</bold> example of simplitigs with 7 strings and 43 total characters. <bold>c:</bold> example of greedily approximated matchtigs with 6 strings and 40 total characters. <bold>d:</bold> example of matchtigs with 5 strings and 39 total characters.</p></caption><graphic xlink:href="EMS157437-f001"/></fig><fig id="F2" position="float"><label>Figure 2</label><caption><p><bold>(A)</bold> The input genomic sequences. <bold>(B)</bold> We first build an arc-centric compacted de Bruijn graph (for simplicity, the reverse complements of the nodes and arcs are not shown) <bold>(C)</bold> In the graph we compute the bi-imbalances of the nodes (the difference between outdegree and indegree). <bold>(D)</bold> From each node with negative bi-imbalance we compute the min-cost paths to all reachable nodes with positive bi-imbalance. The costs of each arc are the amount of characters required to join two strings from the negative to the positive node while repeating the kmers between the nodes. Specifically, the costs of an arc are |s| – (k – 1), where |s| is the length of its label. <bold>(E)</bold> Using a min-cost perfect matching instance built from the min-cost paths, we decide which bi-imbalances should be fixed by repeating kmers. The blue/tightly dashed edges are joining edges stemming from the min-cost paths. The red edges in longer dashes indicate that a node should stay unmatched, i.e. that fixing its bi-imbalance requires breaking arcs. The solution edges are highlighted in bold. There is one node in the matching problem for each binode in the original graph. The nodes <italic>x’</italic> are not reverse complements of nodes x, but stem from a reduction that makes a copy of each node. For more details, refer to <xref ref-type="sec" rid="S25">Section 5.6</xref>. <bold>(F)</bold> For each joining edge in the solution we insert a joining arc into the DBG (in blue, small dashes), always directed such that the overall bi-imbalance decreases. The remaining imbalance is removed by inserting arbitrary breaking arcs (in read, longer dashes). <bold>(G)</bold> We compute a biEulerian circuit in the balanced graph. <bold>(H)</bold> We break the biEulerian circuit at all breaking arcs. <bold>(I)</bold> We output the strings spelled by the broken walks.</p></caption><graphic xlink:href="EMS157437-f002"/></fig><fig id="F3" position="float"><label>Figure 3</label><caption><title>Binodes are surrounded by a dashed box, where self-complemental binodes contain only one graph node.</title><p><bold>a:</bold> a de Bruijn graph of the strings TTCTGA and GTCTGT. The colored/patterned lines are an arc-covering set of biwalks. <bold>b:</bold> a de Bruijn graph containing two self-complemental nodes. The colored/patterned lines are a set of biwalks that visit each biarc exactly once. <bold>c:</bold> a de Bruijn graph containing a self-complemental biarc. The colored line is a biwalk that visits each biarc exactly once.</p></caption><graphic xlink:href="EMS157437-f003"/></fig><fig id="F4" position="float"><label>Figure 4</label><caption><p>A self-complemental biarc [(<italic>ACG, CGT</italic>)] covered by a biEulerian circuit ([(<italic>GAC, ACG</italic>), (<italic>CGT, GTC</italic>)], [(<italic>ACG, CGT</italic>)], [(<italic>CGT, GTG</italic>), (<italic>CAC, ACG</italic>)]). The two directions of the bidirected circuit are drawn in blue ((<italic>GAC, ACG</italic>), (<italic>ACG,CGT</italic>), (<italic>CGT, GTG</italic>)) and green dotted ((<italic>CAC, ACG</italic>), (<italic>ACG,CGT</italic>), (<italic>CGT,GTC</italic>)). In (a), the binode [<italic>ACG,CGT</italic>] is balanced, hence the circuit can enter it with some biarc, cover the self-complemental biarc, and then leave it via some other biarc. If, like in (b), there was no other biarc to leave [<italic>ACG,CGT</italic>], then the graph would not be biEulerian, as the biarc [(<italic>GAC, ACG</italic>), (<italic>CGT, GTC</italic>)] cannot be used twice, even if the second use is in the other direction. Visually, the blue walk cannot use (<italic>CGT, GTC</italic>), since it was already used by the green dotted walk, and the green dotted walk cannot use (<italic>GAC, ACG</italic>), as it was already used by the blue walk.</p></caption><graphic xlink:href="EMS157437-f004"/></fig><fig id="F5" position="float"><label>Figure 5</label><caption><title>The DAG of tools run on the short read sets and pangenomes to compute different tigs.</title></caption><graphic xlink:href="EMS157437-f005"/></fig><table-wrap id="T1" position="float" orientation="portrait"><label>Table 1</label><caption><title>Quality and performance of compressing model organisms</title></caption><table frame="box" rules="all"><tbody><tr><td align="center" valign="top">genome</td><td align="left" valign="top">algorithm</td><td align="left" valign="top">CL ratio</td><td align="left" valign="top">SC ratio</td><td align="left" valign="top">time [s]</td><td align="left" valign="top">memory [GiB]</td></tr><tr><td align="center" valign="middle" rowspan="4">C. elegans (reads)</td><td align="left" valign="middle">B2</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">2402</td><td align="left" valign="middle">5.54</td></tr><tr><td align="left" valign="middle">B2+UST</td><td align="left" valign="middle">0.58</td><td align="left" valign="middle">0.37</td><td align="left" valign="middle">3424 (1.43)</td><td align="left" valign="middle">17.6 (3.18)</td></tr><tr><td align="left" valign="middle">ProphAsm</td><td align="left" valign="middle">0.55</td><td align="left" valign="middle">0.34</td><td align="left" valign="middle">5433</td><td align="left" valign="middle">56.5</td></tr><tr><td align="left" valign="middle">B2+GREEDY</td><td align="left" valign="middle">0.45 (0.79)</td><td align="left" valign="middle">0.11 (0.28)</td><td align="left" valign="middle">3057 (1.27)</td><td align="left" valign="middle">41.0 (7.41)</td></tr><tr><td align="center" valign="middle" rowspan="4">B. mori (reads)</td><td align="left" valign="middle">B2</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">6406</td><td align="left" valign="middle">9.95</td></tr><tr><td align="left" valign="middle">B2+UST</td><td align="left" valign="middle">0.55</td><td align="left" valign="middle">0.35</td><td align="left" valign="middle">9896 (1.54)</td><td align="left" valign="middle">56.2 (5.64)</td></tr><tr><td align="left" valign="middle">ProphAsm</td><td align="left" valign="middle">0.52</td><td align="left" valign="middle">0.31</td><td align="left" valign="middle">27912</td><td align="left" valign="middle">157</td></tr><tr><td align="left" valign="middle">B2+GREEDY</td><td align="left" valign="middle">0.41 (0.74)</td><td align="left" valign="middle">0.06 (0.18)</td><td align="left" valign="middle">11793 (1.84)</td><td align="left" valign="middle">123 (12.4)</td></tr><tr><td align="center" valign="middle" rowspan="3">H. sapiens (reads)</td><td align="left" valign="middle">B2</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">168938</td><td align="left" valign="middle">12.4</td></tr><tr><td align="left" valign="middle">B2+UST</td><td align="left" valign="middle">0.67</td><td align="left" valign="middle">0.46</td><td align="left" valign="middle">170427 (1.01)</td><td align="left" valign="middle">29.0 (2.34)</td></tr><tr><td align="left" valign="middle">B2+GREEDY</td><td align="left" valign="middle">0.57 (0.84)</td><td align="left" valign="middle">0.22 (0.48)</td><td align="left" valign="middle">209646 (1.24)</td><td align="left" valign="middle">68.5 (5.52)</td></tr><tr><td align="center" valign="middle" rowspan="5">C. elegans</td><td align="left" valign="middle">B2</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">52.7</td><td align="left" valign="middle">0.96</td></tr><tr><td align="left" valign="middle">B2+UST</td><td align="left" valign="middle">0.92</td><td align="left" valign="middle">0.34</td><td align="left" valign="middle">58.6 (1.11)</td><td align="left" valign="middle">0.96 (1.00)</td></tr><tr><td align="left" valign="middle">ProphAsm</td><td align="left" valign="middle">0.92</td><td align="left" valign="middle">0.30</td><td align="left" valign="middle">133</td><td align="left" valign="middle">3.78</td></tr><tr><td align="left" valign="middle">B2+GREEDY</td><td align="left" valign="middle">0.90 (0.98)</td><td align="left" valign="middle">0.06 (0.18)</td><td align="left" valign="middle">59.9 (1.14)</td><td align="left" valign="middle">0.9 (1.00)</td></tr><tr><td align="left" valign="middle">B2+MATCH</td><td align="left" valign="middle">0.90 (0.98)</td><td align="left" valign="middle">0.07 (0.23)</td><td align="left" valign="middle">380 (7.21)</td><td align="left" valign="middle">1.34 (1.40)</td></tr><tr><td align="center" valign="middle" rowspan="4">B. mori</td><td align="left" valign="middle">B2</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">244</td><td align="left" valign="middle">1.92</td></tr><tr><td align="left" valign="middle">B2+UST</td><td align="left" valign="middle">0.78</td><td align="left" valign="middle">0.34</td><td align="left" valign="middle">303 (1.24)</td><td align="left" valign="middle">1.92 (1.00)</td></tr><tr><td align="left" valign="middle">ProphAsm</td><td align="left" valign="middle">0.76</td><td align="left" valign="middle">0.28</td><td align="left" valign="middle">716</td><td align="left" valign="middle">13.8</td></tr><tr><td align="left" valign="middle">B2+GREEDY</td><td align="left" valign="middle">0.72 (0.92)</td><td align="left" valign="middle">0.06 (0.19)</td><td align="left" valign="middle">334 (1.37)</td><td align="left" valign="middle">2.42 (1.26)</td></tr><tr><td align="center" valign="middle" rowspan="4">H. sapiens</td><td align="left" valign="middle">B2</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">1787</td><td align="left" valign="middle">6.29</td></tr><tr><td align="left" valign="middle">B2+UST</td><td align="left" valign="middle">0.79</td><td align="left" valign="middle">0.33</td><td align="left" valign="middle">2249 (1.26)</td><td align="left" valign="middle">8.80 (1.40)</td></tr><tr><td align="left" valign="middle">ProphAsm</td><td align="left" valign="middle">0.76</td><td align="left" valign="middle">0.26</td><td align="left" valign="middle">6677</td><td align="left" valign="middle">130</td></tr><tr><td align="left" valign="middle">B2+GREEDY</td><td align="left" valign="middle">0.71 (0.91)</td><td align="left" valign="middle">0.03 (0.10)</td><td align="left" valign="middle">4999 (2.80)</td><td align="left" valign="middle">17.3 (2.75)</td></tr></tbody></table><table-wrap-foot><fn id="TFN1"><p id="P144">We chose <italic>k</italic> = 31 and a min abundance of 10 for Homo sapiens reads and 1 for all others. The CL and SC ratios are between compressed strings and unitigs, and in parentheses are the ratios between our algorithm and the best competitor. B2 means BCALM2. For time and memory, we report the total time and maximum memory required to compute the tigs from the respective data set. BCALM2 directly computes unitigs and ProphAsm directly computes heuristic simplitigs. UST, GREEDY and MATCH compute heuristic simplitigs, greedy matchtigs and matchtigs from unitigs. The number in parentheses behind time and memory indicates the slowdown/increase over computing just unitigs with BCALM2. All algorithms were run with 28 threads, except for UST which supports only one thread (the preceding run of BCALM2 was still executed with 28 threads), and ProphAsm, which supports only one thread as well. Matchtigs are too expensive to run on all genomes except for the C. elegans reference, and ProphAsm takes too much time on H. sapiens reads, especially since it does not support minimum abundance. The lengths of the genomes are 100Mbp for C. elegans, 482Mbp for B. mori and 3.21Gbp for H. sapiens and the read data sets have a coverage of 64x for C. elegans, 58x for B. mori and 300x for H. sapiens.</p></fn></table-wrap-foot></table-wrap><table-wrap id="T2" position="float" orientation="portrait"><label>Table 2</label><caption><title>Quality and performance of compressing pangenomes</title></caption><table frame="box" rules="all"><tbody><tr><td align="center" valign="top">pangenome</td><td align="left" valign="top">algorithm</td><td align="left" valign="top">CL ratio</td><td align="left" valign="top">SC ratio</td><td align="left" valign="top">time [s]</td><td align="left" valign="top">memory [MiB]</td></tr><tr><td align="center" valign="middle" rowspan="5">1102xN. gonorrhoeae</td><td align="left" valign="middle">B2</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">29.1</td><td align="left" valign="middle">4351</td></tr><tr><td align="left" valign="middle">B2+UST</td><td align="left" valign="middle">0.63</td><td align="left" valign="middle">0.35</td><td align="left" valign="middle">31.1 (1.07)</td><td align="left" valign="middle">4351 (1.00)</td></tr><tr><td align="left" valign="middle">ProphAsm</td><td align="left" valign="middle">0.62</td><td align="left" valign="middle">0.33</td><td align="left" valign="middle">735 (25.3)</td><td align="left" valign="middle">207 (0.05)</td></tr><tr><td align="left" valign="middle">B2+GREEDY</td><td align="left" valign="middle">0.57 (0.93)</td><td align="left" valign="middle">0.18 (0.54)</td><td align="left" valign="middle">30.2 (1.04)</td><td align="left" valign="middle">4351 (1.00)</td></tr><tr><td align="left" valign="middle">B2+MATCH</td><td align="left" valign="middle">0.57 (0.92)</td><td align="left" valign="middle">0.18 (0.56)</td><td align="left" valign="middle">31.1 (1.07)</td><td align="left" valign="middle">4351 (1.00)</td></tr><tr><td align="center" valign="middle" rowspan="5">616xS. pneumoniae</td><td align="left" valign="middle">B2</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">26.1</td><td align="left" valign="middle">3146</td></tr><tr><td align="left" valign="middle">B2+UST</td><td align="left" valign="middle">0.61</td><td align="left" valign="middle">0.35</td><td align="left" valign="middle">31.1 (1.19)</td><td align="left" valign="middle">3146 (1.00)</td></tr><tr><td align="left" valign="middle">ProphAsm</td><td align="left" valign="middle">0.60</td><td align="left" valign="middle">0.33</td><td align="left" valign="middle">445 (17.0)</td><td align="left" valign="middle">434 (0.14)</td></tr><tr><td align="left" valign="middle">B2+GREEDY</td><td align="left" valign="middle">0.53 (0.89)</td><td align="left" valign="middle">0.13 (0.41)</td><td align="left" valign="middle">29.0 (1.11)</td><td align="left" valign="middle">3146 (1.00)</td></tr><tr><td align="left" valign="middle">B2+MATCH</td><td align="left" valign="middle">0.52 (0.88)</td><td align="left" valign="middle">0.14 (0.44)</td><td align="left" valign="middle">41.8 (1.60)</td><td align="left" valign="middle">3146 (1.00)</td></tr><tr><td align="center" valign="middle" rowspan="5">3682xE. coli</td><td align="left" valign="middle">B2</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">334</td><td align="left" valign="middle">7117</td></tr><tr><td align="left" valign="middle">B2+UST</td><td align="left" valign="middle">0.60</td><td align="left" valign="middle">0.35</td><td align="left" valign="middle">417 (1.25)</td><td align="left" valign="middle">7117 (1.00)</td></tr><tr><td align="left" valign="middle">ProphAsm</td><td align="left" valign="middle">0.59</td><td align="left" valign="middle">0.32</td><td align="left" valign="middle">13339 (39.9)</td><td align="left" valign="middle">7221 (1.01)</td></tr><tr><td align="center" valign="middle">B2+GREEDY</td><td align="left" valign="middle">0.51 (0.87)</td><td align="left" valign="middle">0.11 (0.33)</td><td align="left" valign="middle">384 (1.15)</td><td align="left" valign="middle">7117 (1.00)</td></tr><tr><td align="left" valign="middle">B2+MATCH</td><td align="left" valign="middle">0.50 (0.85)</td><td align="left" valign="middle">0.12 (0.37)</td><td align="left" valign="middle">861 (2.58)</td><td align="left" valign="middle">7962 (1.12)</td></tr><tr><td align="center" valign="middle" rowspan="3">~309kxSalmonella</td><td align="left" valign="middle">B2</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">82417</td><td align="left" valign="middle">13007</td></tr><tr><td align="left" valign="middle">B2+UST</td><td align="left" valign="middle">0.57</td><td align="left" valign="middle">0.36</td><td align="left" valign="middle">82841 (1.01)</td><td align="left" valign="middle">1300 (1.00)</td></tr><tr><td align="left" valign="middle">B2+GREEDY</td><td align="left" valign="middle">0.46 (0.81)</td><td align="left" valign="middle">0.11 (0.30)</td><td align="left" valign="middle">82726 (1.00)</td><td align="left" valign="middle">19512 (1.50)</td></tr><tr><td align="center" valign="middle" rowspan="3">2505xHuman</td><td align="left" valign="middle">CF</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">1.00</td><td align="left" valign="middle">77582</td><td align="left" valign="middle">411472</td></tr><tr><td align="left" valign="middle">CF+ProphAsm</td><td align="left" valign="middle">0.68</td><td align="left" valign="middle">0.31</td><td align="left" valign="middle">82797 (1.07)</td><td align="left" valign="middle">411472 (1.00)</td></tr><tr><td align="left" valign="middle">CF+GREEDY</td><td align="left" valign="middle">0.63 (0.93)</td><td align="left" valign="middle">0.16 (0.50)</td><td align="left" valign="middle">83507 (1.08)</td><td align="left" valign="middle">411472 (1.00)</td></tr></tbody></table><table-wrap-foot><fn id="TFN2"><p id="P145">We chose <italic>k</italic> = 31 and a min abundance of 1. The CL and SC ratios are between compressed strings and unitigs, and in parentheses are the ratios between our algorithm and the best competitor. B2 means BCALM2. For time and memory, we report the total time and maximum memory required to compute the tigs from the respective data set. BCALM2 directly computes unitigs and ProphAsm directly computes heuristic simplitigs. UST, GREEDY and MATCH compute heuristic simplitigs greedy matchtigs and matchtigs from unitigs. The number in parentheses behind time and memory indicates the slowdown/increase over computing just unitigs with BCALM2. All algorithms were run with 28 threads, except for UST which supports only one thread (the preceding run of BCALM2 was still executed with 28 threads), and ProphAsm, which supports only one thread as well. The N. gonorrhoeae pangenome contains 8.36 million unique kmers, the S. pneumoniae pangenome contains 19.3 million unique kmers, the E. coli pangenome contains 341 million unique kmers, the Salmonella pangenome contains 657 million unique kmers and the human pangenome contains 2.8 billion unique kmers. Due to its size, ProphAsm and MATCH could not be run on the Salmonella pangenome. Also due to size, BCALM2 did not run on the human pangenome, hence we used Cuttlefish 2. To still be able to compare against competitors, we ran ProphAsm on the unitigs produced by Cuttlefish 2 (UST requires extra information from BCALM2).</p></fn></table-wrap-foot></table-wrap><table-wrap-group id="T3" position="float" orientation="portrait"><label>Table 3</label><caption><title>Performance characteristics of querying different tigs with SSHash-Lite.</title></caption><table-wrap id="T01" position="float" orientation="portrait"><label>(a)</label><caption><title>regular SSHash-Lite</title></caption><table frame="hsides" rules="groups"><tbody><tr style="border-bottom: solid thin"><td align="center" valign="middle">genome</td><td align="center" valign="middle">algorithm</td><td align="center" valign="middle">index time [min]</td><td align="center" valign="middle">search time [sec]</td><td align="center" valign="middle">search speedup</td><td align="center" valign="middle">index size [GiB]</td><td align="center" valign="middle">size imprv.</td></tr><tr><td align="center" valign="middle" style="border-bottom: solid thin" rowspan="3">~309kxSalmonella (0.75)</td><td align="center" valign="middle">unitigs</td><td align="center" valign="middle">2.77</td><td align="center" valign="middle">3027</td><td align="center" valign="middle">1.00</td><td align="center" valign="middle">1.04</td><td align="center" valign="middle">1.00</td></tr><tr><td align="center" valign="middle">UST</td><td align="center" valign="middle">2.42</td><td align="center" valign="middle">1491</td><td align="center" valign="middle">2.03</td><td align="center" valign="middle">0.71</td><td align="center" valign="middle">1.48</td></tr><tr><td align="center" valign="middle">gMatchtigs</td><td align="center" valign="middle">2.60</td><td align="center" valign="middle">710</td><td align="center" valign="middle">4.26 (2.10)</td><td align="center" valign="middle">0.65</td><td align="center" valign="middle">1.60 (1.08)</td></tr><tr><td align="center" valign="middle" style="border-bottom: solid thin" rowspan="3">Human reads (0.75)</td><td align="center" valign="middle">unitigs</td><td align="center" valign="middle">18.9</td><td align="center" valign="middle">558</td><td align="center" valign="middle">1.00</td><td align="center" valign="middle">4.60</td><td align="center" valign="middle">1.00</td></tr><tr><td align="center" valign="middle">UST</td><td align="center" valign="middle">17.1</td><td align="center" valign="middle">499</td><td align="center" valign="middle">1.12</td><td align="center" valign="middle">3.63</td><td align="center" valign="middle">1.27</td></tr><tr><td align="center" valign="middle">gMatchtigs</td><td align="center" valign="middle">19.2</td><td align="center" valign="middle">384</td><td align="center" valign="middle">1.45 (1.30)</td><td align="center" valign="middle">3.47</td><td align="center" valign="middle">1.33 (1.05)</td></tr><tr><td align="center" valign="middle" style="border-bottom: solid thin" rowspan="3">2505xHuman (0.65)</td><td align="center" valign="middle">unitigs</td><td align="center" valign="middle">15.1</td><td align="center" valign="middle">515</td><td align="center" valign="middle">1.00</td><td align="center" valign="middle">3.63</td><td align="center" valign="middle">1.00</td></tr><tr><td align="center" valign="middle">ProphAsm</td><td align="center" valign="middle">14.0</td><td align="center" valign="middle">421</td><td align="center" valign="middle">1.22</td><td align="center" valign="middle">2.86</td><td align="center" valign="middle">1.27</td></tr><tr><td align="center" valign="middle">gMatchtigs</td><td align="center" valign="middle">14.8</td><td align="center" valign="middle">363</td><td align="center" valign="middle">1.42 (1.16)</td><td align="center" valign="middle">2.86</td><td align="center" valign="middle">1.27 (1.00)</td></tr></tbody></table></table-wrap><table-wrap id="T02" position="float" orientation="portrait"><label>(b)</label><caption><title>canonical SSHash-Lite</title></caption><table frame="hsides" rules="groups"><tbody><tr style="border-bottom: solid thin"><td align="center" valign="middle">genome</td><td align="center" valign="middle">algorithm</td><td align="center" valign="middle">index time [min]</td><td align="center" valign="middle">search time [sec]</td><td align="center" valign="middle">search speedup</td><td align="center" valign="middle">index size [GiB]</td><td align="center" valign="middle">size imprv.</td></tr><tr><td align="center" valign="middle" style="border-bottom: solid thin" rowspan="3">~309kxSalmonella (0.75)</td><td align="center" valign="middle">unitigs</td><td align="center" valign="middle">3.94</td><td align="center" valign="middle">1576</td><td align="center" valign="middle">1.00</td><td align="center" valign="middle">1.13</td><td align="center" valign="middle">1.00</td></tr><tr><td align="center" valign="middle">UST</td><td align="center" valign="middle">3.30</td><td align="center" valign="middle">961</td><td align="center" valign="middle">1.64</td><td align="center" valign="middle">0.78</td><td align="center" valign="middle">1.44</td></tr><tr><td align="center" valign="middle">gMatchtigs</td><td align="center" valign="middle">3.71</td><td align="center" valign="middle">572</td><td align="center" valign="middle">2.75 (1.68)</td><td align="center" valign="middle">0.74</td><td align="center" valign="middle">1.52 (1.06)</td></tr><tr><td align="center" valign="middle" style="border-bottom: solid thin" rowspan="3">Human reads (0.75)</td><td align="center" valign="middle">unitigs</td><td align="center" valign="middle">25.0</td><td align="center" valign="middle">373</td><td align="center" valign="middle">1.00</td><td align="center" valign="middle">5.02</td><td align="center" valign="middle">1.00</td></tr><tr><td align="center" valign="middle">UST</td><td align="center" valign="middle">23.4</td><td align="center" valign="middle">324</td><td align="center" valign="middle">1.15</td><td align="center" valign="middle">4.05</td><td align="center" valign="middle">1.24</td></tr><tr><td align="center" valign="middle">gMatchtigs</td><td align="center" valign="middle">26.3</td><td align="center" valign="middle">266</td><td align="center" valign="middle">1.40 (1.22)</td><td align="center" valign="middle">3.94</td><td align="center" valign="middle">1.28 (1.03)</td></tr><tr><td align="center" valign="middle" style="border-bottom: solid thin" rowspan="3">2505xHuman (0.65)</td><td align="center" valign="middle">unitigs</td><td align="center" valign="middle">21.3</td><td align="center" valign="middle">340</td><td align="center" valign="middle">1.00</td><td align="center" valign="middle">4.26</td><td align="center" valign="middle">1.00</td></tr><tr><td align="center" valign="middle">ProphAsm</td><td align="center" valign="middle">20.1</td><td align="center" valign="middle">258</td><td align="center" valign="middle">1.32</td><td align="center" valign="middle">3.48</td><td align="center" valign="middle">1.22</td></tr><tr><td align="center" valign="middle">gMatchtigs</td><td align="center" valign="middle">21.1</td><td align="center" valign="middle">232</td><td align="center" valign="middle">1.46 (1.11)</td><td align="center" valign="middle">3.52</td><td align="center" valign="middle">1.21 (0.99)</td></tr></tbody></table><table-wrap-foot><fn id="TFN3"><p id="P146">SSHash-Lite is run with <italic>k</italic> = 31 and a kmer-inclusion rate of 0.8. On the Salmonella pan-genome we used a minimizer length of 17 for the regular index and a minimizer length of 16 for the canonical index. On the human reads we used a minimizer length of 20 for the regular index and a minimizer length of 19 for the canonical index. On the human pangenome we used a minimizer length of 19 for the regular index and a minimizer length of 20 for the canonical index. The search speedup is with respect to unitigs, and the search speedup in parentheses is with respect to the strings computed by UST. Index time is the end-to-end time required to build the SSHash-Lite index: it includes reading the collections from disk and building the data structure using external memory. Searching time is the time required to check which reads have at least 80% of their kmers in the input SPSS. The number in parentheses under the genome is the kmer hitrate, i.e. the fraction of kmers from the query that are part of the queried dataset.</p></fn></table-wrap-foot></table-wrap></table-wrap-group></floats-group></article>