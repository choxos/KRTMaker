<!DOCTYPE article
 PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2 20190208//EN" "JATS-archivearticle1.dtd">
<article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="preprint"><?all-math-mml yes?><?use-mml?><?origin ukpmcpa?><front><journal-meta><journal-id journal-id-type="nlm-ta">bioRxiv</journal-id><journal-title-group><journal-title>bioRxiv : the preprint server for biology</journal-title></journal-title-group><issn pub-type="ppub"/></journal-meta><article-meta><article-id pub-id-type="manuscript">EMS156298</article-id><article-id pub-id-type="doi">10.1101/2022.10.26.513890</article-id><article-id pub-id-type="archive">PPR563011</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Aligning Distant Sequences to Graphs using Long Seed Sketches</article-title></title-group><contrib-group><contrib contrib-type="author" equal-contrib="yes"><name><surname>Joudaki</surname><given-names>Amir</given-names></name><email>amir.joudaki@inf.ethz.ch</email><xref ref-type="aff" rid="A1">1</xref><xref ref-type="aff" rid="A2">2</xref></contrib><contrib contrib-type="author" equal-contrib="yes"><name><surname>Meterez</surname><given-names>Alexandru</given-names></name><email>alexandru.meterez@inf.ethz.ch</email><xref ref-type="aff" rid="A1">1</xref></contrib><contrib contrib-type="author"><name><surname>Mustafa</surname><given-names>Harun</given-names></name><email>harun.mustafa@inf.ethz.ch</email><xref ref-type="aff" rid="A1">1</xref><xref ref-type="aff" rid="A2">2</xref><xref ref-type="aff" rid="A3">3</xref></contrib><contrib contrib-type="author"><name><surname>Koerkamp</surname><given-names>Ragnar Groot</given-names></name><email>ragnar groot.koerkamp@inf.ethz.ch</email><xref ref-type="aff" rid="A1">1</xref></contrib><contrib contrib-type="author"><name><surname>Kahles</surname><given-names>André</given-names></name><xref ref-type="aff" rid="A1">1</xref><xref ref-type="aff" rid="A2">2</xref><xref ref-type="aff" rid="A3">3</xref><xref ref-type="corresp" rid="CR1">†</xref></contrib><contrib contrib-type="author"><name><surname>Rätsch</surname><given-names>Gunnar</given-names></name><xref ref-type="aff" rid="A1">1</xref><xref ref-type="aff" rid="A2">2</xref><xref ref-type="aff" rid="A3">3</xref><xref ref-type="aff" rid="A4">4</xref><xref ref-type="corresp" rid="CR1">†</xref></contrib></contrib-group><aff id="A1"><label>1</label>Department of Computer Science, ETH Zurich, Zurich 8092, Switzerland</aff><aff id="A2"><label>2</label>University Hospital Zurich, Biomedical Informatics Research, Zurich 8091, Switzerland</aff><aff id="A3"><label>3</label>Swiss Institute of Bioinformatics, Lausanne 1015, Switzerland</aff><aff id="A4"><label>4</label>ETH AI Center, 8092 Zurich, Switzerland</aff><author-notes><corresp id="CR1">
<label>†</label>To whom correspondence should be addressed. <email>andré.kahles@inf.ethz.ch</email>; <email>gunnar.rätsch@inf.ethz.ch</email></corresp></author-notes><pub-date pub-type="nihms-submitted"><day>28</day><month>10</month><year>2022</year></pub-date><pub-date pub-type="preprint"><day>27</day><month>10</month><year>2022</year></pub-date><permissions><ali:free_to_read/><license><ali:license_ref>https://creativecommons.org/licenses/by-nc/4.0/</ali:license_ref><license-p>This work is licensed under a <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0 International license</ext-link>.</license-p></license></permissions><abstract><p id="P1">Sequence-to-graph alignment is an important step in applications such as variant genotyping, read error correction and genome assembly. When a query sequence requires a substantial number of edits to align, approximate alignment tools that follow the seed-and-extend approach require shorter seeds to get any matches. However, in large graphs with high variation, relying on a shorter seed length leads to an exponential increase in spurious matches. We propose a novel seeding approach relying on long inexact matches instead of short exact matches. We demonstrate experimentally that our approach achieves a better time-accuracy trade-off in settings with up to a 25% mutation rate.</p><p id="P2">We achieve this by sketching a subset of graph nodes and storing them in a <italic>K</italic>-nearest neighbor index. While sketches are more robust to indels, finding the nearest neighbor of a sketch in a high-dimensional space is more computationally challenging than finding exact seeds. We demonstrate that if we store sketch vectors in a <italic>K</italic>-nearest neighbor index, we can circumvent the curse of dimensionality. Our long sketch-based seed scheme contrasts existing approaches and highlights the important role that tensor sketching can play in bioinformatics applications. Our proposed seeding method and implementation have several advantages: i) We empirically show that our method is efficient and scales to graphs with 1 billion nodes, with time and memory requirements for preprocessing growing linearly with graph size and query time growing quasi-logarithmically with query length. ii) For queries with an edit distance of 25% relative to their length, on the 1 billion node graph, longer sketch-based seeds yield a 4 × increase in recall compared to exact seeds. iii) Conceptually, our seeder can be incorporated into other aligners, proposing a novel direction for sequence-to-graph alignment.</p><p id="P3">The implementation is available at:<ext-link ext-link-type="uri" xlink:href="https://github.com/ratschlab/tensor-sketch-alignment">https://github.com/ratschlab/tensor-sketch-alignment</ext-link>.</p></abstract><kwd-group><kwd>sequence-to-graph alignment</kwd><kwd>tensor sketching</kwd><kwd>tensor embedding</kwd></kwd-group></article-meta></front><body><sec id="S1" sec-type="intro"><label>1</label><title>Introduction</title><p id="P4">Our work focuses on <italic>sequence-to-graph alignment,</italic> defined as aligning a query sequence to a sequence graph [<xref ref-type="bibr" rid="R37">37</xref>,<xref ref-type="bibr" rid="R15">15</xref>]. Sequence-to-graph alignment involves finding the minimal number of <italic>editing operations</italic> to transform the query to a reference sequence encoded in the graph. While there are various cost schemes for penalizing edits, edit distance assigns a cost of 1 to <italic>substitution, insertion,</italic> and <italic>deletion</italic> on the query.</p><p id="P5">Since the time complexity of optimal sequence-to-graph alignment grows linearly with the number of edges in the graph [<xref ref-type="bibr" rid="R20">20</xref>,<xref ref-type="bibr" rid="R16">16</xref>], many approaches instead follow an approximate <italic>seed-and-extend</italic> strategy [<xref ref-type="bibr" rid="R2">2</xref>], which operates in four main steps: i) <italic>seed extraction,</italic> which in its simplest form involves finding all substrings with a certain length, ii) <italic>seed anchoring,</italic> finding matching nodes in the graph, iii) <italic>seed filtration,</italic> often involving clustering [<xref ref-type="bibr" rid="R9">9</xref>,<xref ref-type="bibr" rid="R37">37</xref>] or co-linear chaining [<xref ref-type="bibr" rid="R25">25</xref>,<xref ref-type="bibr" rid="R1">1</xref>,<xref ref-type="bibr" rid="R32">32</xref>,<xref ref-type="bibr" rid="R8">8</xref>] of seeds, and iv) <italic>seed extension,</italic> involving performing semi-global pairwise sequence alignment forwards and backwards from each anchored seed [<xref ref-type="bibr" rid="R28">28</xref>]. We will review the usage of exact seeds utilized in tools such as VG [<xref ref-type="bibr" rid="R15">15</xref>] and G<sc>RAPH</sc>A<sc>LIGNER</sc> [<xref ref-type="bibr" rid="R37">37</xref>] and discuss their limitations in a high mutation-rate setting.</p><p id="P6">Let us highlight the limitations of <italic>k-mers,</italic> defined as substrings with length <italic>k,</italic> as candidates for seeding, with an example.</p><sec id="S2"><title>Example 1</title><p id="P7">For reference sequence <italic>S ~</italic>{<monospace>A,C,G,T</monospace>}<italic><sup>N</sup></italic>, for <italic>i</italic> = 1 up to 100, with probability 1 – <italic>r</italic> copy the <italic>i</italic>-th character <italic>q<sub>i</sub>←S<sub>i</sub></italic>, and with probability <italic>r</italic> mutate it <italic>q<sub>i</sub></italic> ~ <italic>Σ</italic> \ {<italic>S<sub>i</sub></italic>}. The expected number of hits i.e. common <italic>k</italic>-mers between query and reference, is at most (100/<italic>k</italic>)(1 – <italic>r</italic>)<italic><sup>k</sup></italic>. On the other hand, the expected number of spurious hits is <italic>N</italic>4<sup>–<italic>k</italic></sup>.</p><p id="P8">The simple setting in <xref ref-type="sec" rid="S2">Example 1</xref> illustrates the challenge many alignment methods face in practice. Since using a large <italic>k</italic> for seed length reduces the number of spurious matches, methods such as BWA-MEM [<xref ref-type="bibr" rid="R28">28</xref>], E-MEM [<xref ref-type="bibr" rid="R26">26</xref>], DEBGA [<xref ref-type="bibr" rid="R31">31</xref>], and P<sc>UFF</sc>A<sc>LIGNER</sc> [<xref ref-type="bibr" rid="R1">1</xref>] find maximal exact matches (MEMs) between the read and the reference genome. However, the higher precision comes at the expense of fewer seeds and lower recall. For example, for <italic>k</italic> = 21 in <xref ref-type="sec" rid="S2">Example 1</xref>, finding an exact seed for a query with mutation rate <italic>r</italic> = 0.25 becomes exceedingly rare, the expected number of hits being (100/21)(1 – 0.25)<sup>21</sup>≈0.01.</p><p id="P9">The alternative is to use shorter seeds to increase the likelihood of finding accurate alignments. Methods that use De Bruijn graphs as graph model [<xref ref-type="bibr" rid="R5">5</xref>], or an auxiliary index [<xref ref-type="bibr" rid="R40">40</xref>], are restricted to finding seeds of minimum length <italic>k</italic>. To find seeds when the query has a high edit distance relative to the reference sequences, sequence-to-graph alignment tools will either set <italic>k</italic> to a small value [<xref ref-type="bibr" rid="R30">30</xref>,<xref ref-type="bibr" rid="R15">15</xref>,<xref ref-type="bibr" rid="R37">37</xref>] or use a variable-order DBG model [<xref ref-type="bibr" rid="R4">4</xref>,<xref ref-type="bibr" rid="R3">3</xref>,<xref ref-type="bibr" rid="R24">24</xref>,<xref ref-type="bibr" rid="R25">25</xref>] to also allow for anchoring seeds of length less than <italic>k</italic> [<xref ref-type="bibr" rid="R24">24</xref>,<xref ref-type="bibr" rid="R25">25</xref>]. However, shorter seeds generally lead to a more complex and connected graph topology which can lead to a combinatorial explosion of the search space. In the same setting as <xref ref-type="sec" rid="S2">Example 1</xref>, with <italic>N</italic> = 10<sup>9</sup>and <italic>k</italic> = 12, there will be 10<sup>9</sup>/4<sup>12</sup>≈60 false positive matches for every true positive match, while for <italic>r</italic> = 0.25 mutation rate the recall will be (100/12)(1 – 0.25)<sup>12</sup>≈0.26. Therefore, any attempt of changing <italic>k</italic> will either risk a lower recall or a higher false positive.</p><p id="P10">Due to the inherent shortcomings of short and long exact matches, Břinda, et al. [<xref ref-type="bibr" rid="R6">6</xref>] propose <italic>spaced seeds</italic> to incorporate long seeds at higher mutation rates by masking out some positions in the seed. For example, using 0101 as a mask, “<monospace>A<underline>C</underline>G<underline>T</underline></monospace>” will match with “<monospace>G<underline>C</underline>A<underline>T</underline></monospace>”. While spaced seeds were shown to be more sensitive than contiguous seeds without increasing the number of spurious matches, they assume that only mismatches occur in the alignment with no <italic>insertions</italic> or <italic>deletions (indels)</italic> [<xref ref-type="bibr" rid="R33">33</xref>].</p><p id="P11">In this work, we propose using long inexact seeds based on TENSOR SKETCHING [<xref ref-type="bibr" rid="R23">23</xref>]. We use a succinct <italic>De Bruijn graph (DBG)</italic> [<xref ref-type="bibr" rid="R5">5</xref>] as the graph model, and preprocess it in two main stages: i) A subset of nodes in the DBG is sketched into a vector space, while insertions, deletions, and substitutions are approximately embedded into the <italic>L</italic><sup>2</sup> metric. ii) To be able to efficiently retrieve similar sketch vectors, the sketches of nodes are stored in a <italic>Hierarchical Navigable Small Worlds (HNSW)</italic> [<xref ref-type="bibr" rid="R34">34</xref>] index. Aligning a query sequence involves three main stages: i) Compute sketch vectors for all <italic>k</italic>-mers in the query. ii) Use the HNSW index to find the nearest vectors as candidate seeds. iii) Extend these seeds backwards and forwards to find the best possible alignment. <xref ref-type="fig" rid="F1">Figure 1</xref> gives an overview of our sketch-based scheme.</p></sec><sec id="S3"><title>Structure of the manuscript</title><p id="P12">In <xref ref-type="sec" rid="S5">Section 2.1</xref>, we introduce our notation, formalize the problem of sequence-to-graph-alignment, and explain how tensor sketching estimates edit distances. In <xref ref-type="sec" rid="S14">Section 2.3</xref>, we introduce the hierarchical index for inexact search, and in <xref ref-type="sec" rid="S15">Section 2.4</xref>, we empirically compare our method against other tools. <xref ref-type="sec" rid="S16">Section 3</xref> is dedicated to our experimental validations, starting with the synthetic sequence generation in <xref ref-type="sec" rid="S17">Section 3.1</xref>. The accuracy and scalability of our method are covered in <xref ref-type="sec" rid="S19">Sections 3.3</xref> and <xref ref-type="sec" rid="S18">3.2</xref>, respectively. Finally, we present the limitations of sketch-based seeds, as well as future directions in <xref ref-type="sec" rid="S23">Section 4</xref>.</p></sec></sec><sec id="S4" sec-type="methods"><label>2</label><title>Methods</title><sec id="S5"><label>2.1</label><title>Preliminaries</title><sec id="S6"><title>Terminology and notation</title><p id="P13">We use [<italic>N</italic>] :={1,…,<italic>N</italic>}. <italic>Σ</italic> denotes the alphabet, e.g., the nucleotides {<monospace>A,C,G,T</monospace>}, or amino acids. For <italic>k</italic> ∈ ℕ<sup>+</sup>, <italic>Σ</italic>* denotes the set of all strings over <italic>Σ</italic>, and <italic>Σ<sup>k</sup></italic> denotes the subset of all strings with length <italic>k</italic>. Throughout the text, we use the terms string and sequence interchangeably to refer to members of <italic>Σ</italic>*. <italic>q</italic>[<italic>i</italic>] and <italic>q<sub>i</sub></italic> denote the <italic>i</italic>-th character of the sequence, and <italic>q</italic>[<italic>i</italic>: <italic>j</italic>] := <italic>q<sub>i</sub>q<sub>i</sub><sub>+1</sub>…q<sub>j</sub></italic> denotes the sliced substring from <italic>i</italic>, up to <italic>j</italic>. <italic>k</italic>-mers(<italic>s</italic>) denote the substrings of length <italic>k</italic> in string <italic>s</italic>: <italic>k</italic>-mers(<italic>s</italic>) :={<italic>s</italic>[<italic>i: i + k</italic> – 1]: 1 ≤ <italic>i</italic> ≤ |<italic>s</italic>| – <italic>k</italic> + 1}. <italic>p</italic> ∘ <italic>q</italic> denotes the concatenation of <italic>p</italic> and <italic>q</italic>. The <italic>edit distance</italic> ed(<italic>p</italic>, <italic>q</italic>), also referred to as the Levenshtein distance [<xref ref-type="bibr" rid="R41">41</xref>], is defined as the minimum number of insertion, deletion, and substitution operations needed to transform one sequence into the other. The normalized edit distance, is defined as edit distance divided by maximum length <inline-formula><mml:math id="M1"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mtext>ed</mml:mtext></mml:mrow><mml:mo stretchy="true">˜</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.2em"/><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mtext>ed</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>/</mml:mo><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>p</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>q</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Throughout the manuscript, the term “mutation” refers to the normalized edit distance, serving as an abstraction for the combined biological sources of variation and errors in sequencing.</p></sec><sec id="S7"><title>Succinct De Bruijn graph (DBG)</title><p id="P14">The reference DBG is a directed graph over the reference sequences that encodes all substrings of length <italic>k</italic> as vertices and all substrings of length <italic>k</italic> + 1 as directed edges. Formally, let <inline-formula><mml:math id="M2"><mml:mrow><mml:mi mathvariant="script">S</mml:mi><mml:mspace width="0.2em"/><mml:mo>=</mml:mo><mml:mspace width="0.2em"/><mml:mo>{</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be the input sequences. The reference graph is a directed graph <italic>G</italic> = (<italic>V, E</italic>), with vertices <inline-formula><mml:math id="M3"><mml:mrow><mml:mi>V</mml:mi><mml:mspace width="0.2em"/><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mo>∪</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> <italic>k</italic>-mers(<italic>s</italic>) and edges <italic>E</italic> :={(<italic>u, v,v</italic>[<italic>k</italic>]) ∈ <italic>V × V × Σ</italic>: <italic>u</italic>[2: <italic>k</italic>] =<italic>v</italic>[1: <italic>k</italic> – 1]}. The label of edge <italic>e</italic> = (<italic>u, v,v</italic>[<italic>k</italic>]) ∈ <italic>E</italic> is denoted by <italic>l<sub>e</sub></italic> :=<italic>v</italic>[<italic>k</italic>] <italic>∈ Σ</italic>.</p></sec><sec id="S8"><title>Sequence-to-graph alignment</title><p id="P15">Define <inline-formula><mml:math id="M4"><mml:mrow><mml:msub><mml:mi mathvariant="script">W</mml:mi><mml:mi>G</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> as the set of all walks, where each walk <inline-formula><mml:math id="M5"><mml:mrow><mml:mi>w</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">W</mml:mi><mml:mi>G</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is defined as a list of adjacent edges <italic>w</italic> = ((<italic>v</italic><sub>0</sub>,<italic>v</italic><sub>1</sub>,<italic>l</italic><sub>1</sub>),…, (<italic>v</italic><sub>|<italic>w</italic>|–1</sub>,<italic>v</italic><sub>|<italic>w</italic>|</sub>,<italic>l</italic><sub>|<italic>w</italic>|</sub>)) ∈ <italic>E</italic><sup>|<italic>w</italic>|</sup>. Define the <italic>spelling</italic> of a walk as the concatenation of the first <italic>k</italic>-mer on the walk, with the labels of the rest of the edges on the same walk π(<italic>w</italic>) := <italic>v</italic><sub>0</sub> ∘ <italic>l</italic><sub>1</sub><italic>l</italic><sub>2</sub>… <italic>l</italic><sub>|w|</sub>. Thus, given the query sequence <italic>q</italic> ∈ <italic>Σ</italic>* and the reference graph <italic>G</italic>, the optimal <italic>alignment</italic> is the set of walks which achieves the minimum edit distance between the query sequence and the spelling of the walk <inline-formula><mml:math id="M6"><mml:mrow><mml:mtext>align</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.2em"/><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>arg</mml:mi><mml:msub><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">W</mml:mi><mml:mi>G</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtext>ed</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>π</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>w</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p></sec></sec><sec id="S9"><label>2.2</label><title><bold>Estimating edit distance using</bold> TENSOR SKETCH</title><p id="P16">Our approach to the seed extraction and anchoring steps of seed-and-extend (see <xref ref-type="sec" rid="S1">Section 1</xref>) is based on an index of <italic>k-mer sketches</italic> rather than <italic>k</italic>-mers. Briefly, we compute Tensor Sketches [<xref ref-type="bibr" rid="R23">23</xref>] of the graph nodes and store them in a nearest-neighbor search index [<xref ref-type="bibr" rid="R22">22</xref>] that maps each sketch to its corresponding graph node.</p><p id="P17">Tensor Sketching (TS) maps sequences to a vector space that embeds the edit distance into the <italic>l</italic><sup>2</sup> metric. Conceptually, TS can be described in two steps: i) Tensor Embedding (TE), which counts how many times each subsequence appears in the sequence, ii) Implicit tensor sketching, which lowers the dimension without constructing the larger tensor embedding space.</p><sec id="S10"><title>Tensor Embedding</title><p id="P18">Given sequence <italic>a ∈ Σ<sup>n</sup></italic>, define ℐ as set of increasing subsequences of length <italic>t</italic>: <italic>ℐ</italic> :={(<italic>i</italic><sub>1</sub>,…,<italic>i</italic><sub>t</sub>) ∈ [<italic>n</italic>]<sup>t</sup>: <italic>i</italic><sub>1</sub>&lt;…&lt;<italic>i</italic><sub>t</sub>}, and for all <italic>s</italic> ∈ <italic>Σ<sup>t</sup></italic>, define tensor embedding <italic>T<sub>a</sub></italic>[<italic>s</italic>] as the count of all subsequences of length <italic>t</italic> in <italic>s</italic>: <italic>T<sub>a</sub></italic>[<italic>s</italic>] := #{<italic>I</italic> ∈ ℐ: <italic>a</italic>[<italic>i</italic><sub>1</sub>,…,<italic>i<sub>t</sub></italic>] = <italic>s</italic>}. We can view <italic>T<sub>a</sub></italic> as a <italic>|Σ|<sup>t</sup></italic>-dimensional tensor, with the alphabet as its indices. Given sequences <italic>a, b,</italic> we approximate the edit distance by <inline-formula><mml:math id="M7"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mi>a</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula> up to a constant factor. <xref ref-type="fig" rid="F2">Figure 2</xref> illustrates how the embedding distance approximates edit operations.</p></sec><sec id="S11"><title>Tensor embedding preserves Hamming distance under <italic>l</italic><sup>2</sup>-norm</title><p id="P19">Intuitively, tensor embeddings are robust to mutations because they count and sketch subsequences instead of <italic>k</italic>-mers. We can define normalized tensor embedding distance <italic>d<sub>te</sub></italic> between two sequences <italic>a</italic> and <italic>b</italic> as: <disp-formula id="FD1"><label>(1)</label><mml:math id="M8"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.2em"/><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>n</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mn>2</mml:mn><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>⋅</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mi>a</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn><mml:mn>2</mml:mn></mml:msubsup><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
</p><p id="P20">The following lemma demonstrates that tensor embedding preserves edit distance:</p></sec><sec id="S12"><title>Lemma 1</title><p id="P21"><italic>Let a be a uniform random sequence of length n in Σ<sup>n</sup>, and for a fixed mutation rate r</italic> ∈ [0,1] <italic>let b be a sequence where a<sub>i</sub> is substituted by a new character b<sub>i</sub> ∈ Unif(Σ\a<sub>i</sub>) with probability r and b<sub>i</sub> = a<sub>i</sub> otherwise. Then for n ≫ 2tα:</italic>
<disp-formula id="FD2"><label>(2)</label><mml:math id="M9"><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">E</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mspace width="0.2em"/><mml:mo>=</mml:mo><mml:mspace width="0.2em"/><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mn>4</mml:mn><mml:mo>/</mml:mo><mml:mi>σ</mml:mi></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>⋅</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>t</mml:mi><mml:msup><mml:mi>σ</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula> <italic>which for DNA with α</italic> = 4 <italic>and fixed <italic>t</italic> gives <inline-formula><mml:math id="M10"><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">E</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mspace width="0.2em"/><mml:mo>=</mml:mo><mml:mspace width="0.2em"/><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>n</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:math></inline-formula>.</italic></p><p id="P22">Note that the (4/σ)<sup>t–1</sup>factor does not depend on the sequences. Therefore, <xref ref-type="sec" rid="S12">Lemma 1</xref> provides a guarantee that the average distance of mutated pairs remains within a linear estimate of the mutation. Observe that the edit distance in this setting will be <italic>nr</italic>. Therefore, we can, alternatively, refer to <italic>r</italic> as edit distance normalized by length. The proof of <xref ref-type="sec" rid="S12">Lemma 1</xref> is given in <xref ref-type="supplementary-material" rid="SD1">Appendix B</xref>. For numerical validation of this bound, see <xref ref-type="fig" rid="F3">Figure 3</xref>.</p></sec><sec id="S13"><title>Tensor Sketching</title><p id="P23">Tensor Sketching is an implicit, Euclidean-norm preserving dimensionality reduction scheme. Crucially, it projects <italic>|Σ|<sup>t</sup></italic>-dimensional tensors onto constant <italic>D ∈</italic> ℕ<sup>+</sup>dimensions and linearly preserves <italic>l</italic><sup>2</sup> distances, without ever constructing the tensors. We define the tensor sketching function <italic>ϕ</italic>: ℝ<sup>|<italic>Σ</italic></sup>|→ ℝ<sup><italic>D</italic></sup>, that embeds an <italic>|Σ|<sup>t</sup></italic>-dimensional tensor into ℝ<sup><italic>D</italic></sup>. Given pairwise independent hash functions <italic>s<sub>i</sub>, h<sub>i</sub></italic>: <italic>Σ</italic>→[<italic>D</italic>] and <italic>s<sub>i</sub></italic>: <italic>Σ</italic>→{-1,1}, define the tuple hash <inline-formula><mml:math id="M11"><mml:mrow><mml:mi>H</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>A</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.2em"/><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msubsup><mml:mi>∑</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:math></inline-formula> mod <italic>D</italic>, and tuple sign hash <inline-formula><mml:math id="M12"><mml:mrow><mml:mi>S</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>A</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.2em"/><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>∏</mml:mo><mml:mi>i</mml:mi><mml:mi>t</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="M13"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>Σ</mml:mi><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. Finally, the tensor sketch <italic>ϕ</italic> for a tensor <italic>T</italic> ∈ ℝ <sup>|<italic>Σ</italic>|<sup>t</sup></sup> is defined as <inline-formula><mml:math id="M14"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>T</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mspace width="0.2em"/><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>Σ</mml:mi><mml:mi>t</mml:mi></mml:msup><mml:mspace width="0.2em"/><mml:mo>:</mml:mo><mml:mi>H</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>A</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mi>S</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>A</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>T</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>A</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:math></inline-formula> for all <italic>r</italic> ∈ [<italic>D</italic>].</p><p id="P24">Crucially, we have <inline-formula><mml:math id="M15"><mml:mrow><mml:mi mathvariant="double-struck">E</mml:mi><mml:msubsup><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>T</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn><mml:mn>2</mml:mn></mml:msubsup><mml:mspace width="0.2em"/><mml:mo>=</mml:mo><mml:mspace width="0.2em"/><mml:msubsup><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mi>T</mml:mi><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula> and bounded second moments <inline-formula><mml:math id="M16"><mml:mrow><mml:mtext>Var</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>T</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.2em"/><mml:mo>≤</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mi>T</mml:mi><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mi>D</mml:mi></mml:mfrac><mml:mspace width="0.2em"/></mml:mrow></mml:math></inline-formula> (See Lemma 7 of [<xref ref-type="bibr" rid="R36">36</xref>]). <xref ref-type="fig" rid="F3">Figure 3</xref> shows lower and upper bounds. Finally, [<xref ref-type="bibr" rid="R23">23</xref>] reports that <italic>Tensor Slide Sketch (TSS),</italic> which concatenates tensor sketches of windows <italic>w</italic>, using a stride <italic>△</italic> within a given <italic>k</italic>-mer, improves the sensitivity to smaller edit distances. Therefore, we used TSS for our seeding scheme (See <xref ref-type="supplementary-material" rid="SD1">Appendix C</xref> for more details).</p></sec></sec><sec id="S14"><label>2.3</label><title>Anchoring seeds with a hierarchical search index</title><p id="P25">The final pre-processing step is to build a <italic>K</italic>-Nearest Neighbor index of sketches. Conceptually, we can represent the search index as a function from vector space ℝ<sup><italic>D</italic></sup> to a list of graph nodes <italic>K</italic>-NN(<italic>v</italic>) = (<italic>vi,…, v<sub>K</sub></italic>), for some pre-determined number of neighbors <italic>K</italic> ∈ ℕ<sup>+</sup>. During the alignment, we anchor every seed in the query <italic>s</italic> ∈ <italic>k</italic>-mers(<italic>q</italic>), to the vertices returned by the index <italic>K</italic>-NN(<italic>φ</italic>(<italic>s</italic>)).</p><p id="P26">Note that if <italic>v</italic> and <italic>u</italic> are within <italic>s</italic> steps on the graph, they share <inline-formula><mml:math id="M17"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>s</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> of their sequence content. To avoid indexing redundant information, we only store a <italic>k</italic>cover of the graph, defined as a subset of vertices such that any walk on the graph with over <italic>k</italic> nodes contains at least one node in the <italic>k</italic>cover. For any walk <inline-formula><mml:math id="M18"><mml:mrow><mml:mi>W</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">W</mml:mi><mml:mi>G</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>W</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>≥</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, it holds that <italic>W</italic>⋂<italic>k</italic> cover(<italic>G</italic>) ≠ ∅. Observe that if the optimal alignment walk for a query has over <italic>k</italic> nodes, it suffices to sketch the <italic>k</italic>-cover to anchor at least one of its seeds.</p><p id="P27">While sketch vectors are more robust to mutations than exact seeds, retrieving nearest neighbors in a high dimensional space faces the <italic>curse of dimensionality</italic> [<xref ref-type="bibr" rid="R27">27</xref>]. <italic>Locality Sensitive Hashing</italic> [<xref ref-type="bibr" rid="R19">19</xref>,<xref ref-type="bibr" rid="R10">10</xref>] is the first method to get a constant approximation for the nearest neighbors problem, with a theoretically proven sub-linear time with respect to dataset size. However, to scale to billions of nodes in the genome graphs, it is crucial to store sketch vectors in a <italic>Hierarchical Navigable Small Worlds</italic> (HNSW) index [<xref ref-type="bibr" rid="R34">34</xref>]. We use the efficient implementation of HNSW from F<sc>ACEBOOK</sc> AI S<sc>IMILARITY</sc> S<sc>EARCH</sc> (FAISS) [<xref ref-type="bibr" rid="R22">22</xref>]. The pseudo-code for the anchoring is presented in <xref ref-type="boxed-text" rid="BX1">Algorithm 1</xref>.</p><boxed-text id="BX1" position="anchor" content-type="below"><caption><title><bold>Algorithm 1:</bold> ANCHORING</title></caption><p id="P28"><bold>Input :</bold> De Bruijn graph <italic>G</italic>(<italic>V, E</italic>)</p><p id="P29">             Query <italic>q</italic> ∈ <italic>Σ</italic>*</p><p id="P30"><bold>Output :</bold> Anchors <italic>A</italic> ⊆ <italic>k</italic>-mers(<italic>q</italic>) × <italic>V<sup>K</sup></italic></p><p id="P31"><bold>Parameter:</bold> Neighbours <italic>K</italic> ∈ ℕ<sup>+</sup></p><p id="P32"><italic>H</italic> ← HNSW()</p><p id="P33"><bold>for</bold> <italic>v in k</italic>-COVER(<italic>G</italic>) <bold>do</bold></p><p id="P34">      <italic>Φ</italic> ← SKETCH(<italic>v</italic>)</p><p id="P35">      <italic>H</italic>.ADD(<italic>Φ</italic>)</p><p id="P36">end</p><p id="P37"><bold>A</bold> ← {}</p><p id="P38"><bold>for</bold> <italic>s in k</italic>-MERS(<italic>q</italic>) <bold>do</bold></p><p id="P39">      <italic>Φ</italic> ← SKETCH(<italic>s</italic>)</p><p id="P40">      <italic>A</italic> ← <italic>A</italic> ∪ {(<italic>a,H</italic>.KNN(<italic>Φ</italic>))}</p><p id="P41">end</p><p id="P42"><bold>Return :</bold> A</p></boxed-text></sec><sec id="S15"><label>2.4</label><title>Adjusting extension for misaligned anchors</title><p id="P43">M<sc>ETAGRAPH</sc> A<sc>LIGN</sc> (MG-A<sc>LIGN</sc>) follows a seed-and-extend approach, with a dynamic program to determine which path to take in the graph, producing a semi-global alignment. We made a few modifications to adjust for misaligned anchors in the MG-S<sc>KETCH</sc> seeder. To demonstrate this issue, let <italic>v</italic><sub>1</sub>,<italic>v</italic><sub>2</sub>,…, <italic>v<sub>M</sub></italic> denote a list of adjacent <italic>k</italic>-mers on the graph, and let <italic>s</italic><sub>1</sub>,…, <italic>s</italic><sub>|<italic>q</italic>|–k+1</sub> denote seeds in the query <italic>s<sub>i</sub></italic> := <italic>q</italic>[<italic>i</italic> : <italic>i</italic> + <italic>k</italic> – 1]. Let us assume that if <italic>s<sub>i</sub></italic> is anchored to <italic>v<sub>j</sub></italic>, the alignment will be optimal. Observe that ed(<italic>s<sub>i</sub>, s<sub>i</sub><sub>+δ</sub></italic>) ≤ 2δ, obtained by deleting the initial δ characters from <italic>s<sub>i</sub></italic> and inserting the last δ characters of <italic>v<sub>i+δ</sub></italic>. By the triangle inequality, if ed(<italic>s<sub>i</sub>, v<sub>j</sub></italic>) ≤ <italic>d</italic>, it holds that ed(<italic>s<sub>i+δ</sub>, v<sub>j</sub></italic>) ≤ <italic>d</italic>+2δ. While T<sc>ENSOR</sc> S<sc>KETCHING</sc> preserves the edit distance, due to inherent stochasticity in sketching and retrieval, <italic>s<sub>i+δ</sub></italic> may be anchored to <italic>v<sub>j</sub></italic>, instead of <italic>s<sub>i</sub></italic> to <italic>v<sub>j</sub></italic>. This may produce an additional cost of 2δ during the forward and backward extension. To avoid this unnecessary cost, during the forward extension, indels occurring in the beginning of the query are free. If the forward extension completes, we initiate the backward extension from the position of the first matching positions.</p></sec></sec><sec id="S16"><label>3</label><title>Experimental results</title><p id="P44">We implemented the M<sc>ETAGRAPH</sc> S<sc>KETCH</sc> (MG-S<sc>KETCH</sc>) algorithm, which uses our novel sketch-based seeder, in the M<sc>ETAGRAPH</sc> [<xref ref-type="bibr" rid="R24">24</xref>] framework. We primarily compare against M<sc>ETAGRAPH</sc> A<sc>LIGN</sc> (MG-A<sc>LIGN</sc>), which is also implemented in M<sc>ETAGRAPH</sc>, but uses an exact seeding scheme. We compare MG-S<sc>KETCH</sc> against G<sc>RAPH</sc>A<sc>LIGNER</sc> (GA) [<xref ref-type="bibr" rid="R37">37</xref>], <sc>VG MAP</sc> [<xref ref-type="bibr" rid="R18">18</xref>] and <sc>VG MPMAP</sc> [<xref ref-type="bibr" rid="R39">39</xref>] on both synthetic and real datasets (See <xref ref-type="supplementary-material" rid="SD1">Appendix A</xref> for more details).</p><sec id="S17"><label>3.1</label><title>Synthetic Data Generation</title><p id="P45">We generate a synthetic dataset by initializing the sequence pool with <inline-formula><mml:math id="M19"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>←</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, where <italic>s</italic><sub>0</sub> is a random sequence <italic>s</italic><sub>0</sub>~<italic>Σ<sup>N</sup></italic>, for some fixed length <italic>N</italic> ∈ ℕ<sup>+</sup>. At each level <italic>i</italic> ∈ ℕ<sup>+</sup>, we randomly mutate all sequences in the pool by independently substituting every character with 1% probability. We add the mutated sequences to the pool <inline-formula><mml:math id="M20"><mml:mrow><mml:mi mathvariant="script">S</mml:mi><mml:mo>←</mml:mo><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtext>mutate</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>:</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, doubling the pool size. We repeat this process up to <italic>l</italic> levels.</p><p id="P46">We build a De Bruijn graph <italic>G</italic> using M<sc>ETAGRAPH</sc> [<xref ref-type="bibr" rid="R24">24</xref>], on the synthetic sequences <inline-formula><mml:math id="M21"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with <italic>N</italic> = 1000 and <italic>k</italic> = 80. Recall that all sequences in <italic>S<sub>l</sub></italic> are of size <italic>N</italic>, resulting in 2<italic><sup>l</sup>N</italic> nodes in the graph. Construction of <italic>S<sub>l</sub></italic> ensures that approximately 1% of the nodes in <italic>G</italic> are “branching”, i.e. they have at least one incoming or outgoing connection, thereby increasing the difficulty of the sequence-to-graph alignment.</p><p id="P47">To generate ground truth sequences for alignment, we start with a random walk <italic>w<sub>i</sub></italic> in the graph with 250 edges, yielding reference sequences <italic>s<sub>i</sub></italic>:= π(<italic>w<sub>i</sub></italic>), with length |π(<italic>w<sub>i</sub></italic>)| = 80 + 250 = 330. To obtain the query, we apply mutations with rates 5%, 10%, 15%, 20%, and 25% to the references <italic>q<sub>i</sub></italic> := mutate<italic><sub>r</sub></italic>(<italic>s<sub>i</sub></italic>). Conceptually, the alignment method <italic>f</italic> takes the query <italic>q<sub>i</sub></italic> and graph <italic>G</italic> as input, and returns a candidate spell <italic>f</italic>(<italic>q<sub>i</sub>, G</italic>) as output. We quantify the optimality of <italic>f</italic> by measuring the edit distance between the reference and the candidate spell: ed (<italic>s<sub>i</sub>,f</italic>(<italic>q<sub>i</sub></italic>)). We define recall as ed(<italic>s<sub>i</sub>,f(q<sub>i</sub></italic>)) ≤ <italic>k</italic>λ, where λ ∈ [0,1] controls the accuracy of the alignment (lower is more accurate). For all experiments, we set λ = 0.1. Finally, we average the recall and alignment time per query over 500 samples at each mutation rate: <inline-formula><mml:math id="M22"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Recall</mml:mtext></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>r</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>500</mml:mn></mml:mrow></mml:mfrac><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mn>500</mml:mn></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mspace width="0.2em"/><mml:mo>:</mml:mo><mml:mtext>ed</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>q</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mi>λ</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p></sec><sec id="S18"><label>3.2</label><title>Sketch-based alignment achieves high recall in high mutation settings</title><p id="P48">We show that MG-S<sc>KETCH</sc> achieves a uniformly higher recall than MG-A<sc>LIGN</sc>. <xref ref-type="fig" rid="F5">Figure 5</xref> shows that MG-S<sc>KETCH</sc> outperforms MG-A<sc>LIGN</sc> across all graph sizes, particularly in high mutation regimes. MG-S<sc>KETCH</sc> reaches 3× and 1.8× higher recall than MG-ALIGN on 25% and 20% mutation rates respectively, while getting a comparable or better recall in all other cases. If MG-A<sc>LIGN</sc> does not find exact 80-mer matches, it falls back to shorter seeds, until a minimum seed length of 15. If we compute the expected number of hits analogous to <xref ref-type="sec" rid="S2">Example 1</xref>, we get (330/15)(1 – 0.25)<sup>15</sup>≈0.29. This is comparable to the empirical value for 25% mutation in <xref ref-type="fig" rid="F5">Figure 5</xref>. Remarkably, MG-S<sc>KETCH</sc> exceeds this recall by a significant margin, highlighting the importance of long inexact seeds.</p></sec><sec id="S19"><label>3.3</label><title>Sketch-based aligner scales quasi-linearly with graph size</title><p id="P49">We show that the high accuracy of MG-SKETCH does not compromise scalability. To compare the scalability of our approach, we measured peak memory usage and average alignment time per query for graphs with <italic>l</italic> ∈ {4,…, 20}, as outlined in <xref ref-type="sec" rid="S17">Section 3.1</xref>. This generates graphs with 16000 up to approximately 1B <italic>k</italic>-mers, posing a challenge to the scalability of each method. We use the M<sc>ETAGRAPH</sc> base graph for evaluating MG-S<sc>KETCH</sc> and MG-A<sc>LIGN</sc> (See <xref ref-type="supplementary-material" rid="SD1">Appendix A</xref> for more details).</p><sec id="S20"><title>Peak memory usage scales linearly with graph size</title><p id="P50">Peak memory usage imposes a hard limit on the size of graphs that a method can preprocess. In <xref ref-type="fig" rid="F6">Figure 6</xref>, we observe that peak memory usage in MG-S<sc>KETCH</sc> scales linearly with the graph size. In particular, for graphs with over 10M nodes, MG-S<sc>KETCH</sc> requires less memory than all other methods except MG-A<sc>LIGN</sc>. For MG-A<sc>LIGN</sc>,lower memory usage comes at the cost of lower recall, when compared to MG-S<sc>KETCH</sc>. In contrast, <sc>VG MPMAP</sc> peak memory usage grows rapidly above 80GB. Therefore, we only evaluate <sc>VG MPMAP</sc> for graphs with up to 1M nodes. While <sc>VG MAP</sc> requires less memory than <sc>VG MPMAP</sc>, the runtime exceeded 24 hours for graphs with over 60M nodes. It is evident in <xref ref-type="fig" rid="F6">Figure 6</xref> that the peak memory usage of GA grows faster than linear, making MG-S<sc>KETCH</sc> and MG-A<sc>LIGN</sc> the only methods with linear memory complexity.</p></sec><sec id="S21"><title>Query alignment time grows logarithmically with graph size</title><p id="P51">Given that sequence graphs have billions of nodes, it is crucial for the alignment time to grow logarithmically with the graph size. <xref ref-type="fig" rid="F6">Figure 6</xref> demonstrates that MG-SKETCH achieves a logarithmic scale with the graph size. In contrast, the average time for VG MAP and VG MPMAP grows faster than logarithmically. The alignment time for GA also grows faster than linearly, however, this includes the preprocessing time for building the minimizer seeder from the graph.</p><p id="P52">Notably, the scalability of MG-SKETCH does not compromise the recall. <xref ref-type="fig" rid="F4">Figure 4</xref> demonstrates that for all graph sizes and mutation rates, MG-SKETCH achieves a higher or equal recall compared to the other tools, with the exception of VG MPMAP. While VG MPMAP has higher recall at 25%, for graphs with over 1M it exceeds our memory limit of 80GB.</p></sec></sec><sec id="S22"><label>3.4</label><title>Good scalability and recall translate into real-world applications</title><p id="P53">To demonstrate our approach in a more practical setting, we generated a pan-genome De Bruijn graph containing 51,283 assembled virus genome sequences collected from GenBank [<xref ref-type="bibr" rid="R35">35</xref>]. Graph construction was performed using the <italic>MetaGraph</italic> framework, utilizing a <italic>k</italic> of 80. The resulting graph contained 337,480,265 nodes. Similar to previous evaluations, we generated 500 query sequences by sampling random walks of length 330 from the graph, subsequently applying random mutations at rates ranging from 5 to 25 percent. Confirming our previous observations on scalability, the sketching-based approach was able to outperform both the MG-A<sc>LIGN</sc> as well as the GA approaches, starting from mutation rates of 10% and 15%, respectively (<xref ref-type="fig" rid="F7">Figure 7</xref>). Notably, for the highest mutation rate, MG-SKETCH almost doubles the recall when compared to the next best approach.</p></sec></sec><sec id="S23" sec-type="conclusions"><label>4</label><title>Conclusion</title><p id="P54">This work’s main contribution is the introduction of a sketch-based long seed-finding approach that is robust to mutations. We provide a theoretical analysis and demonstrate empirically that our method scales to graphs on the order of 10<sup>9</sup>nodes. While MG-A<sc>LIGN</sc> and MG-SKETCH share the same extension algorithm, the sketch-based seeds improve alignment recall by a substantial margin in high mutation rate (&gt; 15%) regimes.</p><p id="P55">While sketching into vector spaces has been successfully applied in <italic>compressive sensing</italic> [<xref ref-type="bibr" rid="R7">7</xref>,<xref ref-type="bibr" rid="R11">11</xref>], to the best of our knowledge, this is the first work to show that such sketching into vector spaces can lead to improvements in accuracy and scale to genomics-sized datasets. With vector operations, there is a higher gain to be made on systems with specialized hardware, particularly GPUs. In fact, our CUDA-optimized TENSOR SKETCHING implementation is over 200× faster than the single-threaded CPU implementation [<xref ref-type="bibr" rid="R17">17</xref>]. Therefore, by employing the CUDA-optimized implementations of FAISS and TENSOR SKETCHING, we can benefit from massive data parallelism on GPUs.</p><p id="P56">In stark contrast to state-of-the-art tools, our method’s distinguishing feature is that it is a randomized algorithm. At the heart of MG-SKETCH is a randomized sketching scheme, which upon running several times independently can boost the recall of the method. This property enables us to prove theoretical guarantees in <xref ref-type="sec" rid="S12">Lemma 1</xref>, despite the method’s conceptual simplicity. Further exploration on the guarantees can bring new insights, such as a probabilistic bound on the deviations for TENSOR SKETCHING, as well as covering indels in the analysis.</p><p id="P57">There are several aspects that can be improved, but we considered them out the scope of this work. Notably, we have not applied any seed filtering approaches, such as co-linear chaining [<xref ref-type="bibr" rid="R32">32</xref>,<xref ref-type="bibr" rid="R8">8</xref>,<xref ref-type="bibr" rid="R25">25</xref>,<xref ref-type="bibr" rid="R1">1</xref>,<xref ref-type="bibr" rid="R29">29</xref>]. Furthermore, other sub-sampling strategies for indexing, such as spaced-minimized sub-sampling [<xref ref-type="bibr" rid="R14">14</xref>,<xref ref-type="bibr" rid="R38">38</xref>], can improve alignment time per query. In conclusion, MG-SKETCH takes a novel approach to alignment with promising empirical and theoretical properties. It is also conceptually simple and modular, such that it can be utilized in many other tools. Therefore, it opens up many new interesting areas of research for tackling computational challenges in bioinformatics.</p></sec><sec sec-type="supplementary-material" id="SM"><title>Supplementary Material</title><supplementary-material content-type="local-data" id="SD1"><label>Supplemental Material</label><media xlink:href="EMS156298-supplement-Supplemental_Material.pdf" mimetype="application" mime-subtype="pdf" id="d23aAdEbB" position="anchor"/></supplementary-material></sec></body><back><ack id="S24"><title>Acknowledgements</title><p>A. J. is funded through Swiss National Science Foundation Project Grant #200550 to A. K. H. M. is funded as part of Swiss National Research Programme (NRP) 75 “Big Data” by the SNSF grant #407540_167331. A. J., H. M., and A. K. are also partially funded by ETH core funding (to G. R.). R.G. was funded through an ETH Research Grant (# ETH-17 21-1) to G.R.</p></ack><fn-group><fn id="FN1" fn-type="conflict"><p id="P58">We declare no conflicts of interest.</p></fn></fn-group><ref-list><ref id="R1"><label>1</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Almodaresi</surname><given-names>F</given-names></name><name><surname>Zakeri</surname><given-names>M</given-names></name><name><surname>Patro</surname><given-names>R</given-names></name></person-group><article-title>PuffAligner: a fast, efficient and accurate aligner based on the Pufferfish index</article-title><source>Bioinformatics</source><year>2021</year><volume>37</volume><issue>22</issue><fpage>4048</fpage><lpage>4055</lpage><pub-id pub-id-type="pmcid">PMC9502150</pub-id><pub-id pub-id-type="pmid">34117875</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btab408</pub-id></element-citation></ref><ref id="R2"><label>2</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Altschul</surname><given-names>SF</given-names></name><name><surname>Gish</surname><given-names>W</given-names></name><name><surname>Miller</surname><given-names>W</given-names></name><name><surname>Myers</surname><given-names>EW</given-names></name><name><surname>Lipman</surname><given-names>DJ</given-names></name></person-group><article-title>Basic local alignment search tool</article-title><source>Journal of Molecular Biology</source><year>1990</year><volume>215</volume><issue>3</issue><fpage>403</fpage><lpage>410</lpage><comment>URL <ext-link ext-link-type="uri" xlink:href="https://www.sciencedirect.com/science/article/pii/S0022283605803602">https://www.sciencedirect.com/science/article/pii/S0022283605803602</ext-link></comment><pub-id pub-id-type="pmid">2231712</pub-id></element-citation></ref><ref id="R3"><label>3</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Belazzougui</surname><given-names>D</given-names></name><name><surname>Cunial</surname><given-names>F</given-names></name></person-group><source>Fully-Functional Bidirectional Burrows-Wheeler Indexes and Infinite-Order De Bruijn Graphs</source><person-group person-group-type="editor"><name><surname>Pisanti</surname><given-names>N</given-names></name><name><surname>Pissis</surname><given-names>SP</given-names></name></person-group><conf-name>30th Annual Symposium on Combinatorial Pattern Matching (CPM 2019), Leibniz International Proceedings in Informatics (LIPIcs)</conf-name><conf-sponsor>Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, Dagstuhl</conf-sponsor><conf-loc>Germany</conf-loc><year>2019</year><volume>128</volume><fpage>10:1</fpage><lpage>10:15</lpage><comment>URL <ext-link ext-link-type="uri" xlink:href="http://drops.dagstuhl.de/opus/volltexte/2019/10481">http://drops.dagstuhl.de/opus/volltexte/2019/10481</ext-link></comment><pub-id pub-id-type="doi">10.4230/LIPIcs.CPM.2019.10</pub-id></element-citation></ref><ref id="R4"><label>4</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Boucher</surname><given-names>C</given-names></name><name><surname>Bowe</surname><given-names>A</given-names></name><name><surname>Gagie</surname><given-names>T</given-names></name><name><surname>Puglisi</surname><given-names>SJ</given-names></name><name><surname>Sadakane</surname><given-names>K</given-names></name></person-group><source>Variable-order de bruijn graphs</source><conf-name>2015 Data Compression Conference</conf-name><year>2015</year><fpage>383</fpage><lpage>392</lpage><pub-id pub-id-type="doi">10.1109/DCC.2015.70</pub-id></element-citation></ref><ref id="R5"><label>5</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Bowe</surname><given-names>A</given-names></name><name><surname>Onodera</surname><given-names>T</given-names></name><name><surname>Sadakane</surname><given-names>K</given-names></name><name><surname>Shibuya</surname><given-names>T</given-names></name></person-group><source>Succinct de bruijn graphs</source><conf-name>International workshop on algorithms in bioinformatics</conf-name><conf-sponsor>Springer</conf-sponsor><year>2012</year><fpage>225</fpage><lpage>235</lpage></element-citation></ref><ref id="R6"><label>6</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Břinda</surname><given-names>K</given-names></name><name><surname>Sykulski</surname><given-names>M</given-names></name><name><surname>Kucherov</surname><given-names>G</given-names></name></person-group><article-title>Spaced seeds improve <italic>k</italic>-mer-based metagenomic classification</article-title><source>Bioinformatics</source><year>2015</year><volume>31</volume><issue>22</issue><fpage>3584</fpage><lpage>3592</lpage><pub-id pub-id-type="pmid">26209798</pub-id></element-citation></ref><ref id="R7"><label>7</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Candes</surname><given-names>EJ</given-names></name><name><surname>Romberg</surname><given-names>J</given-names></name><name><surname>Tao</surname><given-names>T</given-names></name></person-group><article-title>Robust uncertainty principles: Exact signal reconstruction from highly incomplete frequency information</article-title><source>IEEE Transactions on information theory</source><year>2006</year><volume>52</volume><issue>2</issue><fpage>489</fpage><lpage>509</lpage></element-citation></ref><ref id="R8"><label>8</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chandra</surname><given-names>G</given-names></name><name><surname>Jain</surname><given-names>C</given-names></name></person-group><article-title>Sequence to graph alignment using gap-sensitive co-linear chaining</article-title><source>bioRxiv</source><year>2022</year><comment>URL <ext-link ext-link-type="uri" xlink:href="https://www.biorxiv.org/content/early/2022/09/01/2022.08.29.505691">https://www.biorxiv.org/content/early/2022/09/01/2022.08.29.505691</ext-link></comment><pub-id pub-id-type="doi">10.1101/2022.08.29.505691</pub-id></element-citation></ref><ref id="R9"><label>9</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chang</surname><given-names>X</given-names></name><name><surname>Eizenga</surname><given-names>J</given-names></name><name><surname>Novak</surname><given-names>AM</given-names></name><name><surname>Siren</surname><given-names>J</given-names></name><name><surname>Paten</surname><given-names>B</given-names></name></person-group><article-title>Distance indexing and seed clustering in sequence graphs</article-title><source>Bioinformatics</source><year>2020</year><volume>36</volume><issue>Supplement_1</issue><fpage>i146</fpage><lpage>i153</lpage><pub-id pub-id-type="pmcid">PMC7355256</pub-id><pub-id pub-id-type="pmid">32657356</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btaa446</pub-id></element-citation></ref><ref id="R10"><label>10</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Datar</surname><given-names>M</given-names></name><name><surname>Immorlica</surname><given-names>N</given-names></name><name><surname>Indyk</surname><given-names>P</given-names></name><name><surname>Mirrokni</surname><given-names>VS</given-names></name></person-group><source>Locality-sensitive hashing scheme based on p-stable distributions</source><conf-name>Proceedings of the twentieth annual symposium on Computational geometry</conf-name><year>2004</year><fpage>253</fpage><lpage>262</lpage></element-citation></ref><ref id="R11"><label>11</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Donoho</surname><given-names>DL</given-names></name></person-group><article-title>Compressed sensing</article-title><source>IEEE Transactions on information theory</source><year>2006</year><volume>52</volume><issue>4</issue><fpage>1289</fpage><lpage>1306</lpage></element-citation></ref><ref id="R12"><label>12</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Duarte</surname><given-names>R</given-names></name><name><surname>de Oliveira</surname><given-names>AG</given-names></name></person-group><article-title>New developments of an old identity</article-title><year>2012</year><comment>URL <ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/1203.5424">https://arxiv.org/abs/1203.5424</ext-link></comment><pub-id pub-id-type="doi">10.48550/ARXIV.1203.5424</pub-id></element-citation></ref><ref id="R13"><label>13</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Eizenga</surname><given-names>JM</given-names></name><name><surname>Lorig-Roach</surname><given-names>R</given-names></name><name><surname>Meredith</surname><given-names>MM</given-names></name><name><surname>Paten</surname><given-names>B</given-names></name></person-group><chapter-title>Walk-preserving transformation of overlapped sequence graphs into blunt sequence graphs with getblunted</chapter-title><person-group person-group-type="editor"><name><surname>De Mol</surname><given-names>L</given-names></name><name><surname>Weiermann</surname><given-names>A</given-names></name><name><surname>Manea</surname><given-names>F</given-names></name><name><surname>Fernandez-Duque</surname><given-names>D</given-names></name></person-group><source>Connecting with Computability</source><publisher-name>Springer International Publishing</publisher-name><publisher-loc>Cham</publisher-loc><year>2021</year><fpage>169</fpage><lpage>177</lpage></element-citation></ref><ref id="R14"><label>14</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ekim</surname><given-names>B</given-names></name><name><surname>Berger</surname><given-names>B</given-names></name><name><surname>Chikhi</surname><given-names>R</given-names></name></person-group><article-title>Minimizer-space de bruijn graphs: Whole-genome assembly of long reads in minutes on a personal computer</article-title><source>Cell systems</source><year>2021</year><volume>12</volume><issue>10</issue><fpage>958</fpage><lpage>968</lpage><pub-id pub-id-type="pmcid">PMC8562525</pub-id><pub-id pub-id-type="pmid">34525345</pub-id><pub-id pub-id-type="doi">10.1016/j.cels.2021.08.009</pub-id></element-citation></ref><ref id="R15"><label>15</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Garrison</surname><given-names>E</given-names></name><name><surname>Siren</surname><given-names>J</given-names></name><name><surname>Novak</surname><given-names>AM</given-names></name><name><surname>Hickey</surname><given-names>G</given-names></name><name><surname>Eizenga</surname><given-names>JM</given-names></name><name><surname>Dawson</surname><given-names>ET</given-names></name><name><surname>Jones</surname><given-names>W</given-names></name><name><surname>Garg</surname><given-names>S</given-names></name><name><surname>Markello</surname><given-names>C</given-names></name><name><surname>Lin</surname><given-names>MF</given-names></name><etal/></person-group><article-title>Variation graph toolkit improves read mapping by representing genetic variation in the reference</article-title><source>Nature biotechnology</source><year>2018</year><volume>36</volume><issue>9</issue><fpage>875</fpage><lpage>879</lpage><pub-id pub-id-type="pmcid">PMC6126949</pub-id><pub-id pub-id-type="pmid">30125266</pub-id><pub-id pub-id-type="doi">10.1038/nbt.4227</pub-id></element-citation></ref><ref id="R16"><label>16</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Gibney</surname><given-names>D</given-names></name><name><surname>Thankachan</surname><given-names>SV</given-names></name><name><surname>Aluru</surname><given-names>S</given-names></name></person-group><chapter-title>The complexity of approximate pattern matching on de bruijn graphs</chapter-title><person-group person-group-type="author"><name><surname>Pe’er</surname><given-names>I</given-names></name></person-group><source>Research in Computational Molecular Biology</source><publisher-name>Springer International Publishing</publisher-name><publisher-loc>Cham</publisher-loc><year>2022</year><fpage>263</fpage><lpage>278</lpage></element-citation></ref><ref id="R17"><label>17</label><element-citation publication-type="web"><person-group person-group-type="author"><name><surname>Groot Koerkamp</surname><given-names>R</given-names></name></person-group><source>28000x speedup with numba</source><source>cuda</source><year>2021</year><comment>URL <ext-link ext-link-type="uri" xlink:href="https://curiouscoding.nl/phd/2021/03/24/numba-cuda-speedup/">https://curiouscoding.nl/phd/2021/03/24/numba-cuda-speedup/</ext-link></comment></element-citation></ref><ref id="R18"><label>18</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hickey</surname><given-names>G</given-names></name><name><surname>Heller</surname><given-names>D</given-names></name><name><surname>Monlong</surname><given-names>J</given-names></name><name><surname>Sibbesen</surname><given-names>JA</given-names></name><name><surname>Siren</surname><given-names>J</given-names></name><name><surname>Eizenga</surname><given-names>J</given-names></name><name><surname>Dawson</surname><given-names>ET</given-names></name><name><surname>Garrison</surname><given-names>E</given-names></name><name><surname>Novak</surname><given-names>AM</given-names></name><name><surname>Paten</surname><given-names>B</given-names></name></person-group><article-title>Genotyping structural variants in pangenome graphs using the vg toolkit</article-title><source>Genome biology</source><year>2020</year><volume>21</volume><issue>1</issue><fpage>1</fpage><lpage>17</lpage><pub-id pub-id-type="pmcid">PMC7017486</pub-id><pub-id pub-id-type="pmid">32051000</pub-id><pub-id pub-id-type="doi">10.1186/s13059-020-1941-7</pub-id></element-citation></ref><ref id="R19"><label>19</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Indyk</surname><given-names>P</given-names></name><name><surname>Motwani</surname><given-names>R</given-names></name></person-group><source>Approximate nearest neighbors: towards removing the curse of dimensionality</source><conf-name>Proceedings of the thirtieth annual ACM symposium on Theory of computing</conf-name><year>1998</year><fpage>604</fpage><lpage>613</lpage></element-citation></ref><ref id="R20"><label>20</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jain</surname><given-names>C</given-names></name><name><surname>Zhang</surname><given-names>H</given-names></name><name><surname>Gao</surname><given-names>Y</given-names></name><name><surname>Aluru</surname><given-names>S</given-names></name></person-group><article-title>On the complexity of sequence-to-graph alignment</article-title><source>Journal of Computational Biology</source><year>2020</year><volume>27</volume><issue>4</issue><fpage>640</fpage><lpage>654</lpage><pub-id pub-id-type="doi">10.1089/cmb.2019.0066</pub-id></element-citation></ref><ref id="R21"><label>21</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jensen</surname><given-names>JLWV</given-names></name></person-group><article-title>Sur une identite d’abel et sur d’autres formules analogues</article-title><source>Acta Mathematica</source><year>1902</year><volume>26</volume><fpage>307</fpage><lpage>318</lpage><comment>0</comment><pub-id pub-id-type="doi">10.1007/bf02415499</pub-id></element-citation></ref><ref id="R22"><label>22</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Johnson</surname><given-names>J</given-names></name><name><surname>Douze</surname><given-names>M</given-names></name><name><surname>Jeegou</surname><given-names>H</given-names></name></person-group><article-title>Billion-scale similarity search with GPUs</article-title><source>IEEE Transactions on Big Data</source><year>2019</year><volume>7</volume><issue>3</issue><fpage>535</fpage><lpage>547</lpage></element-citation></ref><ref id="R23"><label>23</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Joudaki</surname><given-names>A</given-names></name><name><surname>Rätsch</surname><given-names>G</given-names></name><name><surname>Kahles</surname><given-names>A</given-names></name></person-group><article-title>Fast alignment-free similarity estimation by tensor sketching</article-title><source>bioRxiv</source><year>2021</year><fpage>2020</fpage><lpage>11</lpage></element-citation></ref><ref id="R24"><label>24</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Karasikov</surname><given-names>M</given-names></name><name><surname>Mustafa</surname><given-names>H</given-names></name><name><surname>Danciu</surname><given-names>D</given-names></name><name><surname>Zimmermann</surname><given-names>M</given-names></name><name><surname>Barber</surname><given-names>C</given-names></name><name><surname>Räatsch</surname><given-names>G</given-names></name><name><surname>Kahles</surname><given-names>A</given-names></name></person-group><article-title>Metagraph: Indexing and analysing nucleotide archives at petabase-scale</article-title><source>BioRxiv</source><year>2020</year></element-citation></ref><ref id="R25"><label>25</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Karasikov</surname><given-names>M</given-names></name><name><surname>Mustafa</surname><given-names>H</given-names></name><name><surname>Räatsch</surname><given-names>G</given-names></name><name><surname>Kahles</surname><given-names>A</given-names></name></person-group><article-title>Lossless indexing with counting de bruijn graphs</article-title><source>Genome Research</source><year>2022</year><comment>URL <ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/content/early/2022/05/23/gr.276607.122.abstract">http://genome.cshlp.org/content/early/2022/05/23/gr.276607.122.abstract</ext-link></comment><pub-id pub-id-type="pmcid">PMC9528980</pub-id><pub-id pub-id-type="pmid">35609994</pub-id><pub-id pub-id-type="doi">10.1101/gr.276607.122</pub-id></element-citation></ref><ref id="R26"><label>26</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Khiste</surname><given-names>N</given-names></name><name><surname>Ilie</surname><given-names>L</given-names></name></person-group><article-title>E-mem: efficient computation of maximal exact matches for very large genomes</article-title><source>Bioinformatics</source><year>2015</year><volume>31</volume><issue>4</issue><fpage>509</fpage><lpage>514</lpage><pub-id pub-id-type="pmid">25399029</pub-id></element-citation></ref><ref id="R27"><label>27</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Koppen</surname><given-names>M</given-names></name></person-group><source>The curse of dimensionality</source><conf-name>5th online world conference on soft computing in industrial applications (WSC5)</conf-name><year>2000</year><volume>1</volume><fpage>4</fpage><lpage>8</lpage></element-citation></ref><ref id="R28"><label>28</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H</given-names></name></person-group><article-title>Aligning sequence reads, clone sequences and assembly contigs with bwa-mem</article-title><source>arXiv preprint</source><year>2013</year><elocation-id>arXiv:1303.3997</elocation-id></element-citation></ref><ref id="R29"><label>29</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H</given-names></name><name><surname>Feng</surname><given-names>X</given-names></name><name><surname>Chu</surname><given-names>C</given-names></name></person-group><article-title>The design and construction of reference pangenome graphs with minigraph</article-title><source>Genome Biology</source><year>2020</year><volume>21</volume><issue>1</issue><elocation-id>265</elocation-id><pub-id pub-id-type="pmcid">PMC7568353</pub-id><pub-id pub-id-type="pmid">33066802</pub-id><pub-id pub-id-type="doi">10.1186/s13059-020-02168-z</pub-id></element-citation></ref><ref id="R30"><label>30</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Limasset</surname><given-names>A</given-names></name><name><surname>Cazaux</surname><given-names>B</given-names></name><name><surname>Rivals</surname><given-names>E</given-names></name><name><surname>Peterlongo</surname><given-names>P</given-names></name></person-group><article-title>Read mapping on de bruijn graphs</article-title><source>BMC bioinformatics</source><year>2016</year><volume>17</volume><issue>1</issue><fpage>1</fpage><lpage>12</lpage><pub-id pub-id-type="pmcid">PMC4910249</pub-id><pub-id pub-id-type="pmid">27306641</pub-id><pub-id pub-id-type="doi">10.1186/s12859-016-1103-9</pub-id></element-citation></ref><ref id="R31"><label>31</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>B</given-names></name><name><surname>Guo</surname><given-names>H</given-names></name><name><surname>Brudno</surname><given-names>M</given-names></name><name><surname>Wang</surname><given-names>Y</given-names></name></person-group><article-title>debga: read alignment with de bruijn graph-based seed and extension</article-title><source>Bioinformatics</source><year>2016</year><volume>32</volume><issue>21</issue><fpage>3224</fpage><lpage>3232</lpage><pub-id pub-id-type="pmid">27378303</pub-id></element-citation></ref><ref id="R32"><label>32</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ma</surname><given-names>J</given-names></name><name><surname>Caceres</surname><given-names>M</given-names></name><name><surname>Salmela</surname><given-names>L</given-names></name><name><surname>Makinen</surname><given-names>V</given-names></name><name><surname>Tomescu</surname><given-names>AI</given-names></name></person-group><article-title>Chaining for accurate alignment of erroneous long reads to acyclic variation graphs</article-title><source>bioRxiv</source><year>2022</year><comment>URL <ext-link ext-link-type="uri" xlink:href="https://www.biorxiv.org/content/early/2022/05/19/2022.01.07.475257">https://www.biorxiv.org/content/early/2022/05/19/2022.01.07.475257</ext-link></comment><pub-id pub-id-type="doi">10.1101/2022.01.07.475257</pub-id></element-citation></ref><ref id="R33"><label>33</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mak</surname><given-names>D</given-names></name><name><surname>Gelfand</surname><given-names>Y</given-names></name><name><surname>Benson</surname><given-names>G</given-names></name></person-group><article-title>Indel seeds for homology search</article-title><source>Bioinformatics</source><year>2006</year><volume>22</volume><issue>14</issue><fpage>e341</fpage><lpage>e349</lpage><pub-id pub-id-type="pmid">16873491</pub-id></element-citation></ref><ref id="R34"><label>34</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Malkov</surname><given-names>YA</given-names></name><name><surname>Yashunin</surname><given-names>DA</given-names></name></person-group><article-title>Efficient and robust approximate nearest neighbor search using hierarchical navigable small world graphs</article-title><source>IEEE transactions on pattern analysis and machine intelligence</source><year>2018</year><volume>42</volume><issue>4</issue><fpage>824</fpage><lpage>836</lpage><pub-id pub-id-type="pmid">30602420</pub-id></element-citation></ref><ref id="R35"><label>35</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mustafa</surname><given-names>H</given-names></name><name><surname>Schilken</surname><given-names>I</given-names></name><name><surname>Karasikov</surname><given-names>M</given-names></name><name><surname>Eickhoff</surname><given-names>C</given-names></name><name><surname>Rätsch</surname><given-names>G</given-names></name><name><surname>Kahles</surname><given-names>A</given-names></name></person-group><article-title>Dynamic compression schemes for graph coloring</article-title><source>Bioinformatics</source><year>2018</year><volume>35</volume><issue>3</issue><fpage>407</fpage><lpage>414</lpage><pub-id pub-id-type="pmcid">PMC6530811</pub-id><pub-id pub-id-type="pmid">30020403</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/bty632</pub-id></element-citation></ref><ref id="R36"><label>36</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Pham</surname><given-names>N</given-names></name><name><surname>Pagh</surname><given-names>R</given-names></name></person-group><source>Fast and scalable polynomial kernels via explicit feature maps</source><conf-name>Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining</conf-name><year>2013</year><fpage>239</fpage><lpage>247</lpage></element-citation></ref><ref id="R37"><label>37</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rautiainen</surname><given-names>M</given-names></name><name><surname>Marschall</surname><given-names>T</given-names></name></person-group><article-title>Graphaligner: rapid and versatile sequence-to-graph alignment</article-title><source>Genome biology</source><year>2020</year><volume>21</volume><issue>1</issue><fpage>1</fpage><lpage>28</lpage><pub-id pub-id-type="pmcid">PMC7513500</pub-id><pub-id pub-id-type="pmid">32972461</pub-id><pub-id pub-id-type="doi">10.1186/s13059-020-02157-2</pub-id></element-citation></ref><ref id="R38"><label>38</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Roberts</surname><given-names>M</given-names></name><name><surname>Hayes</surname><given-names>W</given-names></name><name><surname>Hunt</surname><given-names>BR</given-names></name><name><surname>Mount</surname><given-names>SM</given-names></name><name><surname>Yorke</surname><given-names>JA</given-names></name></person-group><article-title>Reducing storage requirements for biological sequence comparison</article-title><source>Bioinformatics</source><year>2004</year><volume>20</volume><issue>18</issue><fpage>3363</fpage><lpage>3369</lpage><pub-id pub-id-type="pmid">15256412</pub-id></element-citation></ref><ref id="R39"><label>39</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sibbesen</surname><given-names>JA</given-names></name><name><surname>Eizenga</surname><given-names>JM</given-names></name><name><surname>Novak</surname><given-names>AM</given-names></name><name><surname>Siren</surname><given-names>J</given-names></name><name><surname>Chang</surname><given-names>X</given-names></name><name><surname>Garrison</surname><given-names>E</given-names></name><name><surname>Paten</surname><given-names>B</given-names></name></person-group><article-title>Haplotype-aware pantranscriptome analyses using spliced pangenome graphs</article-title><source>BioRxiv</source><year>2022</year><fpage>2021</fpage><lpage>03</lpage></element-citation></ref><ref id="R40"><label>40</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Siren</surname><given-names>J</given-names></name></person-group><source>Indexing variation graphs</source><conf-name>2017 Proceedings of the ninteenth workshop on algorithm engineering and experiments (ALENEX)</conf-name><conf-sponsor>SIAM</conf-sponsor><year>2017</year><fpage>13</fpage><lpage>27</lpage></element-citation></ref><ref id="R41"><label>41</label><element-citation publication-type="other"><source>ΛEBEHMτE⊓H, B.H.: %BOπUHŁIE KOFLBI C NCπPABΛEH⊓EM BM⊓AFLE≡πĚ, βCτAβOκ π 3AMERNYH⊓π CHMBOλOB. %OKλ AH CCCP</source><year>1965</year><volume>163</volume><issue>4</issue><fpage>845</fpage><lpage>848</lpage><comment>URL <ext-link ext-link-type="uri" xlink:href="http://mi.mathnet.ru/dan31411">http://mi.mathnet.ru/dan31411</ext-link></comment></element-citation></ref></ref-list></back><floats-group><fig id="F1" position="float"><label>Fig. 1</label><caption><p>The full sequence-to-graph alignment of one query sequence using MG-S<sc>KETCH</sc> consists of several steps: i) Sketching the spell of every graph node in the kmer-cover of the DBG and storing the sketches in a hierarchical searchable index, mapping from sketch vector to node, ii) For every <italic>k</italic>-mer in the query (magenta), find the nearest neighbors with the smallest sketch <italic>L</italic><sup>2</sup>-distance (green) stored in the index, iii) Seed an alignment at every node returned in the previous step and iv) Extend forwards and backwards from each seed, finding the path in the graph that maximizes the alignment score of the query.</p></caption><graphic xlink:href="EMS156298-f001"/></fig><fig id="F2" position="float"><label>Fig. 2</label><caption><p>Tensor Embedding illustration for <italic>t</italic> = 2. Observe that the substitution, insertion, and deletion, correspond to blocks of non-zero elements in the difference tensor</p></caption><graphic xlink:href="EMS156298-f002"/></fig><fig id="F3" position="float"><label>Fig. 3</label><caption><p>(left) Tensor Embedding vs. Hamming Distance: Dashed line represents the closed-form expectation according to the <xref ref-type="sec" rid="S12">Lemma 1</xref> with <italic>t</italic> = 3, <italic>n</italic> = 1000, which is almost overlapping with the empirical average represented by the solid line. The solid line shows the mean tensor embedding distance with <italic>t</italic> = 3, averaged over 2000 sequence pairs of length 1000, at normalized Hamming distances ranging from 0 to 1. (right) Tensor Sketching vs. Hamming Distance: Average tensor sketch distance on the same dataset used for tensor embedding distances, with the solid line showing the average sketch distance with <italic>t</italic> = 3 and <italic>D</italic> = 8, 16, 32, 64. The sketch distance is normalized such that it is equal to 1 for Hamming distance 1. Shaded regions represent the standard deviation of the sketch distance for <italic>D</italic> = 8, 16, 32, 64, with the lightest shade corresponding to <italic>D</italic> = 8. (right).</p></caption><graphic xlink:href="EMS156298-f003"/></fig><fig id="F4" position="float"><label>Fig. 4</label><caption><p>Recall achieved across different mutation rates with increasing graph sizes for each baseline. The number of nodes in the graph for each plot is 100K (A), 10M (B), 100M (C) and 1B (D). Values are measured on the De Bruijn graph generated by M<sc>ETAGRAPH</sc>. We run MG-S<sc>KETCH</sc> with <italic>K</italic> = 40 neighbors and <italic>D</italic> = 14,<italic>w</italic> = 16,<italic>s</italic> = 8,<italic>t</italic> = 6. Query generation follows the same approach as explained in <xref ref-type="sec" rid="S17">Section 3.1</xref>.</p></caption><graphic xlink:href="EMS156298-f004"/></fig><fig id="F5" position="float"><label>Fig. 5</label><caption><p>Recall achieved across different mutation rates with increasing graph sizes for MG-SKETCH (left) and MG-A<sc>LIGN</sc> (right). We run MG-S<sc>KETCH</sc> with <italic>t</italic> = 6, <italic>w</italic> = 16, <italic>s</italic> = 8, <italic>D</italic> = 14, and <italic>K</italic> = 40 neighbors. Query generation follows the same approach as explained in <xref ref-type="sec" rid="S17">Section 3.1</xref>. We omit 0% and 5% mutation rate, as both methods achieve an almost perfect recall.</p></caption><graphic xlink:href="EMS156298-f005"/></fig><fig id="F6" position="float"><label>Fig. 6</label><caption><p>Peak RAM usage and query time vs. graph size. Graphs are generated with <italic>k</italic> = 80 according to <xref ref-type="sec" rid="S17">Section 3.1</xref>. We run MG-S<sc>KETCH</sc> with <italic>t</italic> = 6, <italic>D</italic> = 14, <italic>w</italic> = 16, <italic>s</italic> = 8 and <italic>k</italic> =10 neighbors. Traces for <sc>VG MPMAP</sc> and <sc>VG MAP</sc> are incomplete as they exceed time or memory limit. (left) Peak RAM usage vs. graph size. (right) Average alignment time vs. graph size. For recall comparisons see <xref ref-type="fig" rid="F4">Figure 4</xref>.</p></caption><graphic xlink:href="EMS156298-f006"/></fig><fig id="F7" position="float"><label>Fig. 7</label><caption><p>Seeding recall for the GenBank viral graph. Recall is shown for MG-S<sc>KETCH</sc>, MG-A<sc>LIGN</sc>, and GA as purple, pink, and orange lines, respectively, for query sets of increasing distance, simulated with a random mutation rate ranging from 0% to 25%</p></caption><graphic xlink:href="EMS156298-f007"/></fig></floats-group></article>