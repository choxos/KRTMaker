<!DOCTYPE article
 PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2 20190208//EN" "JATS-archivearticle1.dtd">
<article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="preprint"><?all-math-mml yes?><?use-mml?><?origin ukpmcpa?><front><journal-meta><journal-id journal-id-type="nlm-ta">bioRxiv</journal-id><journal-title-group><journal-title>bioRxiv : the preprint server for biology</journal-title></journal-title-group><issn pub-type="ppub"/></journal-meta><article-meta><article-id pub-id-type="manuscript">EMS179827</article-id><article-id pub-id-type="doi">10.1101/2022.10.18.512733</article-id><article-id pub-id-type="archive">PPR563350</article-id><article-version-alternatives><article-version article-version-type="status">preprint</article-version><article-version article-version-type="number">3</article-version></article-version-alternatives><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group><subj-group subj-group-type="europepmc-category"><subject>Covid-19</subject></subj-group></article-categories><title-group><article-title>Mora: abundance aware metagenomic read re-assignment for disentangling similar strains</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Zheng</surname><given-names>Andrew</given-names></name><xref ref-type="aff" rid="A1">1</xref><email>andrewf.zheng@mail.utoronto.ca</email></contrib><contrib contrib-type="author"><name><surname>Shaw</surname><given-names>Jim</given-names></name><xref ref-type="aff" rid="A1">1</xref><xref ref-type="corresp" rid="CR1">*</xref></contrib><contrib contrib-type="author"><name><surname>Yu</surname><given-names>Yun William</given-names></name><xref ref-type="aff" rid="A1">1</xref><xref ref-type="aff" rid="A2">2</xref><xref ref-type="corresp" rid="CR1">*</xref></contrib></contrib-group><aff id="A1"><label>1</label>Mathematics, University of Toronto, 27 King’s College Circle, Toronto, M3R 0A3, Ontario, Canada</aff><aff id="A2"><label>2</label>Computer and Mathematical Sciences, University of Toronto at Scarborough, 1265 Military Trail, Toronto, M1C 1A4, Ontario, Canada</aff><author-notes><corresp id="CR1">
<label>*</label>Corresponding author(s). <email>jshaw@math.toronto.edu</email>; <email>ywyu@math.toronto.edu</email></corresp></author-notes><pub-date pub-type="nihms-submitted"><day>15</day><month>07</month><year>2023</year></pub-date><pub-date pub-type="preprint"><day>11</day><month>07</month><year>2023</year></pub-date><permissions><ali:free_to_read/><license><ali:license_ref>https://creativecommons.org/licenses/by-nc-nd/4.0/</ali:license_ref><license-p>This work is licensed under a <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0 International license</ext-link>.</license-p></license></permissions><abstract><sec id="S1"><title>Background</title><p id="P1">Taxonomic classification of reads obtained by metagenomic sequencing is often a first step for understanding a microbial community, but correctly assigning sequencing reads to the strain or sub-species level has remained a challenging computational problem.</p></sec><sec id="S2"><title>Results</title><p id="P2">We introduce Mora, a MetagenOmic read Re-Assignment algorithm capable of assigning short and long metagenomic reads with high precision, even at the strain level. Mora is able to accurately re-assign reads by first estimating abundances through an expectation-maximization algorithm and then utilizing abundance information to re-assign query reads. The key idea behind Mora is to maximize read re-assignment qualities <italic>while simultaneously</italic> minimizing the difference from estimated abundance levels, allowing Mora to avoid over assigning reads to the same genomes. On simulated diverse reads, this allows Mora to achieve F1 scores comparable to other algorithms while having less runtime. However, Mora significantly outshines other algorithms on very similar reads. We show that the high penalty of over assigning reads to a common reference genome allows Mora to accurately infer correct strains for real data in the form of short E. coli reads and long Covid-19 reads.</p></sec><sec id="S3"><title>Conclusions</title><p id="P3">Mora is a fast and accurate read re-assignment algorithm that is modularized, allowing it to be incorporated into general metagenomics and genomics workflows. It is freely available at <ext-link ext-link-type="uri" xlink:href="https://github.com/AfZheng126/MORA">https://github.com/AfZheng126/MORA</ext-link>.</p></sec></abstract><kwd-group><title>Keywords</title><kwd>Metagenomics</kwd><kwd>Read Re-Assignment</kwd><kwd>Abundance Quantification</kwd></kwd-group></article-meta></front><body><sec id="S4" sec-type="intro"><label>1</label><title>Background</title><p id="P4">When analyzing microbial communities through metagenomic sequencing, a fundamental task is to determine which reference genome a specific sequencing read originates from [<xref ref-type="bibr" rid="R1">1</xref>]. This gives information about microbial composition and allows for mapping-based analysis of genetic variation. A common first step in a processing pipeline is to use a fast taxonomic read classifier such as Kraken2 [<xref ref-type="bibr" rid="R2">2</xref>], CLARK [<xref ref-type="bibr" rid="R3">3</xref>], Centrifuge [<xref ref-type="bibr" rid="R4">4</xref>] or others. While such methods are extremely fast, they are not sensitive enough to assign reads to the strain level. Since strain-level resolution has important functional implications [<xref ref-type="bibr" rid="R5">5</xref>–<xref ref-type="bibr" rid="R7">7</xref>], sensitive methods that are able to resolve reads at the strain level are needed.</p><p id="P5">To resolve reads at the level of strains, a naive approach would be to more sensitively align the read to a set of candidate reference genomes using a read aligner such as Bowtie2 [<xref ref-type="bibr" rid="R8">8</xref>], Minimap2 [<xref ref-type="bibr" rid="R9">9</xref>], or CORA [<xref ref-type="bibr" rid="R10">10</xref>] (no relation to Mora) and then take the best reference genome as the correct assignment. However, strain-level reference genomes share large regions of similarity, so many ambiguous mappings are inevitable. To overcome this limitation, one can statistically calculate abundance information of the candidate set of reference strains and only use references that have high enough abundances [<xref ref-type="bibr" rid="R11">11</xref>–<xref ref-type="bibr" rid="R14">14</xref>]. Afterwards, one can re-assign reads to the “correct” references, i.e. reference strains that seem to be abundant in the metagenomic sample.</p><p id="P6">However, re-assigning reads to the correct references while maintaining abundance estimates is non-trivial. For example, if one were to assign a multi-mapped read to the most abundant reference strain with a putative mapping, all reads coming from a region of similarity between two strains will be mapped to only one strain—in this case the most abundant one. This is not an accurate assignment of the reads and will skew the abundance. Importantly, not all algorithms do abundance estimation <italic>and</italic> read assignment; some algorithms calculate only abundances and do not output re-assigned reads [<xref ref-type="bibr" rid="R15">15</xref>–<xref ref-type="bibr" rid="R17">17</xref>].</p><p id="P7">In this paper, we present Mora, a tool that allows for sensitive yet efficient metage-nomic read re-assignment and abundance calculation at the strain level for both long and short reads. Given an alignment in SAM or BAM format and a set of reference strains, Mora calculates the abundance of each reference strain present in the sample and re-assigns the reads to the correct reference strain in a way such that abundance estimates are preserved. We rigorously formulate this problem as an optimization problem and give provable guarantees on our heuristic algorithm. We show that Mora is more effective than Pathoscope2 [<xref ref-type="bibr" rid="R12">12</xref>], a state-of-the-art read re-assigner, at disambiguating similar strains present in a sample on simulated data for short reads while being an order of magnitude faster. Furthermore, we show that Mora has similar if not better F1 scores compared to Pathoscope2, Kraken2, and Clark while taking less time and RAM on simulated long read data. We then verify our results on real long-read data as well.</p></sec><sec id="S5" sec-type="results | discussion"><label>2</label><title>Results and discussion</title><sec id="S6"><label>2.1</label><title>Pipeline of Mora</title><p id="P8">Mora’s pipeline consists of two main steps (<xref ref-type="fig" rid="F1">Figure 1</xref>): abundance estimation and read re-assignment. Like other metagenomic abundance estimators [<xref ref-type="bibr" rid="R17">17</xref>, <xref ref-type="bibr" rid="R18">18</xref>], it first utilizes a standard generative probabilistic model on input mappings and performs inference using the expectation maximization (EM) algorithm, augmented with a set cover algorithm to filter out spuriously abundant genomes [<xref ref-type="bibr" rid="R17">17</xref>]. Mora’s novelty comes from the subsequent step, where we re-assign reads in a manner <italic>dependent on the calculated abundances.</italic> Mora models the problem of maximizing correct read assignments while minimizing the difference between predicted abundance levels and final abundance levels as a non-linear minimization problem (<xref ref-type="sec" rid="S15">Section 3.3</xref> and <xref ref-type="fig" rid="F2">Figure 2</xref>). Although we use a greedy heuristic, we prove that heuristic is guaranteed to improve the minimization score. Finally, Mora outputs a (re-)assignment of each read to a reference genome that is consistent with the calculated abundances.</p></sec><sec id="S7"><label>2.2</label><title>Benchmarking details</title><p id="P9">We benchmarked Mora using simulated short and long reads against Pathoscope2 [<xref ref-type="bibr" rid="R12">12</xref>], Kraken2 [<xref ref-type="bibr" rid="R2">2</xref>], and Clark [<xref ref-type="bibr" rid="R3">3</xref>]. Pathoscope2 can identify strains, compute abundance levels, perform re-assignments, and output informative result summaries. It has seen usage in numerous studies [<xref ref-type="bibr" rid="R19">19</xref>–<xref ref-type="bibr" rid="R22">22</xref>], and its algorithm has also been incorporated into other taxonomic classification pipelines [<xref ref-type="bibr" rid="R23">23</xref>]. Kraken2 and Clark are two taxonomic classifiers that classify reads by assigning them a taxonomic ID. In the case of Kraken2, it may classify reads to the least common ancestor of the possible taxons to reduce the chance of false assignments. For Clark, the taxonomic IDs can be manipulated for strain-level assignments. This was also attempted for Kraken2, but errors were encountered when trying to build a custom database. Hence, Kraken2 was unable to work at the strain level. All algorithms except Pathoscope2 were run using their default parameters, which would not run due to the high number of strains. Instead, certain parts in Pathoscope2’s code had to be augmented to allow it run correctly. Its initial library construction code no longer works and must be replaced with code from MetaScope [<xref ref-type="bibr" rid="R24">24</xref>]. The output step also had to be fixed to allow for large number of reads. These changes did not affect how Pathoscope2 re-assigns reads, so the only change should be being able to run on large datasets and a decrease in runtime. We now denote the augmented Pathoscope2 as AugPatho2, and the augmented code can be found in same repository as the appendix files. Given these caveats, Pathoscope2 appears to be the current practical state-of-the-art.</p><p id="P10">We also considered MetaMaps [<xref ref-type="bibr" rid="R14">14</xref>] and Sigma [<xref ref-type="bibr" rid="R13">13</xref>], two other re-assignment tools, but they were not included in this comparison as the software are no longer actively maintained and parts of both software are no longer functional; other studies also had issues with these two programs [<xref ref-type="bibr" rid="R15">15</xref>, <xref ref-type="bibr" rid="R25">25</xref>].</p><p id="P11">F1 score, sensitivity, and precision are used to evaluate the accuracy of the final read re-assignment at three different taxonomic ranks: strain, species, and genus (see section 3.4). For the purpose of this paper, two DNA sequences are of the same species/genus if their NCBI taxID corresponds to the same species/genus name. Two DNA sequences are of the same strain if their accession number is the same.</p></sec><sec id="S8"><label>2.3</label><title>Re-Assignment of reads to similar strains</title><p id="P12">To test strain identification, 58 E. coli reference genomes were obtained from NCBI and 950,000 short 150bp pair-end reads were generated for 3 of those strains, so each strain has about 30x coverage. We aligned the reads with Pufferfish/Puffaligner [<xref ref-type="bibr" rid="R26">26</xref>], a very efficient read alignment method. We then used Mora and AugPatho2 to reassign the reads, and we report the number of assigned reads for each strain. We also performed assignment using Clark and Bowtie2 with their default parameters. The results are shown in <xref ref-type="fig" rid="F3">Figure 3</xref>. AugPatho2 is programmed to perform an initial assignment by calling Bowtie2 with pathoMAP. To allow the use of other alignment algorithms, we generated the SAM file independently of AugPatho2 and ran pathoID and pathoMAP on it. Since all the strains had the same taxonomic ID, Kraken2 could not be benchmarked on this dataset. To run Clark, the taxonomic IDs were changed to be unique from each other.</p><p id="P13">In <xref ref-type="fig" rid="F3">Figure 3</xref>, Mora, AugPatho2, and Pufferfish were able to identify the presence of all three strains. Mora had a F1 score of 74.03, much higher than 29.01, 32.48, 18.35, 32.28, the F1 scores of AugPatho2, Pufferfish, Clark, and Bowtie2 respectively. AugPatho2 mapped most reads to the strain C41(DE3), a strain whose average nucleotide identity to C43(DE3) is 99.94% according to OrthoANI [<xref ref-type="bibr" rid="R27">27</xref>]. This may be caused by how Pathoscope2’s algorithm incorporates reference length into its calculations of read alignment scores. The length of strain C43(DE3) was 56,061 base pairs shorter than strain C41(DE3), making the alignment scores to C41(DE3) higher than those to C43(DE3), which is the likely reason for a large number false assignments. As most high mapping scores were equal in value, selecting the primary alignment without regard of abundance levels is likely the reason for Pufferfish’s high false positive rate. Clark was unable to align 81% of the reads while Bowtie2 assigned almost equal amounts of reads to all strains. The number of reads assigned to each strain can be found in appendix table A.1.</p></sec><sec id="S9"><label>2.4</label><title>Large-scale simulated short read re-assignment at the species and genus level</title><p id="P14">We used the complex Illumina 400 dataset of 400 different microbial genomes and its corresponding simulated 26.6 million 75bp paired-end short reads [<xref ref-type="bibr" rid="R28">28</xref>] to test the accuracy of short read alignment. We consider two cases: when there is a good guess of which genomes the reads come from, and when there is no information at all. For the first case, we built a reference library (REF-1) from the Illumina 400 dataset (400 genomes) that was used to simulate our reads. For the second case, we built a reference library (REF-2) using the complete bacterial genomes from NCBI RefSeq (6487 genomes). Importantly, REF-2 does not contain all references in REF-1. REF-2 contains 36% of the strains, 72% of the species, and 87% of the genera of REF-1. Due to the lack of species and genus level taxonomic data for REF-1, the scores for species and genus are worse than the scores for strain. When using REF-2 as the reference genomes, scores for the strain rank are not reported due to the low number of strains from REF-1 included in REF-2.</p><p id="P15">When aligning to REF-1, Pufferfish was unable to map 13.7 million reads while Bowtie2 was unable to map 5.7 million. When aligning to REF-2, Pufferfish was unable to map 15.8 million reads while Bowtie2 was unable to map 10.1 million.</p><p id="P16">As shown in Tables <xref ref-type="table" rid="T3">tables 3</xref> and <xref ref-type="table" rid="T4">4</xref>, AugPatho2 performed worse than Mora when aligning to REF-2 using Bowtie2, but was slightly better in other cases. However, it was much slower in runtime due to the pathoREP module in AugPatho2. For large data sets, the pathoREP module wasn’t able to output the final XML file due to lack of memory. We had to split the SAM file into 3-5 smaller files and change the XML output script to accommodate this problem. As seen in <xref ref-type="table" rid="T1">Table 1</xref>, Mora was over 19 times faster than AugPatho2, while only having a 3 times increase in RAM usage. Using Bowtie2 increased scores significantly due to its ability to map more reads than Pufferfish, however, this did lead to a large increase in computer runtime. Clark had comparable but slightly better scores than Mora when using Bowtie2 in all categories except on REF-2 at the genus level. Kraken2 on the other hand performed worse than Mora when using Bowtie2 on REF-1 but had slightly better scores on REF-2 at the genus level.</p></sec><sec id="S10"><label>2.5</label><title>Re-Assignment of long reads</title><p id="P17">To test Mora on long reads, we used badreads [<xref ref-type="bibr" rid="R29">29</xref>] v0.4.0 with default parameters on REF-1 to simulate 1.37 million long nanopore reads. When using Minimap2 to perform the initial alignment to REF-1, 44.3 thousand reads could not be aligned. When using Minimap2 to align to REF-2, 183 thousand reads could not be aligned.</p><p id="P18">Tables <xref ref-type="table" rid="T5">tables 5</xref> and <xref ref-type="table" rid="T6">6</xref> lists the scores evaluating assignment accuracy at the strain, species, and genus level of long reads for the different algorithms. Mora consistently had higher scores on long reads for REF-1, though this lead was lost when looking at the scores for REF-2. Though AugPatho2 had a very similar score to Mora, <xref ref-type="table" rid="T2">Table 2</xref> shows a large difference in memory and RAM usage. Mora performs at least four times faster and uses up to 27.45 fold less RAM compared to AugPatho2 on long reads. The main bottleneck for AugPatho2 was again PathoREP, the algorithm to write its result files. Even after the augmentations of PathoREP to reduce its runtime and memory usage, AugPatho2 still had higher runtime and RAM usage than Mora for long reads. Both Kraken2 and Clark had lower F1 scores than Mora in both REF-1 and REF-2, which is expected as they were initially designed for short reads. Furthermore, Kraken2’s tendency to assign common ancestry when dealing with multi-mapping reads results in very low scores at the species level.</p></sec><sec id="S11"><label>2.6</label><title>Results on real sequencing data</title><p id="P19">To show applicability to real sequencing data, we ran Mora on two sets of real data, each representing a different scenario.</p><p id="P20">In the first case, we look at real short E. coli reads from three different assemblies. Mora and AugPatho2 (with Bowtie2 as the initial aligner) were run on 30,000 pair-end short reads of average length 250 bp. These 30,000 reads were composed of 10,000 reads from three SRA runs representing the assembly genomes of INF13/18/A, INF191/17/A, and INF32/16/A (see Appendix table A.7), while the references were the 58 E. coli strains used previously with the addition of the three new strains. The average nucleotide identity (ANI), calculated by skani [<xref ref-type="bibr" rid="R30">30</xref>], of the three strains to each other were between 96.4 and 96.57 (see Appendix table A.7). As seen in <xref ref-type="fig" rid="F4">Figure 4</xref>, Mora was able to assign most reads to the three INF strains, while AugPatho2 assigned a lot of reads to a different complete genome assembly: JJ2434. The ANI between JJ2434 and INF191/17/A was 99.39, but its complete genome (i.e. one single contig) sequence length was 3.4 million bps longer than the longest scaffold in the assembly for INF191/17/A. This is the likely reason for the large error in AugPatho2, which uses reference lengths for scoring. Similar to other experiments, Bowtie2 assigns a decent amount of reads to all E. coli strains. Mora had an F1 score of 62.34 while AugPatho2 and Bowtie2 had F1 scores of 49.48 and 41.10 respectively.</p><p id="P21">In the second case, we still test Mora on very similar strains, but now the reads are long PacBio Covid-19 reads. Mora and AugPatho2 (with Minimap2 as the initial aligner) were used to re-assign 2635 Covid-19 reads of average length 1239 bp to five different Covid-19 strains: Wuhan, Alpha, Beta, Delta, and Omnicron. The specific sequence used to represent these strains was chosen by taking the first sequence for the Pango lineage as shown on NCBI Virus. For the Alpha strain, two different sequences (one from USA and one from Germany) were selected, but their ANI was 99.91, meaning they differed by around 30 nucleotides. ANI between the different strains was between 99.50 and 99.85. For more sample details, see Appendix table A.8. As the samples were taken from USA during 2021, which was when the Alpha strain was the most prevalent, it is likely that the samples are likely to belong the Alpha strain. As seen in <xref ref-type="fig" rid="F5">Figure 5</xref>, Mora assigns the most reads to Alpha, with AugPatho2 assigning the second most number of reads to Alpha. Based on our initial knowledge of the samples, we conclude that the results from Mora are more likely to be correct in this experiment.</p></sec></sec><sec id="S12" sec-type="methods"><label>3</label><title>Methods</title><p id="P22">We define <italic>mapping score</italic> as some positive value associated to each alignment that measures how good the alignment is. In practice, we use the AS:i secondary flag that is present in most read aligners, but our theory holds for any such score.</p><sec id="S13"><label>3.1</label><title>Initial read mapping</title><p id="P23">The input to Mora is a SAM/BAM file with an initial alignment of the reads. After filtering out unaligned reads, the remaining reads are fed into Mora. At minimum, Mora only requires a SAM file with header information to output read (re)assignments. Mora optionally allows for the inclusion of taxonomic information of reference genomes in the final output by using accession and taxonomic information from NCBI.</p><p id="P24">For convenience, Mora is also implemented with a read mapping module using Snakemake [<xref ref-type="bibr" rid="R31">31</xref>], allowing the user to use Mora from a set of input reads and references. The mapping modules allow the user to use Pufferfish, Bowtie2, or Minimap2. However other programs can be used as long as their generated SAM contains a header with the reference genomes and the AS:i secondary mapping flag is available in each alignment record. After the SAM file is generated, the reads that could not be assigned are filtered out. These reads are later added to the final output with the “NO ALIGNMENT” string being assigned to them.</p></sec><sec id="S14"><label>3.2</label><title>Abundance estimation</title><p id="P25">We solve the problem of estimating the abundance levels of reference genomes by adapting the common model from calculating RNA transcript abundances used by Agamemnon [<xref ref-type="bibr" rid="R17">17</xref>] and RSEM [<xref ref-type="bibr" rid="R32">32</xref>]. In this model, each read is generated by first selecting a reference and then a position on that reference. Assuming the same model for all the reads, we have the following likelihood function for observing a set of reads from a set of reference genomes. <disp-formula id="FD1"><mml:math id="M1"><mml:mi mathvariant="bold-fraktur">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>θ</mml:mi><mml:mo>∣</mml:mo><mml:mi mathvariant="bold-fraktur">Q</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mo>∏</mml:mo></mml:mstyle><mml:mtext>​</mml:mtext></mml:msup></mml:mrow><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="bold-fraktur">Q</mml:mi></mml:mrow></mml:munder><mml:munderover><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mtext>​</mml:mtext></mml:msup></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:munderover><mml:mi>Pr</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:mi>θ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>Pr</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></disp-formula> where M is the number of references, <inline-formula><mml:math id="M2"><mml:mrow><mml:mi mathvariant="bold-fraktur">Q</mml:mi></mml:mrow></mml:math></inline-formula> is the set of reads, <italic>θ</italic> is the abundance estimation, <italic>Pr(R<sub>j</sub>|θ)</italic> is the prior probability of selecting reference <italic>R<sub>j</sub></italic>, and <italic>Pr(r<sub>i</sub>|R<sub>j</sub>)</italic> is the conditional probability of generating read <italic>r<sub>i</sub></italic> from reference <italic>R<sub>j</sub></italic>.</p><p id="P26"><italic>Pr(r<sub>i</sub>|R<sub>j</sub></italic>) is computed by normalizing the mapping score between read <italic>r<sub>i</sub></italic> and reference <italic>R<sub>j</sub></italic> over all mapping scores from <italic>r<sub>i</sub></italic>. The estimation of θ is done with an EM algorithm. To reduce the number of iterations needed by the EM algorithm to converge, the reads are reduced to a set of equivalent classes where two reads <italic>r<sub>i<sub>1</sub></sub></italic> and <italic>r<sub>i<sub>2</sub></sub></italic> are equivalent if they align to the same set of references.</p><p id="P27">After every 10 iterations, we implement Agamemnon’s idea of using a set cover algorithm to remove redundant references with low abundances from the rest of the iteration process. This results in better-estimated abundances of leftover references while also increasing the convergence rate. These algorithms are implemented based on the Cedar algorithm used by Agamemnon. For more information, please consult Agamemnon’s original paper.</p></sec><sec id="S15"><label>3.3</label><title>Re-Assignment of reads</title><p id="P28">Mora then adds to the functions of Agamemnon by using the estimated abundance levels to perform read re-assignment. The assignment of reads based on their mapping scores while trying to stay true to the estimated abundance levels can be modeled as a variant of the Weapon-Target Assignment (WTA) problem [<xref ref-type="bibr" rid="R33">33</xref>]. Given different weapons that are to be fired on a set of different targets, the objective is to find which weapons should be assigned to which targets to minimize the expected remaining health of the targets. Formulating it as a non-linear problem, let {<italic>T</italic><sub>1</sub>, <italic>T</italic><sub>2</sub>,…,<italic>T<sub>N</sub></italic>} be the set of targets and {<italic>W</italic><sub>1</sub>, <italic>W</italic><sub>2</sub>,…,<italic>W<sub>M</sub></italic>} be the set of different weapons. For each weapon type <italic>W<sub>i</sub></italic>, there are <italic>w<sub>i</sub></italic> number of it and each has probability p¿j to destroy the target <italic>T<sub>j</sub></italic>. After assigning <italic>x<sub>ij</sub></italic> of weapon <italic>W<sub>i</sub></italic> to target <italic>T<sub>j</sub></italic>, the probability that <italic>T<sub>j</sub></italic> survives is <inline-formula><mml:math id="M3"><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:msubsup><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula>. Thus the WTA problem aims to minimize the following non-linear problem with constraints: <disp-formula id="FD2"><mml:math id="M4"><mml:mi>min</mml:mi><mml:mi>G</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munderover><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mtext>​</mml:mtext></mml:msup></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:munderover><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mo>∏</mml:mo></mml:mstyle><mml:mtext>​</mml:mtext></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:munderover><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:munderover><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mtext>​</mml:mtext></mml:msup></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℤ</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:math></disp-formula></p><p id="P29">Instead of selecting which weapons to assign to which targets to maximize expected damage, we are selecting which reads to assign to which references to maximize likelihood. Let <italic>R<sub>j</sub></italic> represent a reference genome, <italic>r<sub>i</sub></italic> represent a read, and <italic>p<sub>ij</sub></italic> represent the probability that <italic>r<sub>i</sub></italic> comes from <italic>R<sub>j</sub></italic> is true, calculated in the same way as for abundance estimation. To model our metagenomic problem as the WTA problem, we have three assumptions: <list list-type="order" id="L1"><list-item><p id="P30">Every reference <italic>R<sub>j</sub></italic> appears <italic>a<sub>j</sub> · M</italic> times in the set of references, where <italic>a<sub>j</sub></italic> is the estimated abundance of <italic>R<sub>j</sub></italic> and <italic>M</italic> is the total number of reads. The value of <italic>a<sub>j</sub> · M</italic> is approximated to the nearest integer.</p></list-item><list-item><p id="P31">Every read maps to some reference genome.</p></list-item><list-item><p id="P32">Every read is unique, so <italic>w<sub>i</sub></italic> = 1 for <italic>i</italic> = 1,…, <italic>M</italic>.</p></list-item></list></p><p id="P33">These three assumptions result in the re-assignment problem being formulated as the following minimization problem with constraints: <disp-formula id="FD3"><label>(1)</label><mml:math id="M5"><mml:mi>min</mml:mi><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munderover><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mtext>​</mml:mtext></mml:msup></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:munderover><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mtext>​</mml:mtext></mml:msup></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>⋅</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:munderover><mml:munderover><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mo>∏</mml:mo></mml:mstyle><mml:mtext>​</mml:mtext></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:munderover><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></disp-formula> <disp-formula id="FD4"><mml:math id="M6"><mml:munderover><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mtext>​</mml:mtext></mml:msup></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:munderover><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mtext>​</mml:mtext></mml:msup></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>⋅</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℤ</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:math></disp-formula></p><p id="P34">The second sum shows that there are <italic>a<sub>j</sub> · M</italic> of reference <italic>M<sub>j</sub></italic> and the <italic>x<sub>i,(j,k)</sub></italic> is how much of read <italic>r<sub>i</sub></italic> we assign to the <italic>k</italic>th copy of reference <italic>M<sub>j</sub></italic>. This model is more punishing against undershooting compared to overshooting as over-assigning reads to a reference does not decrease the objective function <italic>F</italic>(<italic>x</italic>). This is desirable as it is better to identify all the low-abundance genomes and undershoot the most abundant genome than to not identify the low-abundance genomes. As leaving a read un-assigned and assigning it to a very wrong reference both contribute a value of 1 to the objective function <italic>F(x)</italic>, the assumption that every read maps to some reference is needed to prevent large numbers of false positives. Using Equation 1, we can now use optimization methods to get exact solutions, though this is not very practical given the bad runtime scaling for large data sets.</p><p id="P35">As this is an NP-hard problem [<xref ref-type="bibr" rid="R33">33</xref>], Mora uses a greedy algorithm that finds a relatively good solution. Mora views each reference as a bin with a fixed space capacity. Every time a read is assigned to a reference, the available capacity of the reference decreases. Once the capacity of a reference is full, no other read can be assigned to that reference unless something is taken out. By default, the capacity <italic>C<sub>j</sub></italic> of a reference <italic>R<sub>j</sub></italic> is <italic>C<sub>j</sub></italic> = <italic>aj</italic> + 0.001. The amount of space each read takes up is 1/<italic>M</italic>. As reads get assigned to the references, the references <italic>R<sub>i</sub></italic> can be represented as a list of assignments 𝓐(<italic>R<sub>i</sub></italic>) containing the reads that have already been assigned to it. <disp-formula id="FD5"><label>(2)</label><mml:math id="M7"><mml:mi>𝓐</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></disp-formula> where <italic>r<sub>i</sub><sub>k</sub></italic> represents a read, <italic>s<sub>i<sub>k,i</sub></sub></italic> is the corresponding mapping score between <italic>r<sub>i<sub>k</sub></sub></italic> and <italic>R<sub>i</sub></italic>, and <italic>n</italic> is the current number of reads that have been assigned to <italic>R<sub>i</sub></italic>. The list is ordered using <italic>s<sub>i<sub>i,k</sub></sub></italic> ≥ <italic>s<sub>i<sub>(k+1),i</sub></sub></italic> and the capacity limitation is <inline-formula><mml:math id="M8"><mml:mfrac><mml:mi>n</mml:mi><mml:mi>M</mml:mi></mml:mfrac><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula>. If <inline-formula><mml:math id="M9"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:mfrac><mml:mo>≥</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula>, we say that the reference <italic>R<sub>i</sub></italic> is full. Similarly, the reads <italic>r<sub>j</sub></italic> can be represented as a list of potential mappings 𝓜(<italic>r<sub>j</sub></italic>). <disp-formula id="FD6"><label>(3)</label><mml:math id="M10"><mml:mi>𝓜</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></disp-formula> where the list is ordered such that <italic>S<sub>j,j<sub>k</sub></sub></italic> ≥ <italic>S<sub>j,j<sub>(k+1)</sub></sub></italic>. The total score of a read <italic>r<sub>j</sub></italic> is defined to be <disp-formula id="FD7"><mml:math id="M11"><mml:mi>T</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mtext>​</mml:mtext></mml:msup></mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>a</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:mi>𝓜</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:munder><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:math></disp-formula> which gives us, by definition, that <inline-formula><mml:math id="M12"><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:math></inline-formula>.</p><p id="P36">Mora assigns the reads in terms of priority. A read <italic>r<sub>i</sub></italic> is given priority 1 if the read maps to only one reference. A read <italic>r<sub>i</sub></italic> is given priority 2 if the ratio of the second best score to the best score is less than a threshold. By default, this threshold is 0.5 but can be changed. A read is given priority 3 if it doesn’t satisfy the conditions of being priority 1 or priority 2. Once priority values are assigned, the priority 1 reads are assigned, followed by priority 2 reads, and then priority 3 reads.</p><p id="P37">Priority 1 reads are assigned to the unique reference they map to. For priority 2 reads, they are first sorted from highest best mapping score to lowest best mapping scores. In this order, the reads are assigned to the reference with the best mapping score if that reference has space. If the reference is at full capacity, the read is relabeled as a priority 3 read. When assigning priority 3 reads, all mappings between the priority 3 reads and references that still have space are sorted in terms of the score into a list. The reads are then assigned in order of this list, or left over for a second round of assignment if all of its potential references are full. After the initial assignment is done, Mora will try to “open up space” in a reference to assign leftover reads.</p><sec id="S16"><title>Definition 1</title><p id="P38"><italic>For a read r<sub>i</sub> and (R<sub>j</sub>, s<sub>i,j</sub>) ∈ 𝓜(r<sub>i</sub>), R<sub>j</sub> can open up space for r<sub>i</sub> if it is full and there exists a (r<sub>k</sub>,s<sub>k,j</sub>) ∈ 𝓐(R<sub>j</sub>) such that r<sub>k</sub> can be moved to another reference (R<sub>l</sub>, s<sub>k,l</sub>) ∈ 𝓜(r<sub>k</sub>) with the condition that</italic> <disp-formula id="FD8"><label>(4)</label><mml:math id="M13"><mml:mfrac><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>≥</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:math></disp-formula></p><p id="P39">Using the notation in this definition, we have the following theorem.</p></sec><sec id="S17"><title>Theorem 1</title><p id="P40">If r<sub>i</sub> is a read and R<sub>j</sub> is a reference that can open up space for r<sub>i</sub> by re-assigning r<sub>k</sub> to another reference R<sub>l</sub>, then doing so and then assigning r<sub>i</sub> to R<sub>j</sub> decreases the value of F(x) from Equation 1.</p><sec id="S18"><title>Proof</title><p id="P41">The act of performing this re-assigning <italic>r<sub>k</sub></italic> from <italic>R<sub>j</sub></italic> to <italic>R<sub>l</sub></italic> and then assigning <italic>r<sub>i</sub></italic> to <italic>R<sub>j</sub></italic> is equivalent to changing from [<italic>x<sub>ij</sub>, x<sub>kj</sub>, x<sub>kl</sub></italic>] = [0,1, 0] to <inline-formula><mml:math id="M14"><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msubsup><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>∗</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>x</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>∗</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>x</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mo>∗</mml:mo></mml:msubsup></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula>. Since <inline-formula><mml:math id="M15"><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:math></inline-formula>, the last condition of being able to open up space gives us that <disp-formula id="FD9"><mml:math id="M16"><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>⇒</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mn>2</mml:mn><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P42">The right side can be written as <disp-formula id="FD10"><mml:math id="M17"><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:msubsup><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>∗</mml:mo></mml:msubsup></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:msubsup><mml:mi>x</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>∗</mml:mo></mml:msubsup></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:msubsup><mml:mi>x</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mo>∗</mml:mo></mml:msubsup></mml:mrow></mml:msup><mml:mo>≤</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:math></disp-formula></p><p id="P43">Since there is space in <italic>R<sub>l</sub></italic>, changing the three values <italic>x<sub>ij</sub>, x<sub>kj</sub>, x<sub>kl</sub></italic> doesn’t result in the invalidation of any constraints and doesn’t affect any other terms in the sum of <italic>F(x)</italic>. Thus, performing the re-assignment causes a decrease in the value of <italic>F(x)</italic>.</p><p id="P44">If space cannot be opened up in <italic>R<sub>j1</sub></italic>, Mora will try to open up space in <italic>R<sub>j2</sub></italic>, and so on. If space cannot be opened for any of the references the read maps to, the read will be left to the end to be assigned randomly with weights corresponding to the mapping scores. At this stage, mapping these reads using probability is plausible as their mapping scores are relatively similar to each other. A simple example of this greedy algorithm is shown in <xref ref-type="fig" rid="F2">Figure 2</xref>.</p></sec></sec></sec><sec id="S19"><label>3.4</label><title>Evaluation metrics</title><p id="P45">Genomes are classified as the same species or genus depending on the taxonomic information listed in NCBI. Taxonomic information of the data is obtained from NCBI Taxonomy’s FTP database (/pub/taxonomy/accession2taxid/) using the live and dead nucleotide sequence records. Genomes are classified as the same strain if their accession numbers are the same. The calculation of the accuracy metrics only considers reads that were successfully aligned by the first assignment algorithm. This allows us to evaluate the re-assignment algorithms without having the results be affected by the first assignment algorithms.</p><p id="P46">Read assignment accuracy on the simulated data sets is measured using F1 score, sensitivity, and precision. Let <italic>r<sub>i</sub></italic> be a read generated from a reference <italic>R<sub>i</sub></italic>. At any taxonomic rank, <italic>r<sub>i</sub></italic> is labeled as a true positive if it is mapped to reference <italic>R<sub>j</sub></italic> that agrees with <italic>R<sub>i</sub></italic> at that taxonomic rank. If <italic>R<sub>i</sub></italic> and <italic>R<sub>j</sub></italic> do not agree at that rank, then <italic>r<sub>i</sub></italic> is labeled a false positive. If <italic>r<sub>i</sub></italic> is not assigned to anything, it is not labeled as anything. For example, a read generated from <italic>Escherichia coli</italic> with accession number CP0001, assigning it to <italic>Escherichia coli</italic> with accession number CP0005 would be a true positive for the species and genus rank, but a false positive at the strain rank. Assigning it to <italic>Escherichia fergusonii</italic> with accession number CP1001 would be a true positive at the genus rank, but a false positive at the strain and species rank.</p><p id="P47">For a taxonomic rank, let TP be the total number of true positives for that rank and let FP be the total number of false positives for that rank. We define <disp-formula id="FD11"><mml:math id="M18"><mml:mtext>Sensitivity </mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:mfrac><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mtext> Precision </mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi><mml:mo>+</mml:mo><mml:mi>F</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:mfrac></mml:math></disp-formula> where <italic>M</italic> is the total number of reads. The F1 score is defined to be the harmonic mean of sensitivity and precision.</p></sec><sec id="S20"><label>3.5</label><title>Data Simulation and Availability</title><p id="P48">30 E. coli genomes assemblies were downloaded from NCBI Assembly and combined to form 58 E. coli strains. The three strains 2009C-3133, SQ110, and C43(DE3) were chosen randomly to simulate short reads 1.37 million 150bp pair-end short reads. The reads were simulated according to a uniform distribution using art_illumina [<xref ref-type="bibr" rid="R34">34</xref>] with the default parameters for pair-end reads. The simulated 26.6 million 75bp pairend short read data from REF-1 was obtained from [<xref ref-type="bibr" rid="R28">28</xref>], where it simulated using iMESSJllumina with a skewed distribution. For the simulation of long reads, Badread [<xref ref-type="bibr" rid="R29">29</xref>] was used with the default parameters corresponding to mediocre Oxford nanopore reads with quantity 20x. The read distribution is proportional to the length of the references.</p><p id="P49">The real E.coli data for the strains INF32/16/A, INF191/17/A, and INF13/18/A can be found at SRR15443628, SRR15497613, and SRR10587526 respectively. The Covid-19 reference strains were taken from NCBI Virus by searching for their respective accession codes (found in Appendix table A.8) while the samples were taken from SRR14752036.</p><p id="P50">For a use-case, the <italic>E. coli</italic> reads and references are available at <ext-link ext-link-type="uri" xlink:href="https://github.com/AfZheng126/MORA-data">https://github.com/AfZheng126/MORA-data</ext-link>. The full appendix tables of scores, time, and memory usage for the different simulations are also available in the same repository as the <italic>E. coli</italic> reads/reference data.</p></sec></sec><sec id="S21" sec-type="conclusions"><label>4</label><title>Conclusion</title><p id="P51">In this work, we presented Mora, a new flexible algorithm and pipeline for assigning reads at the strain level. Mora takes as input an alignment file and re-assigns the reads to strains by (1) estimating abundance information and (2) modelling the reassignment problem as a discrete non-linear minimization problem for which Mora’s heuristic solution has provable guarantees. We showed that Mora performs well compared to other read assignment algorithms, but truly shines on reads from very similar strains.</p><p id="P52">Additionally, we showed that Mora is fast and practical to use, even on large datasets, with speeds and memory usage several times better than AugPatho2. Though the speed of the full pipeline is slower than Kraken2 and Clark, it makes up for it this with higher F1 scores at the strain, species, and genus levels on long reads and very similar reads.</p><p id="P53">We found that there is a surprising lack of well-engineered tools that deal with the specific problem of sensitive read re-assignment to the strain level. Thus we designed Mora using general mathematical formulations, leading to it working well on many kinds of data. Furthermore, Mora is engineered to be modular and easy to use—the minimal input required is just a single SAM/BAM file. Thus we believe that Mora will be a useful tool for researchers interested in studying strain-level read information from metagenomic sequencing data.</p></sec></body><back><ack id="S22"><title>Acknowledgements</title><sec id="S23"><title>Funding</title><p>We acknowledge the support of the Natural Sciences and Engineering Research Council of Canada (NSERC), (NSERC grant RGPIN-2022-03074), as well as the DND/NSERC Discovery Grant Supplement DGDND-2022-03074. J.S is supported by an NSERC CGS-D scholarship.</p></sec></ack><sec id="S24" sec-type="data-availability"><title>Availability of data and materials</title><p id="P54">All analysis software written for this manuscript are available in the <ext-link ext-link-type="uri" xlink:href="https://github.com/AfZheng126/MORA">https://github.com/AfZheng126/MORA</ext-link> repository, which contains the Mora software described in this manuscript. The software requires Rust ¿1.60.0 and has been tested on Linux environments. It is available under an MIT-style free and open source license.</p><p id="P55">The datasets supporting the conclusions of this article are available in the <ext-link ext-link-type="uri" xlink:href="https://github.com/AfZheng126/MORA-data">https://github.com/AfZheng126/MORA-data</ext-link> repository.</p></sec><fn-group><fn id="FN1" fn-type="conflict"><p id="P56"><bold>Conflict of interest</bold></p><p id="P57">We declare no conflicts of interest.</p></fn><fn id="FN2" fn-type="con"><p id="P58"><bold>Authors’ contributions</bold></p><p id="P59">The study was conceived by J.S. and supervised by Y.W.Y. A.Z. wrote the software and performed the experiments.</p></fn><fn id="FN3"><p id="P60"><bold>Consent for publication</bold></p><p id="P61">This manuscript has been seen and approved by all listed authors.</p></fn><fn id="FN4"><p id="P62"><bold>Ethics approval</bold></p><p id="P63">Not applicable.</p></fn><fn id="FN5"><p id="P64"><bold>Consent to participate</bold></p><p id="P65">Not applicable.</p></fn></fn-group><ref-list><ref id="R1"><label>[1]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lu</surname><given-names>J</given-names></name><name><surname>Rincon</surname><given-names>N</given-names></name><name><surname>Wood</surname><given-names>DE</given-names></name><name><surname>Breitwieser</surname><given-names>FP</given-names></name><name><surname>Pockrandt</surname><given-names>C</given-names></name><name><surname>Langmead</surname><given-names>B</given-names></name><etal/></person-group><article-title>Metagenome analysis using the Kraken software suite</article-title><source>Nature protocols</source><year>2022</year><volume>17</volume><issue>12</issue><fpage>2815</fpage><lpage>2839</lpage><pub-id pub-id-type="pmcid">PMC9725748</pub-id><pub-id pub-id-type="pmid">36171387</pub-id><pub-id pub-id-type="doi">10.1038/s41596-022-00738-y</pub-id></element-citation></ref><ref id="R2"><label>[2]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wood</surname><given-names>DE</given-names></name><name><surname>Lu</surname><given-names>J</given-names></name><name><surname>Langmead</surname><given-names>B</given-names></name></person-group><article-title>Improved metagenomic analysis with Kraken 2</article-title><source>Genome biology</source><year>2019</year><volume>20</volume><fpage>1</fpage><lpage>13</lpage><pub-id pub-id-type="pmcid">PMC6883579</pub-id><pub-id pub-id-type="pmid">31779668</pub-id><pub-id pub-id-type="doi">10.1186/s13059-019-1891-0</pub-id></element-citation></ref><ref id="R3"><label>[3]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ounit</surname><given-names>R</given-names></name><name><surname>Wanamaker</surname><given-names>S</given-names></name><name><surname>Close</surname><given-names>TJ</given-names></name><name><surname>Lonardi</surname><given-names>S</given-names></name></person-group><article-title>CLARK: fast and accurate classification of metagenomic and genomic sequences using discriminative k-mers</article-title><source>BMC genomics</source><year>2015</year><volume>16</volume><issue>1</issue><fpage>1</fpage><lpage>13</lpage><pub-id pub-id-type="pmcid">PMC4428112</pub-id><pub-id pub-id-type="pmid">25879410</pub-id><pub-id pub-id-type="doi">10.1186/s12864-015-1419-2</pub-id></element-citation></ref><ref id="R4"><label>[4]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kim</surname><given-names>D</given-names></name><name><surname>Song</surname><given-names>L</given-names></name><name><surname>Breitwieser</surname><given-names>FP</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name></person-group><article-title>Centrifuge: rapid and sensitive classification of metagenomic sequences</article-title><source>Genome research</source><year>2016</year><volume>26</volume><issue>12</issue><fpage>1721</fpage><lpage>1729</lpage><pub-id pub-id-type="pmcid">PMC5131823</pub-id><pub-id pub-id-type="pmid">27852649</pub-id><pub-id pub-id-type="doi">10.1101/gr.210641.116</pub-id></element-citation></ref><ref id="R5"><label>[5]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Segata</surname><given-names>N</given-names></name></person-group><article-title>On the road to strain-resolved comparative metagenomics</article-title><source>MSystems</source><year>2018</year><volume>3</volume><issue>2</issue><elocation-id>e00190-17</elocation-id><pub-id pub-id-type="pmcid">PMC5850074</pub-id><pub-id pub-id-type="pmid">29556534</pub-id><pub-id pub-id-type="doi">10.1128/mSystems.00190-17</pub-id></element-citation></ref><ref id="R6"><label>[6]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Brito</surname><given-names>IL</given-names></name><name><surname>Alm</surname><given-names>EJ</given-names></name></person-group><article-title>Tracking strains in the microbiome: insights from metagenomics and models</article-title><source>Frontiers in Microbiology</source><year>2016</year><volume>7</volume><fpage>712</fpage><pub-id pub-id-type="pmcid">PMC4871868</pub-id><pub-id pub-id-type="pmid">27242733</pub-id><pub-id pub-id-type="doi">10.3389/fmicb.2016.00712</pub-id></element-citation></ref><ref id="R7"><label>[7]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Leimbach</surname><given-names>A</given-names></name><name><surname>Hacker</surname><given-names>J</given-names></name><name><surname>Dobrindt</surname><given-names>U</given-names></name></person-group><article-title>E. coli as an all-rounder: the thin line between commensalism and pathogenicity</article-title><source>Between pathogenicity and commensalism</source><year>2013</year><fpage>3</fpage><lpage>32</lpage><pub-id pub-id-type="pmid">23340801</pub-id></element-citation></ref><ref id="R8"><label>[8]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Langmead</surname><given-names>B</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name></person-group><article-title>Fast gapped-read alignment with Bowtie 2</article-title><source>Nature methods</source><year>2012</year><volume>9</volume><issue>4</issue><fpage>357</fpage><lpage>359</lpage><pub-id pub-id-type="pmcid">PMC3322381</pub-id><pub-id pub-id-type="pmid">22388286</pub-id><pub-id pub-id-type="doi">10.1038/nmeth.1923</pub-id></element-citation></ref><ref id="R9"><label>[9]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H</given-names></name></person-group><article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title><source>Bioinformatics</source><year>2018</year><volume>34</volume><issue>18</issue><fpage>3094</fpage><lpage>3100</lpage><pub-id pub-id-type="pmcid">PMC6137996</pub-id><pub-id pub-id-type="pmid">29750242</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/bty191</pub-id></element-citation></ref><ref id="R10"><label>[10]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Yorukoglu</surname><given-names>D</given-names></name><name><surname>Yu</surname><given-names>YW</given-names></name><name><surname>Peng</surname><given-names>J</given-names></name><name><surname>Berger</surname><given-names>B</given-names></name></person-group><article-title>Compressive mapping for nextgeneration sequencing</article-title><source>Nature biotechnology</source><year>2016</year><volume>34</volume><issue>4</issue><fpage>374</fpage><lpage>376</lpage><pub-id pub-id-type="pmcid">PMC5080835</pub-id><pub-id pub-id-type="pmid">27054987</pub-id><pub-id pub-id-type="doi">10.1038/nbt.3511</pub-id></element-citation></ref><ref id="R11"><label>[11]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lu</surname><given-names>J</given-names></name><name><surname>Breitwieser</surname><given-names>FP</given-names></name><name><surname>Thielen</surname><given-names>P</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name></person-group><article-title>Bracken: estimating species abundance in metagenomics data</article-title><source>PeerJ Computer Science</source><year>2017</year><volume>3</volume><fpage>e104</fpage></element-citation></ref><ref id="R12"><label>[12]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hong</surname><given-names>C</given-names></name><name><surname>Manimaran</surname><given-names>S</given-names></name><name><surname>Shen</surname><given-names>Y</given-names></name><name><surname>Perez-Rogers</surname><given-names>JF</given-names></name><name><surname>Byrd</surname><given-names>AL</given-names></name><name><surname>Castro-Nallar</surname><given-names>E</given-names></name><etal/></person-group><article-title>PathoScope 2.0: a complete computational framework for strain identification in environmental or clinical sequencing samples</article-title><source>Microbiome</source><year>2014</year><volume>2</volume><issue>1</issue><fpage>1</fpage><lpage>15</lpage><pub-id pub-id-type="pmcid">PMC4164323</pub-id><pub-id pub-id-type="pmid">25225611</pub-id><pub-id pub-id-type="doi">10.1186/2049-2618-2-33</pub-id></element-citation></ref><ref id="R13"><label>[13]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ahn</surname><given-names>TH</given-names></name><name><surname>Chai</surname><given-names>J</given-names></name><name><surname>Pan</surname><given-names>C</given-names></name></person-group><article-title>Sigma: strain-level inference of genomes from metagenomic analysis for biosurveillance</article-title><source>Bioinformatics</source><year>2015</year><volume>31</volume><issue>2</issue><fpage>170</fpage><lpage>177</lpage><pub-id pub-id-type="pmcid">PMC4287953</pub-id><pub-id pub-id-type="pmid">25266224</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btu641</pub-id></element-citation></ref><ref id="R14"><label>[14]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dilthey</surname><given-names>AT</given-names></name><name><surname>Jain</surname><given-names>C</given-names></name><name><surname>Koren</surname><given-names>S</given-names></name><name><surname>Phillippy</surname><given-names>AM</given-names></name></person-group><article-title>Strain-level metagenomic assignment and compositional estimation for long reads with MetaMaps</article-title><source>Nature communications</source><year>2019</year><volume>10</volume><issue>1</issue><elocation-id>3066</elocation-id><pub-id pub-id-type="pmcid">PMC6624308</pub-id><pub-id pub-id-type="pmid">31296857</pub-id><pub-id pub-id-type="doi">10.1038/s41467-019-10934-2</pub-id></element-citation></ref><ref id="R15"><label>[15]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>van Dijk</surname><given-names>LR</given-names></name><name><surname>Walker</surname><given-names>BJ</given-names></name><name><surname>Straub</surname><given-names>TJ</given-names></name><name><surname>Worby</surname><given-names>CJ</given-names></name><name><surname>Grote</surname><given-names>A</given-names></name><name><surname>Schreiber</surname><given-names>HL</given-names><suffix>IV</suffix></name><etal/></person-group><article-title>StrainGE: a toolkit to track and characterize low-abundance strains in complex microbial communities</article-title><source>Genome biology</source><year>2022</year><volume>23</volume><issue>1</issue><fpage>74</fpage><pub-id pub-id-type="pmcid">PMC8900328</pub-id><pub-id pub-id-type="pmid">35255937</pub-id><pub-id pub-id-type="doi">10.1186/s13059-022-02630-0</pub-id></element-citation></ref><ref id="R16"><label>[16]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Albanese</surname><given-names>D</given-names></name><name><surname>Donati</surname><given-names>C</given-names></name></person-group><article-title>Strain profiling and epidemiology of bacterial species from metagenomic sequencing</article-title><source>Nature communications</source><year>2017</year><volume>8</volume><issue>1</issue><elocation-id>2260</elocation-id><pub-id pub-id-type="pmcid">PMC5741664</pub-id><pub-id pub-id-type="pmid">29273717</pub-id><pub-id pub-id-type="doi">10.1038/s41467-017-02209-5</pub-id></element-citation></ref><ref id="R17"><label>[17]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Skoufos</surname><given-names>G</given-names></name><name><surname>Almodaresi</surname><given-names>F</given-names></name><name><surname>Zakeri</surname><given-names>M</given-names></name><name><surname>Paulson</surname><given-names>JN</given-names></name><name><surname>Patro</surname><given-names>R</given-names></name><name><surname>Hatzigeorgiou</surname><given-names>AG</given-names></name><etal/></person-group><article-title>AGAMEMNON: an Accurate metaGenomics And MEtatranscriptoMics quaNtificatiON analysis suite</article-title><source>Genome Biology</source><year>2022</year><volume>23</volume><issue>1</issue><fpage>1</fpage><lpage>27</lpage><pub-id pub-id-type="pmcid">PMC8802518</pub-id><pub-id pub-id-type="pmid">35101114</pub-id><pub-id pub-id-type="doi">10.1186/s13059-022-02610-4</pub-id></element-citation></ref><ref id="R18"><label>[18]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schaeffer</surname><given-names>L</given-names></name><name><surname>Pimentel</surname><given-names>H</given-names></name><name><surname>Bray</surname><given-names>N</given-names></name><name><surname>Melsted</surname><given-names>P</given-names></name><name><surname>Pachter</surname><given-names>L</given-names></name></person-group><article-title>Pseudoalignment for metagenomic read assignment</article-title><source>Bioinformatics</source><year>2017</year><volume>33</volume><issue>14</issue><fpage>2082</fpage><lpage>2088</lpage><pub-id pub-id-type="pmcid">PMC5870846</pub-id><pub-id pub-id-type="pmid">28334086</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btx106</pub-id></element-citation></ref><ref id="R19"><label>[19]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Uzelac</surname><given-names>M</given-names></name><name><surname>Li</surname><given-names>Y</given-names></name><name><surname>Chakladar</surname><given-names>J</given-names></name><name><surname>Li</surname><given-names>WT</given-names></name><name><surname>Ongkeko</surname><given-names>WM</given-names></name></person-group><article-title>Archaea Microbiome Dys-regulated Genes and Pathways as Molecular Targets for Lung Adenocarcinoma and Squamous Cell Carcinoma</article-title><source>International Journal of Molecular Sciences</source><year>2022</year><volume>23</volume><issue>19</issue><elocation-id>11566</elocation-id><pub-id pub-id-type="pmcid">PMC9570029</pub-id><pub-id pub-id-type="pmid">36232866</pub-id><pub-id pub-id-type="doi">10.3390/ijms231911566</pub-id></element-citation></ref><ref id="R20"><label>[20]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fujiogi</surname><given-names>M</given-names></name><name><surname>Raita</surname><given-names>Y</given-names></name><name><surname>Pérez-Losada</surname><given-names>M</given-names></name><name><surname>Freishtat</surname><given-names>RJ</given-names></name><name><surname>Celedon</surname><given-names>JC</given-names></name><name><surname>Mansbach</surname><given-names>JM</given-names></name><etal/></person-group><article-title>Integrated relationship of nasopharyngeal airway host response and microbiome associates with bronchiolitis severity</article-title><source>Nature communications</source><year>2022</year><volume>13</volume><issue>1</issue><elocation-id>4970</elocation-id><pub-id pub-id-type="pmcid">PMC9427849</pub-id><pub-id pub-id-type="pmid">36042194</pub-id><pub-id pub-id-type="doi">10.1038/s41467-022-32323-y</pub-id></element-citation></ref><ref id="R21"><label>[21]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kinsella</surname><given-names>CM</given-names></name><name><surname>Deijs</surname><given-names>M</given-names></name><name><surname>Becker</surname><given-names>C</given-names></name><name><surname>Broekhuizen</surname><given-names>P</given-names></name><name><surname>van Gool</surname><given-names>T</given-names></name><name><surname>Bart</surname><given-names>A</given-names></name><etal/></person-group><article-title>Host prediction for disease-associated gastrointestinal cressdnaviruses</article-title><source>Virus Evolution</source><year>2022</year><volume>8</volume><issue>2</issue><elocation-id>veac087</elocation-id><pub-id pub-id-type="pmcid">PMC9615429</pub-id><pub-id pub-id-type="pmid">36325032</pub-id><pub-id pub-id-type="doi">10.1093/ve/veac087</pub-id></element-citation></ref><ref id="R22"><label>[22]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Raita</surname><given-names>Y</given-names></name><name><surname>Péerez-Losada</surname><given-names>M</given-names></name><name><surname>Freishtat</surname><given-names>RJ</given-names></name><name><surname>Harmon</surname><given-names>B</given-names></name><name><surname>Mansbach</surname><given-names>JM</given-names></name><name><surname>Piedra</surname><given-names>PA</given-names></name><etal/></person-group><article-title>Integrated omics endotyping of infants with respiratory syncytial virus bronchiolitis and risk of childhood asthma</article-title><source>Nature communications</source><year>2021</year><volume>12</volume><issue>1</issue><elocation-id>3601</elocation-id><pub-id pub-id-type="pmcid">PMC8203688</pub-id><pub-id pub-id-type="pmid">34127671</pub-id><pub-id pub-id-type="doi">10.1038/s41467-021-23859-6</pub-id></element-citation></ref><ref id="R23"><label>[23]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fan</surname><given-names>J</given-names></name><name><surname>Huang</surname><given-names>S</given-names></name><name><surname>Chorlton</surname><given-names>SD</given-names></name></person-group><article-title>BugSeq: a highly accurate cloud platform for long-read metagenomic analyses</article-title><source>BMC bioinformatics</source><year>2021</year><volume>22</volume><fpage>1</fpage><lpage>12</lpage><pub-id pub-id-type="pmcid">PMC7993542</pub-id><pub-id pub-id-type="pmid">33765910</pub-id><pub-id pub-id-type="doi">10.1186/s12859-021-04089-5</pub-id></element-citation></ref><ref id="R24"><label>[24]</label><element-citation publication-type="web"><person-group person-group-type="author"><name><surname>Odom-Mabey</surname><given-names>A</given-names></name><name><surname>Varki</surname><given-names>R</given-names></name><name><surname>Johnson</surname><given-names>WE</given-names></name></person-group><source>MetaScope: Tools and functions for preprocessing 16S and metagenomic sequencing microbiome data</source><comment>R package version 0.99.12. Available from: https://github.com/compbiomed/metascopehttps://compbiomed.github.io/metascope-docs/</comment></element-citation></ref><ref id="R25"><label>[25]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Simon</surname><given-names>HY</given-names></name><name><surname>Siddle</surname><given-names>KJ</given-names></name><name><surname>Park</surname><given-names>DJ</given-names></name><name><surname>Sabeti</surname><given-names>PC</given-names></name></person-group><article-title>Benchmarking metagenomics tools for taxonomic classification</article-title><source>Cell</source><year>2019</year><volume>178</volume><issue>4</issue><fpage>779</fpage><lpage>794</lpage><pub-id pub-id-type="pmcid">PMC6716367</pub-id><pub-id pub-id-type="pmid">31398336</pub-id><pub-id pub-id-type="doi">10.1016/j.cell.2019.07.010</pub-id></element-citation></ref><ref id="R26"><label>[26]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Almodaresi</surname><given-names>F</given-names></name><name><surname>Zakeri</surname><given-names>M</given-names></name><name><surname>Patro</surname><given-names>R</given-names></name></person-group><article-title>PuffAligner: a fast, efficient and accurate aligner based on the Pufferfish index</article-title><source>Bioinformatics</source><year>2021</year><volume>37</volume><issue>22</issue><fpage>4048</fpage><lpage>4055</lpage><pub-id pub-id-type="pmcid">PMC9502150</pub-id><pub-id pub-id-type="pmid">34117875</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btab408</pub-id></element-citation></ref><ref id="R27"><label>[27]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lee</surname><given-names>I</given-names></name><name><surname>Ouk Kim</surname><given-names>Y</given-names></name><name><surname>Park</surname><given-names>SC</given-names></name><name><surname>Chun</surname><given-names>J</given-names></name></person-group><article-title>OrthoANI: an improved algorithm and software for calculating average nucleotide identity</article-title><source>International journal of systematic and evolutionary microbiology</source><year>2016</year><volume>66</volume><issue>2</issue><fpage>1100</fpage><lpage>1103</lpage><pub-id pub-id-type="pmid">26585518</pub-id></element-citation></ref><ref id="R28"><label>[28]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mende</surname><given-names>DR</given-names></name><name><surname>Waller</surname><given-names>AS</given-names></name><name><surname>Sunagawa</surname><given-names>S</given-names></name><name><surname>Jarvelin</surname><given-names>AI</given-names></name><name><surname>Chan</surname><given-names>MM</given-names></name><name><surname>Arumugam</surname><given-names>M</given-names></name><etal/></person-group><article-title>Assessment of metagenomic assembly using simulated next generation sequencing data</article-title><source>PloS one</source><year>2012</year><volume>7</volume><issue>2</issue><elocation-id>e31386</elocation-id><pub-id pub-id-type="pmcid">PMC3285633</pub-id><pub-id pub-id-type="pmid">22384016</pub-id><pub-id pub-id-type="doi">10.1371/journal.pone.0031386</pub-id></element-citation></ref><ref id="R29"><label>[29]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wick</surname><given-names>RR</given-names></name></person-group><article-title>Badread: simulation of error-prone long reads</article-title><source>Journal of Open Source Software</source><year>2019</year><volume>4</volume><issue>36</issue><fpage>1316</fpage></element-citation></ref><ref id="R30"><label>[30]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Shaw</surname><given-names>J</given-names></name><name><surname>Yu</surname><given-names>YW</given-names></name></person-group><article-title>Fast and robust metagenomic sequence comparison through sparse chaining with skani</article-title><source>bioRxiv</source><year>2023</year><elocation-id>2023-01</elocation-id></element-citation></ref><ref id="R31"><label>[31]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Koster</surname><given-names>J</given-names></name><name><surname>Rahmann</surname><given-names>S</given-names></name></person-group><article-title>Snakemake—a scalable bioinformatics workflow engine</article-title><source>Bioinformatics</source><year>2012</year><volume>28</volume><issue>19</issue><fpage>2520</fpage><lpage>2522</lpage><pub-id pub-id-type="pmid">22908215</pub-id></element-citation></ref><ref id="R32"><label>[32]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>B</given-names></name><name><surname>Dewey</surname><given-names>CN</given-names></name></person-group><article-title>RSEM: accurate transcript quantification from RNA-Seq data with or without a reference genome</article-title><source>BMC bioinformatics</source><year>2011</year><volume>12</volume><fpage>1</fpage><lpage>16</lpage><pub-id pub-id-type="pmcid">PMC3163565</pub-id><pub-id pub-id-type="pmid">21816040</pub-id><pub-id pub-id-type="doi">10.1186/1471-2105-12-323</pub-id></element-citation></ref><ref id="R33"><label>[33]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Andersen</surname><given-names>AC</given-names></name><name><surname>Pavlikov</surname><given-names>K</given-names></name><name><surname>Toffolo</surname><given-names>TA</given-names></name></person-group><article-title>Weapon-target assignment problem: Exact and approximate solution algorithms</article-title><source>Annals of Operations Research</source><year>2022</year><volume>312</volume><issue>2</issue><fpage>581</fpage><lpage>606</lpage></element-citation></ref><ref id="R34"><label>[34]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Huang</surname><given-names>W</given-names></name><name><surname>Li</surname><given-names>L</given-names></name><name><surname>Myers</surname><given-names>JR</given-names></name><name><surname>Marth</surname><given-names>GT</given-names></name></person-group><article-title>ART: a next-generation sequencing read simulator</article-title><source>Bioinformatics</source><year>2012</year><volume>28</volume><issue>4</issue><fpage>593</fpage><lpage>594</lpage><pub-id pub-id-type="pmcid">PMC3278762</pub-id><pub-id pub-id-type="pmid">22199392</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btr708</pub-id></element-citation></ref></ref-list></back><floats-group><fig id="F1" position="float"><label>Fig. 1</label><caption><title>The pipeline for Mora to output re-assignments from query and reference FASTA files.</title><p>Mora’s processing steps are enclosed by the dark green rectangle. The abundance estimation step includes the Expectation Maximization (EM) algorithm and a set cover algorithm to filter out spuriously abundant genomes [<xref ref-type="bibr" rid="R17">17</xref>]. The reassignment step uses the estimated abundance from the previous step to re-assign reads.</p></caption><graphic xlink:href="EMS179827-f001"/></fig><fig id="F2" position="float"><label>Fig. 2</label><caption><title>An example of Mora’s approach to read re-assignment.</title><p>The exact algorithm is outlined in Section 3.3. R1-R4 are four reference genomes labelled with colours, and the 8 reads shown have colour content proportional to the mapping scores with respect to each coloured reference genome. Grey boxes are not reads, but available read assignments based on Mora’s estimated abundances. Step 1: Assigning reads based on highest mapping scores leads to invalid assignments, since R4 can only store 1 read based on the abundance constraint. Step 2: we move a more ambiguously assigned read in R2 to R3 instead, opening space in R2. Step 3: We move the multi-assigned read in R4 to R2, where there is now space.</p></caption><graphic xlink:href="EMS179827-f002"/></fig><fig id="F3" position="float"><label>Fig. 3</label><caption><title>Relative assignment abundancies of Mora, AugPatho2, and Pufferfish of 950,000 synthetic short 150bp pair-end reads to 58 E. coli strains.</title><p>The synthetic short reads were simulated from the three E. coli strains: 2009C-3133, SQ110, and C43(DE3). The strains listed had at least 2000 assigned reads from at least one of the algorithms. Relative assignment percentages of the final assignments from three different algorithms are represented by the different coloured bars. The real abundance levels of the strains are represented by the red dots. AugPatho2 is Pathoscope2 but with slight changes in the code to make it able to run and output results. Assignment by Pufferfish and Bowtie2 were done by choosing the primary alignment in the SAM file, while assignment by Mora and AugPatho2 was done using Pufferfish as the initial aligner. Clark and Bowtie2 were run without any additional algorithms. Mora’s assignments are closest to the real abundancies.</p></caption><graphic xlink:href="EMS179827-f003"/></fig><fig id="F4" position="float"><label>Fig. 4</label><caption><p>Comparison of assignment percentages of real short E. coli reads from the three assemblies: INF32/16/A, INF13/18/A, and INF191/17/A by Mora, AugPatho2, and the initial aligner Bowtie2. The real abundance levels of the strains are represented by the red dots. Mora assigns a lot more reads to the INF assemblies compared to AugPatho2 and Bowtie2.</p></caption><graphic xlink:href="EMS179827-f004"/></fig><fig id="F5" position="float"><label>Fig. 5</label><caption><title>Final abundances of Mora, AugPatho2, and Minimap2 of covid-19 samples.</title><p>Long PacBio Covid-19 reads were from 48 individuals from Kentucky, USA published in June 2021. All algorithms assign most of the reads to the Alpha strain, which based on time and location is the most likely strain, with Mora assigning the most.</p></caption><graphic xlink:href="EMS179827-f005"/></fig><table-wrap id="T1" position="float" orientation="portrait"><label>Table 1</label><caption><title>Wall clock time (s) and maximum RAM usage (GB) for algorithms on aligning simulated short reads (SR)</title></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle"> </th><th align="center" valign="middle" colspan="2" style="border-bottom: 1px solid">SR to REF-1</th><th align="center" valign="middle" colspan="2" style="border-bottom: 1px solid">SR to REF-2</th></tr><tr><th align="left" valign="middle">Algorithm</th><th align="left" valign="middle">Time(s)</th><th align="left" valign="middle">RAM(GB)</th><th align="left" valign="middle">Time(s)</th><th align="left" valign="middle">RAM(GB)</th></tr></thead><tbody><tr><td align="center" valign="middle">Mora</td><td align="left" valign="middle">381.48</td><td align="left" valign="middle">47.04</td><td align="left" valign="middle">514.30</td><td align="left" valign="middle">46.16</td></tr><tr style="border-bottom: 1px solid"><td align="center" valign="middle">AugPatho2</td><td align="left" valign="middle">28103.34</td><td align="left" valign="middle">51.58</td><td align="left" valign="middle">28111.39</td><td align="left" valign="middle">15.99</td></tr><tr><td align="center" valign="middle">Pufferfish</td><td align="left" valign="middle">89.70</td><td align="left" valign="middle">6.791</td><td align="left" valign="middle">273.22</td><td align="left" valign="middle">8.388</td></tr><tr style="border-bottom: 1px solid"><td align="center" valign="middle">Bowtie2</td><td align="left" valign="middle">490.55</td><td align="left" valign="middle">1.591</td><td align="left" valign="middle">753.09</td><td align="left" valign="middle">21.265</td></tr><tr><td align="center" valign="middle">Kraken2</td><td align="left" valign="middle">73.48</td><td align="left" valign="middle">2.40</td><td align="left" valign="middle">70.54</td><td align="left" valign="middle">24.33</td></tr><tr><td align="center" valign="middle">Clark</td><td align="left" valign="middle">222.25</td><td align="left" valign="middle">41.09</td><td align="left" valign="middle">311.63</td><td align="left" valign="middle">91.10</td></tr></tbody></table><table-wrap-foot><fn id="TFN1"><p id="P66">Other than using more RAM on short reads to REF-2, Mora consistently used fewer resources than AugPatho2 and was substantially faster. Time cannot be directly compared between the Mora/AugPatho2 and Kraken/Clark as they require the output from one of the initial aligners. CPU time and other information can be found in appendix table A.4. All algorithms were run with 8 threads on a Ubuntu 20.04.4 LTS server with an AMD Ryzen 3970X 32-core CPU with 256 GB of RAM.</p></fn></table-wrap-foot></table-wrap><table-wrap id="T2" position="float" orientation="portrait"><label>Table 2</label><caption><title>Wall clock time (s) and maximum RAM usage (GB) for algorithms on aligning simulated long reads (LR)</title></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="middle"> </th><th align="center" valign="middle" colspan="2" style="border-bottom: 1px solid">LR to REF-1</th><th align="center" valign="middle" colspan="2" style="border-bottom: 1px solid">LR to REF-2</th></tr><tr><th align="left" valign="middle">Algorithm</th><th align="left" valign="middle">Time(s)</th><th align="left" valign="middle">RAM(GB)</th><th align="left" valign="middle">Time(s)</th><th align="left" valign="middle">RAM(GB)</th></tr></thead><tbody><tr><td align="center" valign="middle">Mora</td><td align="left" valign="middle">62.91</td><td align="left" valign="middle"><bold>0.78</bold></td><td align="left" valign="middle">23.42</td><td align="left" valign="middle"><bold>1.83</bold></td></tr><tr style="border-bottom: 1px solid"><td align="center" valign="middle">AugPatho2</td><td align="left" valign="middle">341.93</td><td align="left" valign="middle">21.51</td><td align="left" valign="middle">429.23</td><td align="left" valign="middle">22.522</td></tr><tr style="border-bottom: 1px solid"><td align="center" valign="middle">Minimap2</td><td align="left" valign="middle">1074.89</td><td align="left" valign="middle">11.228</td><td align="left" valign="middle">8696.29</td><td align="left" valign="middle">20.048</td></tr><tr><td align="center" valign="middle">Kraken2</td><td align="left" valign="middle">193.08</td><td align="left" valign="middle">2.58</td><td align="left" valign="middle">326.09</td><td align="left" valign="middle">25.01</td></tr><tr><td align="center" valign="middle">Clark</td><td align="left" valign="middle">521.64</td><td align="left" valign="middle">74.43</td><td align="left" valign="middle">1043.08</td><td align="left" valign="middle">124.26</td></tr></tbody></table><table-wrap-foot><fn id="TFN2"><p id="P67">Mora used significantly fewer resources than AugPatho2 and was substantially faster. Time and RAM cannot be directly compared between the Mora/AugPatho2 and Kraken/Clark as Mora and AugPatho2 requires Minimap2 to give them an output file. CPU time and other information can be found in appendix table A.4. All algorithms were run with 8 threads on a Ubuntu 20.04.4 LTS server with an AMD Ryzen 3970X 32-core CPU with 256 GB of RAM.</p></fn></table-wrap-foot></table-wrap><table-wrap id="T3" position="float" orientation="portrait"><label>Table 3</label><caption><title>Scores of algorithms when aligning short reads to REF-1</title></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="middle"> </th><th align="center" valign="middle" colspan="3" style="border-bottom: 1px solid">Strain</th><th align="center" valign="middle" colspan="3" style="border-bottom: 1px solid">Species</th><th align="left" valign="middle" colspan="3" style="border-bottom: 1px solid">Genus</th></tr><tr style="border-bottom: 1px solid"><th align="left" valign="middle">Algorithm</th><th align="left" valign="middle">Fl</th><th align="left" valign="middle">Sensitivity</th><th align="left" valign="middle">Precision</th><th align="left" valign="middle">Fl</th><th align="left" valign="middle">Sensitivity</th><th align="left" valign="middle">Precision</th><th align="left" valign="middle">Fl</th><th align="left" valign="middle">Sensitivity</th><th align="left" valign="middle">Precision</th></tr></thead><tbody><tr><td align="center" valign="middle">Pufferfish</td><td align="left" valign="middle">60.58</td><td align="left" valign="middle">44.05</td><td align="left" valign="middle">96.94</td><td align="left" valign="middle">59.17</td><td align="left" valign="middle">42.53</td><td align="left" valign="middle">97.19</td><td align="left" valign="middle">65.00</td><td align="left" valign="middle">48.19</td><td align="left" valign="middle">99.80</td></tr><tr><td align="center" valign="middle">Mora + Pufferfish</td><td align="left" valign="middle">63.51</td><td align="left" valign="middle">47.21</td><td align="left" valign="middle">97.02</td><td align="left" valign="middle">59.22</td><td align="left" valign="middle">42.56</td><td align="left" valign="middle">97.27</td><td align="left" valign="middle">65.00</td><td align="left" valign="middle">48.21</td><td align="left" valign="middle">99.83</td></tr><tr style="border-bottom: 1px solid"><td align="center" valign="middle">AugPatho2 + Pufferfish</td><td align="left" valign="middle">63.55</td><td align="left" valign="middle">47.24</td><td align="left" valign="middle">97.07</td><td align="left" valign="middle">59.23</td><td align="left" valign="middle">42.57</td><td align="left" valign="middle">97.29</td><td align="left" valign="middle">65.02</td><td align="left" valign="middle">48.21</td><td align="left" valign="middle">99.83</td></tr><tr><td align="center" valign="middle">Bowtie2</td><td align="left" valign="middle">83.13</td><td align="left" valign="middle">74.29</td><td align="left" valign="middle">94.36</td><td align="left" valign="middle">78.31</td><td align="left" valign="middle">66.87</td><td align="left" valign="middle">94.46</td><td align="left" valign="middle">87.25</td><td align="left" valign="middle">77.71</td><td align="left" valign="middle">99.46</td></tr><tr><td align="center" valign="middle">Mora + Bowtie2</td><td align="left" valign="middle">85.41</td><td align="left" valign="middle">76.33</td><td align="left" valign="middle">96.95</td><td align="left" valign="middle">80.56</td><td align="left" valign="middle">68.79</td><td align="left" valign="middle">97.18</td><td align="left" valign="middle">87.53</td><td align="left" valign="middle">77.96</td><td align="left" valign="middle">99.77</td></tr><tr style="border-bottom: 1px solid"><td align="center" valign="middle">AugPatho2 + Bowtie2</td><td align="left" valign="middle"><bold>90.21</bold></td><td align="left" valign="middle"><bold>84.22</bold></td><td align="left" valign="middle">97.12</td><td align="left" valign="middle"><bold>85.33</bold></td><td align="left" valign="middle"><bold>75.93</bold></td><td align="left" valign="middle">97.39</td><td align="left" valign="middle">92.31</td><td align="left" valign="middle"><bold>85.87</bold></td><td align="left" valign="middle"><bold>99.79</bold></td></tr><tr><td align="center" valign="middle">Kraken2</td><td align="left" valign="middle">NA</td><td align="left" valign="middle">NA</td><td align="left" valign="middle">NA</td><td align="left" valign="middle">0.29</td><td align="left" valign="middle">0.27</td><td align="left" valign="middle">0.33</td><td align="left" valign="middle">87.17</td><td align="left" valign="middle">79.26</td><td align="left" valign="middle">96.84</td></tr><tr style="border-bottom: 1px solid"><td align="center" valign="middle">Clark</td><td align="left" valign="middle">86.88</td><td align="left" valign="middle">78.10</td><td align="left" valign="middle"><bold>97.87</bold></td><td align="left" valign="middle">82.82</td><td align="left" valign="middle">71.46</td><td align="left" valign="middle"><bold>98.47</bold></td><td align="left" valign="middle"><bold>97.85</bold></td><td align="left" valign="middle">78.68</td><td align="left" valign="middle">99.46</td></tr></tbody></table><table-wrap-foot><fn id="TFN3"><p id="P68">Both Mora and AugPatho2 were able to improve the scores of the initial aligner, though AugPatho2 appears to have a slight systematic edge.</p></fn></table-wrap-foot></table-wrap><table-wrap id="T4" position="float" orientation="portrait"><label>Table 4</label><caption><title>Scores of algorithms when aligning short reads to REF-2</title></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle"> </th><th align="left" valign="middle" colspan="3" style="border-bottom: 1px solid">Species</th><th align="left" valign="middle" colspan="3" style="border-bottom: 1px solid">Genus</th></tr><tr style="border-bottom: 1px solid"><th align="center" valign="middle">Algorithm</th><th align="left" valign="middle">F1</th><th align="left" valign="middle">Sensitivity</th><th align="left" valign="middle">Precision</th><th align="left" valign="middle">F1</th><th align="left" valign="middle">Sensitivity</th><th align="left" valign="middle">Precision</th></tr></thead><tbody><tr><td align="center" valign="middle">Pufferfish</td><td align="left" valign="middle">26.32</td><td align="left" valign="middle">16.56</td><td align="left" valign="middle"><bold>64.14</bold></td><td align="left" valign="middle">40.32</td><td align="left" valign="middle">25.55</td><td align="left" valign="middle">92.08</td></tr><tr><td align="center" valign="middle">Mora + Pufferfish</td><td align="left" valign="middle">34.73</td><td align="left" valign="middle">24.10</td><td align="left" valign="middle">62.15</td><td align="left" valign="middle">54.44</td><td align="left" valign="middle">38.26</td><td align="left" valign="middle">94.34</td></tr><tr style="border-bottom: 1px solid"><td align="center" valign="middle">AugPatho2 + Pufferfish</td><td align="left" valign="middle">35.59</td><td align="left" valign="middle">24.70</td><td align="left" valign="middle">63.69</td><td align="left" valign="middle">54.97</td><td align="left" valign="middle">38.62</td><td align="left" valign="middle">95.26</td></tr><tr><td align="center" valign="middle">Bowtie2</td><td align="left" valign="middle">44.51</td><td align="left" valign="middle">35.55</td><td align="left" valign="middle">59.52</td><td align="left" valign="middle">71.83</td><td align="left" valign="middle">58.22</td><td align="left" valign="middle">93.73</td></tr><tr><td align="center" valign="middle">Mora + Bowtie2</td><td align="left" valign="middle">46.54</td><td align="left" valign="middle">37.17</td><td align="left" valign="middle">62.23</td><td align="left" valign="middle">72.42</td><td align="left" valign="middle">58.71</td><td align="left" valign="middle"><bold>94.51</bold></td></tr><tr style="border-bottom: 1px solid"><td align="center" valign="middle">AugPatho2 + Bowtie2</td><td align="left" valign="middle">39.14</td><td align="left" valign="middle">28.79</td><td align="left" valign="middle">61.11</td><td align="left" valign="middle">62.72</td><td align="left" valign="middle">46.98</td><td align="left" valign="middle">94.28</td></tr><tr><td align="center" valign="middle">Kraken2</td><td align="left" valign="middle">14.95</td><td align="left" valign="middle">13.03</td><td align="left" valign="middle">17.53</td><td align="left" valign="middle"><bold>78.51</bold></td><td align="left" valign="middle"><bold>68.42</bold></td><td align="left" valign="middle">92.08</td></tr><tr><td align="center" valign="middle">Clark</td><td align="left" valign="middle"><bold>49.89</bold></td><td align="left" valign="middle"><bold>40.94</bold></td><td align="left" valign="middle">63.85</td><td align="left" valign="middle">69.65</td><td align="left" valign="middle">59.10</td><td align="left" valign="middle">86.94</td></tr></tbody></table><table-wrap-foot><fn id="TFN4"><p id="P69">When using Bowtie2, Mora performed substantially better than AugPatho2, but was still slightly worse than Clark. Kraken2 had very low scores at the species level but had better scores at the genus level. Kraken2 and Clark were both able to map more reads compared to Mora and AugPatho2 due to mapping more reads than Pufferfish and Bowtie2. The specific number of reads mapped correctly can be found in appendix table A.6.</p></fn></table-wrap-foot></table-wrap><table-wrap id="T5" position="float" orientation="portrait"><label>Table 5</label><caption><title>Scores between Minimap2, Mora, AugPatho2, Kraken2, and Clark when aligning long simulated reads to REF-1</title></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle"> </th><th align="center" valign="middle" colspan="3" style="border-bottom: 1px solid">Strain</th><th align="center" valign="middle" colspan="3" style="border-bottom: 1px solid">Species</th><th align="center" valign="middle" colspan="3" style="border-bottom: 1px solid">Genus</th></tr><tr><th align="center" valign="middle">Algorithm</th><th align="left" valign="middle">Fl</th><th align="left" valign="middle">Sensitivity</th><th align="left" valign="middle">Precision</th><th align="left" valign="middle">Fl</th><th align="left" valign="middle">Sensitivity</th><th align="left" valign="middle">Precision</th><th align="left" valign="middle">Fl</th><th align="left" valign="middle">Sensitivity</th><th align="left" valign="middle">Precision</th></tr></thead><tbody><tr><td align="center" valign="middle">Minimap2</td><td align="left" valign="middle">94.76</td><td align="left" valign="middle">93.22</td><td align="left" valign="middle">96.34</td><td align="left" valign="middle">90.15</td><td align="left" valign="middle">84.62</td><td align="left" valign="middle">96.46</td><td align="left" valign="middle">97.42</td><td align="left" valign="middle">95.45</td><td align="left" valign="middle">99.48</td></tr><tr><td align="center" valign="middle">Mora</td><td align="left" valign="middle"><bold>97.61</bold></td><td align="left" valign="middle"><bold>96.03</bold></td><td align="left" valign="middle"><bold>99.24</bold></td><td align="left" valign="middle"><bold>92.97</bold></td><td align="left" valign="middle"><bold>87.26</bold></td><td align="left" valign="middle"><bold>99.47</bold></td><td align="left" valign="middle"><bold>99.45</bold></td><td align="left" valign="middle"><bold>95.48</bold></td><td align="left" valign="middle"><bold>99.51</bold></td></tr><tr style="border-bottom: 1px solid"><td align="center" valign="middle">AugPatho2</td><td align="left" valign="middle">96.10</td><td align="left" valign="middle">94.49</td><td align="left" valign="middle">97.77</td><td align="left" valign="middle">91.41</td><td align="left" valign="middle">85.74</td><td align="left" valign="middle">97.88</td><td align="left" valign="middle">97.37</td><td align="left" valign="middle">95.34</td><td align="left" valign="middle">99.51</td></tr><tr><td align="center" valign="middle">Kraken2</td><td align="left" valign="middle">NA</td><td align="left" valign="middle">NA</td><td align="left" valign="middle">NA</td><td align="left" valign="middle">0.277</td><td align="left" valign="middle">0.262</td><td align="left" valign="middle">0.295</td><td align="left" valign="middle">88.824</td><td align="left" valign="middle">83.803</td><td align="left" valign="middle">94.485</td></tr><tr><td align="center" valign="middle">Clark</td><td align="left" valign="middle">87.50</td><td align="left" valign="middle">82.03</td><td align="left" valign="middle">93.75</td><td align="left" valign="middle">84.39</td><td align="left" valign="middle">75.64</td><td align="left" valign="middle">95.43</td><td align="left" valign="middle">89.92</td><td align="left" valign="middle">83.65</td><td align="left" valign="middle">97.20</td></tr></tbody></table><table-wrap-foot><fn id="TFN5"><p id="P70">Both Mora and AugPatho2 increase the scores of Minimap2, but Mora is slightly outperforming AugPatho2.</p></fn></table-wrap-foot></table-wrap><table-wrap id="T6" position="float" orientation="portrait"><label>Table 6</label><caption><title>Scores between Minimap2, Mora, AugPatho2, Kraken2, and Clark when aligning long simulated reads to REF-2</title></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle"> </th><th align="center" valign="middle" colspan="3" style="border-bottom: 1px solid">Species</th><th align="center" valign="middle" colspan="3" style="border-bottom: 1px solid">Genus</th></tr><tr><th align="center" valign="middle">Algorithm</th><th align="center" valign="middle">F1</th><th align="center" valign="middle">Sensitivity</th><th align="center" valign="middle">Precision</th><th align="center" valign="middle">F1</th><th align="center" valign="middle">Sensitivity</th><th align="center" valign="middle">Precision</th></tr></thead><tbody><tr><td align="center" valign="middle">Minimap2</td><td align="left" valign="middle">52.02</td><td align="left" valign="middle">46.60</td><td align="left" valign="middle">58.86</td><td align="left" valign="middle">83.60</td><td align="left" valign="middle">77.74</td><td align="left" valign="middle">90.42</td></tr><tr><td align="center" valign="middle">Mora</td><td align="left" valign="middle">53.84</td><td align="left" valign="middle">48.23</td><td align="left" valign="middle">60.92</td><td align="left" valign="middle">84.64</td><td align="left" valign="middle">70.70</td><td align="left" valign="middle">91.55</td></tr><tr style="border-bottom: 1px solid"><td align="center" valign="middle">AugPatho2</td><td align="left" valign="middle"><bold>54.30</bold></td><td align="left" valign="middle"><bold>48.31</bold></td><td align="left" valign="middle"><bold>61.97</bold></td><td align="left" valign="middle"><bold>85.40</bold></td><td align="left" valign="middle"><bold>78.78</bold></td><td align="left" valign="middle"><bold>93.23</bold></td></tr><tr><td align="center" valign="middle">Kraken2</td><td align="left" valign="middle">16.45</td><td align="left" valign="middle">15.39</td><td align="left" valign="middle">17.66</td><td align="left" valign="middle">79.56</td><td align="left" valign="middle">74.43</td><td align="left" valign="middle">85.47</td></tr><tr><td align="center" valign="middle">Clark</td><td align="left" valign="middle">49.78</td><td align="left" valign="middle">43.17</td><td align="left" valign="middle">58.78</td><td align="left" valign="middle">73.37</td><td align="left" valign="middle">65.66</td><td align="left" valign="middle">83.12</td></tr></tbody></table><table-wrap-foot><fn id="TFN6"><p id="P71">Both Mora and AugPatho2 increase the scores of Minimap2, but AugPatho2 is slightly outperforming Mora.</p></fn></table-wrap-foot></table-wrap></floats-group></article>