<!DOCTYPE article
 PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2 20190208//EN" "JATS-archivearticle1.dtd">
<article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="preprint"><?all-math-mml yes?><?use-mml?><?origin ukpmcpa?><front><journal-meta><journal-id journal-id-type="nlm-ta">bioRxiv</journal-id><journal-title-group><journal-title>bioRxiv : the preprint server for biology</journal-title></journal-title-group><issn pub-type="epub">2692-8205</issn></journal-meta><article-meta><article-id pub-id-type="manuscript">EMS198840</article-id><article-id pub-id-type="doi">10.1101/2022.10.18.512737</article-id><article-id pub-id-type="archive">PPR562391</article-id><article-version-alternatives><article-version article-version-type="status">preprint</article-version><article-version article-version-type="number">2</article-version></article-version-alternatives><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Filtered finite state projection method for the analysis and estimation of stochastic biochemical reaction networks</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>D’Ambrosio</surname><given-names>Elena</given-names></name><xref ref-type="aff" rid="A1">1</xref></contrib><contrib contrib-type="author"><name><surname>Fang</surname><given-names>Zhou</given-names></name><xref ref-type="aff" rid="A1">1</xref></contrib><contrib contrib-type="author"><name><surname>Gupta</surname><given-names>Ankit</given-names></name><xref ref-type="aff" rid="A1">1</xref></contrib><contrib contrib-type="author"><name><surname>Kumar</surname><given-names>Sant</given-names></name><xref ref-type="aff" rid="A1">1</xref></contrib><contrib contrib-type="author"><name><surname>Khammash</surname><given-names>Mustafa</given-names></name><xref ref-type="aff" rid="A1">1</xref><xref ref-type="corresp" rid="CR1">*</xref></contrib></contrib-group><aff id="A1"><label>1</label>Department of Biosystems Science and Engineering, <institution-wrap><institution-id institution-id-type="ror">https://ror.org/05a28rw58</institution-id><institution>ETH Zurich</institution></institution-wrap>, <city>Basel</city>, <country country="CH">Switzerland</country></aff><author-notes><corresp id="CR1">
<label>*</label><email>mustafa.khammash@bsse.ethz.ch</email></corresp></author-notes><pub-date pub-type="nihms-submitted"><day>22</day><month>09</month><year>2024</year></pub-date><pub-date pub-type="preprint"><day>20</day><month>09</month><year>2024</year></pub-date><permissions><ali:free_to_read/><license><ali:license_ref>https://creativecommons.org/licenses/by-nc-nd/4.0/</ali:license_ref><license-p>This work is licensed under a <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0 International license</ext-link>.</license-p></license></permissions><abstract><p id="P1">Time-lapse microscopy has become increasingly prevalent in biological experimentation, as it provides single-cell trajectories that unveil valuable insights into underlying networks and their stochastic dynamics. However, the limited availability of fluorescent reporters typically constrains tracking to only a few network species. Addressing this challenge, the dynamic estimation of hidden state-components becomes crucial, for which stochastic filtering presents a robust mathematical framework. Yet, the complexity of biological networks often renders direct solutions to the filtering equation intractable due to high dimensionality and nonlinear interactions.</p><p id="P2">In this study, we establish and rigorously prove the well-posedness of the filtering equation for the time-evolution of the conditional distribution of hidden species. Focusing on continuous-time, noise-free observations within a continuous-time discrete state-space Markov chain model, we develop the Filtered Finite State Projection (FFSP) method. This computational approach offers an approximated solution by truncating the hidden species’ state space, accompanied by computable error bounds. We illustrate the effectiveness of FFSP through diverse numerical examples, comparing it with established filtering techniques such as the Kalman filter, Extended Kalman filter, and particle filter. Finally, we show an application of our methodology with real time-lapse microscopy data. This work not only advances the application of stochastic filtering to biological systems but also contributes towards more accurate implementation of biomolecular feedback controllers.</p></abstract></article-meta></front><body><sec id="S1" sec-type="intro"><label>1</label><title>Introduction</title><p id="P3">The genetics revolution of the 20<sup>th</sup> century significantly impacted various foundational aspects of biological sciences. A landmark event during this era was the discovery of Green Fluorescent Protein in 1962, which spurred the development of fluorescent technologies [<xref ref-type="bibr" rid="R1">1</xref>] and microscopic techniques [<xref ref-type="bibr" rid="R2">2</xref>]. These innovations greatly enhanced scientists’ ability to observe the dynamic behaviors of living cells. However, despite these technological advances, tracking capabilities are still limited to a few cellular components, such as fluorescent proteins and mRNAs [<xref ref-type="bibr" rid="R3">3</xref>–<xref ref-type="bibr" rid="R5">5</xref>]. Consequently, critical dynamic states like gene activation, transcription factors, and promoter activities remain elusive and poorly understood.</p><p id="P4">Moreover, the inherently stochastic interactions among biomolecular species within cells, especially at low concentrations, add layers of complexity to understanding these biological systems [<xref ref-type="bibr" rid="R6">6</xref>–<xref ref-type="bibr" rid="R8">8</xref>]. This stochasticity at the gene expression level introduces significant phenotypic variability even among genetically identical cells [<xref ref-type="bibr" rid="R9">9</xref>, <xref ref-type="bibr" rid="R10">10</xref>], which is crucial for understanding cellular decision-making processes [<xref ref-type="bibr" rid="R11">11</xref>]. To fully characterize the stochastic behaviour in living cells, the last decades have seen a surge of development in stochastic models and forward simulation techniques in biology [<xref ref-type="bibr" rid="R12">12</xref>–<xref ref-type="bibr" rid="R14">14</xref>].</p><p id="P5">One of the most common ways to model stochastic biochemical reaction processes is to employ a continuous-time Markov Chain (CTMC) with discrete state space which keeps track of the molecular species copy number over time. The states’ probability of this Markov Chain satisfies a very large or possibly infinite dimensional linear ordinary differential system of coupled equations, also known as the Chemical Master Equation (CME), that describe the chain’s state probabilities over time. One well-known numerical strategy for solving this extensive system is the finite state projection (FSP) method [<xref ref-type="bibr" rid="R15">15</xref>], which truncates the Markov Chain’s state space and gives rise to a finite-dimensional system for the evolution of state probabilities while providing an exact error certificate of the approximated solution.</p><p id="P6">In addition to this relatively direct approach, the CME can also be solved by simulation based approaches, like the Gillespie algorithm [<xref ref-type="bibr" rid="R14">14</xref>, <xref ref-type="bibr" rid="R16">16</xref>] and its variants [<xref ref-type="bibr" rid="R17">17</xref>, <xref ref-type="bibr" rid="R18">18</xref>], which exactly simulate the Markov chain model and approximate the probability distribution with the empirical distribution. However, these simulation-based approaches become computationally infeasible when the system size increases or several reactions are firing in a small time unit. Therefore, other approximations of the CME have become available. Some of these methods, such as the Chemical Langevin Equation and the Linear Noise Approximation (see [<xref ref-type="bibr" rid="R19">19</xref>] for a detailed reference), focus on approximating the underlying stochastic process of the CME with a continuous state process. Instead, other methods look at the CME solution statistics and provide moment closure techniques to close the moment equations [<xref ref-type="bibr" rid="R20">20</xref>–<xref ref-type="bibr" rid="R22">22</xref>].</p><p id="P7">Despite the availability of several approaches to approximate the CME’s solution, comparatively fewer computational methods exist for obtaining real-time estimations of latent cellular states as the observations arrive sequentially in time [<xref ref-type="bibr" rid="R23">23</xref>–<xref ref-type="bibr" rid="R28">28</xref>]. Experimentally, we can only observe certain chemical species, making it challenging to understand the hidden parts of the network that generated the observed data. Understanding the behaviour of the hidden species in relation to observed data through network simulation is typically computationally infeasible, and an inordinately large number of forward stochastic simulations would need to be generated to obtain a sample of trajectories that is consistent with observations.</p><p id="P8">Thus, it is more practical to use observed data as it arrives to predict hidden dynamics. Stochastic filtering offers a viable and accurate approach for reconstructing and understanding stochastic reaction networks beyond current experimental reach. In particular, stochastic filtering theory offers a robust framework for real-time estimation of latent states from time-course measurement data comprising of partial state observations. Specifically, it involves estimating the conditional probability distribution <italic>π<sub>t</sub></italic> of the latent state, modeled by a stochastic process <italic>X<sub>t</sub>,</italic> based on all available information up to time t. This information is typically encapsulated in a sigma-algebra generated by an observation process, denoted as <italic>Y<sub>t</sub>.</italic> The conditional probability π<sub>t</sub> usually satisfies a complex stochastic evolution equation known as the filtering equation, which is generally non-linear and infinite-dimensional [<xref ref-type="bibr" rid="R29">29</xref>].</p><p id="P9">The complexity and high-dimensionality of this equation pose significant challenges for real-time estimation of latent cellular states from time-course measurement data. Consequently, developing computational methods that address these challenges and reduce the computational time required for accurately solving the filtering equation is essential. This would facilitate real-time estimations of hidden cellular states, allowing for more effective experimental design. With real-time estimations, we could further explore poorly understood cellular functions, analyze the impact of noise on cellular regulation, and improve the design of biomolecular controllers, which hold tremendous potential for therapeutic applications [<xref ref-type="bibr" rid="R30">30</xref>].</p><p id="P10">One of the first pivotal advances in stochastic filtering has been the linear filter introduced by Kalman in the discrete-time setting [<xref ref-type="bibr" rid="R31">31</xref>]. The extension to the continuous-time case was given later by Bucy [<xref ref-type="bibr" rid="R32">32</xref>]. For linear dynamical systems corrupted with Gaussian noise, this linear filter provides an analytical expression for the conditional distribution, π<sub>t</sub>, which is Gaussian and therefore determined by its mean and covariance matrix. This Kalman-Bucy filter has been widely used in practical applications, including space missions like the Apollo project [<xref ref-type="bibr" rid="R33">33</xref>]. For the non-linear setting, the filtering equation (referred to as the Kushner-Stratonovich equation [<xref ref-type="bibr" rid="R34">34</xref>, <xref ref-type="bibr" rid="R35">35</xref>] in some cases) is generally infinite-dimensional [<xref ref-type="bibr" rid="R36">36</xref>]; an analytical expression of the solution is not always available. Facing this challenge, a surge of interest has occurred in particle filter methods since the seminal paper by Gordon, Salmond, and Smith [<xref ref-type="bibr" rid="R37">37</xref>]. The key feature of such methods is that finitely many random samples (or particles) are generated to represent the posterior probability distribution. These methods look promising and particularly suited to address the infinite-dimensional feature of filtering problems.</p><p id="P11">In the stochastic reaction networks framework, state and parameter estimations have been mainly carried out with the Kalman filter and particle filtering (also known as the sequential Monte-Carlo method). In [<xref ref-type="bibr" rid="R38">38</xref>], and [<xref ref-type="bibr" rid="R39">39</xref>], Sun et al. and Chuang et al. applied the Extended Kalman filter and the Kalman filter to non-linear state-space models of gene regulatory networks. Moreover, in [<xref ref-type="bibr" rid="R40">40</xref>], Calderazzo et al. used an Extended Kalman-Bucy filter to obtain parameters and state estimations in discrete-time of a stochastic negative feedback model. In [<xref ref-type="bibr" rid="R41">41</xref>], Liu et al. employ (i) extended Kalman filter (EKF), (ii) unscented Kalman filter (UKF) and (iii) the particle filter to estimate unobserved states of cellular responses in <italic>Escherichia Coli</italic> subjected to a sudden temperature increase. Moreover, in [<xref ref-type="bibr" rid="R42">42</xref>], and [<xref ref-type="bibr" rid="R43">43</xref>], Boys et al. and Golightly et al. applied sequential Monte-Carlo methods to diffusion approximations models of gene regulatory networks to infer kinetic parameters. Along these lines, Fang et al. [<xref ref-type="bibr" rid="R27">27</xref>, <xref ref-type="bibr" rid="R28">28</xref>, <xref ref-type="bibr" rid="R44">44</xref>] used a particle filter algorithm on a reduced model of a stochastic reaction network, derived through time-scale separation, rigorously showing that the filter of the original model converges to the one of the reduced model. In the context of noisy and discrete time observation processes, Huang et al. [<xref ref-type="bibr" rid="R25">25</xref>] derive the posterior master equation and approximate the infinite-dimensional moment dynamics, validating their method using both in silico data and single-cell data from two gene expression systems in <italic>Saccharomyces cerevisiae.</italic> For a noise-free observation process, in [<xref ref-type="bibr" rid="R45">45</xref>–<xref ref-type="bibr" rid="R47">47</xref>], Zechner et al. solved the filtering equation through a moment-closure approach. In the same setting, Rathinam et al. [<xref ref-type="bibr" rid="R26">26</xref>] proposed a bootstrap particle filtering (BPF) algorithm to solve numerous estimations problems in biologically relevant examples. In [<xref ref-type="bibr" rid="R23">23</xref>], Rathinam et al. develop a novel particle filtering method, called the targeting algorithm, to solve the stochastic filtering problem in the context of noise free discrete time observations.</p><p id="P12">The widespread adoption of traditional filtering techniques faces significant challenges due to their inherent limitations in scenarios in Biology that diverge from their core assumptions. The Kalman filter, which relies on assumptions of system linearity and Gaussian noise, often falls short in the complexities of real-world applications characterized by nonlinear dynamics and non-Gaussian disturbances. Consequently, the Extended Kalman Filter (EKF) was developed to improve modeling accuracy for nonlinear systems. However, both the Kalman filter and EKF exhibit difficulties in discrete-state processes with pronounced deviations from Gaussian noise, particularly in situations involving low copy numbers.</p><p id="P13">To address these challenges, we compared the performance of these conventional filters using a nonlinear chemical reaction network model with feedback (details in <xref ref-type="supplementary-material" rid="SD1">Section S4</xref> of the Supplementary Material), as depicted in panel (a) of <xref ref-type="fig" rid="F1">Fig. 1</xref>. This comparison assesses their effectiveness relative to a bootstrap particle filter (BPF) developed in [<xref ref-type="bibr" rid="R26">26</xref>] and the Filtered Finite State Projection (FFSP) method, the latter being a contribution of this article. In panel (d) of <xref ref-type="fig" rid="F1">Fig. 1</xref>, the SSA trajectory of the hidden processes (<italic>Z<sub>1</sub></italic> and <italic>Z<sub>2</sub></italic>) is presented alongside the conditional mean and standard deviations estimated by the various filters.</p><p id="P14">Given the observation process trajectory of <italic>X<sub>1</sub></italic> shown in panel (b) and the feedback structure presented in panel (c), it appears that the Kalman filter may struggle to accurately reconstruct the behavior of the hidden species. This is suggested by the fact that the trajectories of the hidden processes fall outside the one-interval standard deviation bands. In particular, the Kalman filter seems to have difficulty accounting for the roles of <italic>Z<sub>1</sub></italic> and <italic>Z<sub>2</sub></italic> in the initial sharp increase of <italic>X</italic><sub>1</sub>, possibly due to the highly nonlinear nature of the feedback.</p><p id="P15">However, the Extended Kalman filter, designed to overcome the nonlinearities inherent in the network, shows better performance in estimating the hidden species’ behavior, though a significant mismatch is observed for the hidden species <italic>Z<sub>2</sub></italic>. Specifically, the Extended Kalman filter provides negative estimates, likely due to a mismatch between the observation models. The EKF expects Gaussian-like observation noise suited to continuous state processes that can take both positive and negative values, while the Poisson-like noise in this context is designed for non-negative discrete state processes. Therefore, in the presence of strong nonlinearities and non-Gaussian noise, both the Kalman and Extended Kalman filters may not be suitable for predicting the hidden dynamics of discrete state processes.</p><p id="P16">In stark contrast, the particle filter and the FFSP method exhibit accuracy in predicting the hidden species’ behavior, affirming their effectiveness for nonlinear discrete stochastic systems affected by non-Gaussian noise. The FFSP, in particular, offers a valid alternative for the analysis of biological systems modeled as continuous-time Markov chains (CTMC).</p><p id="P17">However, as it can be seen in <xref ref-type="sec" rid="S10">Section 3.1.1</xref>, Kalman filter can still be a valuable resource for state estimation in scenarios of linear networks, no feedback, and an observation process with noise that approximates Gaussian noise close enough.</p><p id="P18">Moreover, while particle filters are known for their precision in estimating summary statistics of conditional distributions, their efficacy significantly diminishes when calculating specific event probabilities, especially for rare events. Our example, as highlighted in <xref ref-type="fig" rid="F2">Fig. 2</xref>, demonstrates that the bootstrap particle filter’s relative error [<xref ref-type="bibr" rid="R26">26</xref>] in estimating the low-probability event of the system being in state 0 in a very simple linear network remains substantial, irrespective of an increase in particle numbers, which consequently escalates computational demands. This observation underscores a critical limitation of particle filters, emphasizing the need for more sophisticated methodologies in scenarios dominated by rare events.</p><p id="P19">This discussion emphasizes the distinct challenges encountered by the Kalman, Extended Kalman, and particle filters and it also highlights why the FFSP method could be a valid alternative for modeling and estimation in complex biological systems.</p><p id="P20">In this paper, we concern ourselves with the situation of noise-free observations, which is reasonable given the significant advances in modern microscopy. In this setting, we first rigorously verified the validity of the continuous-time filtering equation, previously derived in [<xref ref-type="bibr" rid="R26">26</xref>, <xref ref-type="bibr" rid="R45">45</xref>, <xref ref-type="bibr" rid="R46">46</xref>]. The filtering equation has an unnormalized version, which resembles the CME very closely except for a jump term driven by the observation process. Inspired by this, we propose the Filtered Finite State Projection (FFSP) approach for the filtering problem by solving the unnormalized filtering equation on the truncated state space of the hidden species. Since the FFSP method solves the filtering equation in a direct fashion, it turns out to be more accurate than simulation-based particle filtering. We provide two different equivalent versions of the FFSP algorithm together with their error bounds. Finally, several biologically relevant numerical examples are presented to illustrate our approach.</p><p id="P21">The paper is organised as follows. First, we introduce our methods in the next section. Specifically, in <xref ref-type="sec" rid="S4">Section 2.1</xref> and <xref ref-type="sec" rid="S5">Section 2.2</xref>, we briefly review basic concepts of stochastic reaction networks and the associated stochastic filtering problem in the situation of continuous-time noise-free observations. In <xref ref-type="sec" rid="S6">Section 2.3</xref> we outline the Filtered Finite State Projection (FFSP) method together with its accuracy analysis, and in <xref ref-type="sec" rid="S7">Section 2.4</xref>, we propose an alternative FFSP algorithm with a tighter error bound but with more limited applicability. Then, in <xref ref-type="sec" rid="S8">Section 3</xref> we present several numerical examples in which we compare the performance of both the algorithms, compute the error bounds, and compare our algorithm with the bootstrap particle filter (BPF) algorithm available in [<xref ref-type="bibr" rid="R26">26</xref>] and the famous Kalman filter. In <xref ref-type="sec" rid="S20">Section 3.4</xref>, we evaluated our method using the telegraph model within a hybrid experimental framework, as detailed in [<xref ref-type="bibr" rid="R48">48</xref>]. Specifically, the transcription component of the circuit was operationalized in yeast cells [<xref ref-type="bibr" rid="R49">49</xref>], with mRNA molecules marked by fluorescent reporters. These trajectories were subsequently utilized to synthesize in silico SSA protein translation profiles. We employed these protein dynamics as observational data to infer mRNA trajectories using the FFSP. Our approach demonstrated high accuracy and closely aligned with the biological data, underscoring its effectiveness in practical biological applications. Finally, <xref ref-type="sec" rid="S21">Section 4</xref> concludes this paper.</p></sec><sec id="S2"><label>Notations</label><p id="P22">In this paper, we term <bold>0</bold> as a zero vector of a proper size and <inline-formula><mml:math id="M1"><mml:mrow><mml:mn>𝟙</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as the indicator function, which equals one if the argument holds and zero otherwise. <bold>1</bold> is a vector of ones of a proper size.</p></sec><sec id="S3" sec-type="materials | methods"><label>2</label><title>Materials and methods</title><sec id="S4"><label>2.1</label><title>Stochastic modelling of intracellular chemical reacting processes and their associated filtering problems</title><p id="P23">We consider an intracellular chemical reacting system that has <italic>n</italic> species (<italic>S</italic><sub>1</sub>,…,<italic>S<sub>n</sub></italic>) and <italic>M</italic> reactions: <disp-formula id="FD1"><mml:math id="M2"><mml:mrow><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:msub><mml:mi>ξ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>S</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mover><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:msubsup><mml:mi>ξ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msubsup><mml:msub><mml:mi>S</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mi>M</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula> where <italic>ξ<sub>ik</sub></italic> and <inline-formula><mml:math id="M3"><mml:mrow><mml:msubsup><mml:mi>ξ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> are the numbers of <italic>S<sub>i</sub></italic> molecules consumed and produced in the <italic>k</italic><sup>th</sup> reaction. We indicate with <italic>a</italic><sub>1</sub>, <italic>a</italic><sub>2</sub>,…<italic>a</italic><sub><italic>M</italic></sub> the propensity functions representing the rates of these M reactions. Moreover, we term <inline-formula><mml:math id="M4"><mml:mrow><mml:msub><mml:mi>ν</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>≜</mml:mo><mml:msubsup><mml:mi>ξ</mml:mi><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>−</mml:mo><mml:msub><mml:mi>ξ</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, as the stoichiometry vector associated with the <italic>k<sup>th</sup></italic> reaction channel and define the stoichiometry matrix as follows: <disp-formula id="FD2"><mml:math id="M5"><mml:mrow><mml:mi mathvariant="double-struck">S</mml:mi><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mo>∣</mml:mo></mml:mtd><mml:mtd/><mml:mtd><mml:mo>∣</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>ν</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mtd><mml:mtd><mml:mo>…</mml:mo></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>ν</mml:mi><mml:mi>M</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>∣</mml:mo></mml:mtd><mml:mtd/><mml:mtd><mml:mo>∣</mml:mo></mml:mtd></mml:mtr></mml:mtable><mml:mo>]</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P24">In the low copy number regime, the nature of the interactions among intracellular biomolecular species is inevitably stochastic, and its dynamics is usually modelled by a stochastic dynamic equation, known as the Random Time Change (RTC) representation [<xref ref-type="bibr" rid="R12">12</xref>]: <disp-formula id="FD3"><label>(1)</label><mml:math id="M6"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Z</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Z</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:munderover><mml:msub><mml:mi>ν</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mi>R</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>(</mml:mo><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>∫</mml:mo></mml:mstyle><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Z</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>s</mml:mi><mml:mo>)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P25">Here, <bold>Z</bold>(<italic>t</italic>) is a continuous-time discrete state Markov Chain keeping track of the molecules copy numbers, and <italic>R</italic><sub>1</sub>,…,<italic>R<sub>M</sub></italic> are independent unit rate Poisson processes, which count the firing events of every reaction. We only consider the processes <bold>Z</bold>(<italic>t</italic>) that satisfy the following non-explosivity condition: <disp-formula id="FD4"><label>(2)</label><mml:math id="M7"><mml:mrow><mml:munder><mml:mrow><mml:mi>sup</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:munder><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:munderover><mml:mi mathvariant="double-struck">E</mml:mi><mml:mo>[</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Z</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>]</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>∞</mml:mi><mml:mspace width="3em"/><mml:mo>∀</mml:mo><mml:mi>T</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></disp-formula> which suggests that the system state will almost surely not grow to infinity in a finite time. Also, to avoid negative molecular copies, we assume that <italic>a<sub>j</sub></italic>(<italic>z</italic>) = 0 for every <italic>j</italic> ∈ {1,…,<italic>M</italic>} and <inline-formula><mml:math id="M8"><mml:mrow><mml:mi>z</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>ν</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>∉</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>.</p><p id="P26">The probability distribution to the process in (<xref ref-type="disp-formula" rid="FD3">1</xref>) is given by the Kolmogorov’s forward equation also known as the Chemical Master Equation (CME) [<xref ref-type="bibr" rid="R12">12</xref>]: <disp-formula id="FD5"><label>(3)</label><mml:math id="M9"><mml:mrow><mml:mfrac><mml:mi>d</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>ν</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>ν</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width="1em"/><mml:mo>∀</mml:mo><mml:mi>z</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mspace width="0.3em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.3em"/><mml:mo>∀</mml:mo><mml:mi>t</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula> where <italic>p</italic>(<italic>t, z</italic>) = <italic>P</italic>{<bold><italic>Z</italic></bold>(<italic>t</italic>) = <italic>z</italic>} is the (unconditional) probability mass function associated with the Markov Chain, indicating the probability of finding the chemical system in state <inline-formula><mml:math id="M10"><mml:mrow><mml:mi>z</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℤ</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> at time <italic>t</italic> &gt; 0. Under the condition (<xref ref-type="disp-formula" rid="FD4">2</xref>), the two dynamical representations (<xref ref-type="disp-formula" rid="FD3">1</xref>) and (<xref ref-type="disp-formula" rid="FD5">3</xref>) of the system are equivalent.</p><p id="P27">With modern time-lapse fluorescent microscopes, scientists can now measure single-cell trajectories at high resolutions [<xref ref-type="bibr" rid="R1">1</xref>, <xref ref-type="bibr" rid="R2">2</xref>]. However, due to the limited choices of distinguishable fluorescent reporters, this technology cannot keep track of all the chemical species in a cell [<xref ref-type="bibr" rid="R3">3</xref>]. This obstacle gives rise to a stochastic filtering problem for the considered system, i.e., to infer the hidden state based on the partially observed cell states. An accurate solution to this problem can provide deep insights into intracellular dynamics and enables the design of better controllers [<xref ref-type="bibr" rid="R30">30</xref>].</p></sec><sec id="S5"><label>2.2</label><title>The Filtering Problem for the Noise-Free Observation Process</title><p id="P28">To describe this filtering problem, we further decompose the system into two sub-networks, <bold>Z</bold>(<italic>t</italic>) = (<bold>X</bold>(<italic>t</italic>), <bold>Y</bold>(<italic>t</italic>)), where <inline-formula><mml:math id="M11"><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>X</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>χ</mml:mi><mml:mo>⊆</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:math></inline-formula> keeps track of the copy numbers of the <italic>n</italic><sub>1</sub> hidden (unobserved) species, and <inline-formula><mml:math id="M12"><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>t</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:math></inline-formula> (with <italic>n</italic><sub>2</sub>= <italic>n</italic> – <italic>n</italic><sub>1</sub>) keeps track of the copy numbers of the observed species. For simplicity, we rearrange the species orders so that the first <italic>n</italic><sub>1</sub> species are the hidden species, and the last <italic>n</italic><sub>2</sub> species are the observed ones. In this paper, we assume that we can time-continuously and exactly (noise-freely) observe the trajectory of the observed species <bold>Y</bold>(<italic>t</italic>). Our goal is to compute the conditional distribution <inline-formula><mml:math id="M13"><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≜</mml:mo><mml:mspace width="0.3em"/><mml:mi>P</mml:mi><mml:mo>{</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>X</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo>∣</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>s</mml:mi><mml:mspace width="0.3em"/><mml:mo>≤</mml:mo><mml:mi>t</mml:mi><mml:mo>}</mml:mo></mml:math></inline-formula><sup><xref ref-type="fn" rid="FN1">1</xref></sup>, which is also viewed as the optimal estimate of the hidden process given the observations because for any <inline-formula><mml:math id="M14"><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:math></inline-formula> and <italic>t</italic> ≥ 0 <disp-formula id="FD6"><mml:math id="M15"><mml:mrow><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mtext>arg</mml:mtext><mml:mspace width="0.3em"/><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>K</mml:mi><mml:mspace width="0.3em"/><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width="0.3em"/><mml:mtext>is</mml:mtext><mml:mspace width="0.3em"/><mml:mtext>adapted</mml:mtext><mml:mspace width="0.3em"/><mml:mtext>to</mml:mtext><mml:mspace width="0.3em"/><mml:mtext>the</mml:mtext><mml:mspace width="0.3em"/><mml:mtext>filtration</mml:mtext><mml:mspace width="0.3em"/><mml:mtext>generated</mml:mtext><mml:mspace width="0.3em"/><mml:mtext>by</mml:mtext><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mtext>Y</mml:mtext></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:mi mathvariant="double-struck">E</mml:mi><mml:mo>[</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mn>𝟙</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>X</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>]</mml:mo></mml:mrow></mml:math></disp-formula> where adapted means that the process under consideration is measurable with respect to the filtration generated by <bold>Y</bold>(<italic>t</italic>) for every <italic>t</italic> ≥ 0.</p><p id="P29">To present the filtering equation characterising the time evolution of <italic>π</italic>(<italic>t,x</italic>), we need first to introduce several notations related to the system decomposition. For each reaction stoichiometric vector <italic>V<sub>j</sub></italic> (<italic>j</italic> = 1,…,<italic>M</italic>), we denote its first <italic>n</italic><sub>1</sub> components by <inline-formula><mml:math id="M16"><mml:mrow><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> and the last <italic>n</italic><sub>2</sub> components as <inline-formula><mml:math id="M17"><mml:mrow><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>. Following the notations in [<xref ref-type="bibr" rid="R26">26</xref>], we term <inline-formula><mml:math id="M18"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo>≜</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>∣</mml:mo><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msubsup><mml:mo>≠</mml:mo><mml:msub><mml:menclose notation="updiagonalstrike"><mml:mn>0</mml:mn></mml:menclose><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> as the set of observable reactions that can alter the dynamics of <bold>Y</bold>(<italic>t</italic>), and we term <inline-formula><mml:math id="M19"><mml:mrow><mml:mi mathvariant="script">U</mml:mi><mml:mo>≜</mml:mo><mml:msup><mml:mi mathvariant="script">O</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> as the unobservable reactions that cannot alter <bold>Y</bold>(<italic>t</italic>). We define <inline-formula><mml:math id="M20"><mml:mrow><mml:msup><mml:mi>a</mml:mi><mml:mi mathvariant="script">O</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≜</mml:mo><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">O</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, which is the total propensity of the observed reactions. Also, we term <inline-formula><mml:math id="M21"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> as the random jump times of the observed process <bold>Y</bold>(<italic>t</italic>) and denote <inline-formula><mml:math id="M22"><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>≜</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">O</mml:mi><mml:mo>∣</mml:mo><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mi>y</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>y</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mi>k</mml:mi><mml:mo>−</mml:mo></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> (for every <inline-formula><mml:math id="M23"><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>), which represents the reaction channels compatible with the jump of the observation process at time <italic>t<sub>k</sub></italic>. Finally, we define <italic>t</italic><sub>0</sub> = 0.</p><p id="P30">The filtering equation for the conditional distribution <italic>π</italic>(<italic>t,x</italic>) has been formally derived in [<xref ref-type="bibr" rid="R50">50</xref>] for systems with finite state-spaces. In the infinite state-space setting, instead, it has been informally obtained by [<xref ref-type="bibr" rid="R26">26</xref>, <xref ref-type="bibr" rid="R45">45</xref>, <xref ref-type="bibr" rid="R46">46</xref>], and it is expressed by <disp-formula id="FD7"><label>(4)</label><mml:math id="M24"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mfrac><mml:mi>d</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mstyle mathsize="140%" displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">U</mml:mi></mml:mrow></mml:munder><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:munder><mml:mstyle mathsize="140%" displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">U</mml:mi></mml:mrow></mml:munder><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>−</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mi mathvariant="script">O</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:munder><mml:mstyle mathsize="140%" displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:munder><mml:msup><mml:mi>a</mml:mi><mml:mi mathvariant="script">O</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mover><mml:mi>x</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mover><mml:mi>x</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula> for all <inline-formula><mml:math id="M25"><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="M26"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, and <disp-formula id="FD8"><label>(5)</label><mml:math id="M27"><mml:mrow><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>t</mml:mi><mml:mi>k</mml:mi><mml:mo>−</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mover><mml:mi>x</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>t</mml:mi><mml:mi>k</mml:mi><mml:mo>−</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mover><mml:mi>x</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:mfrac><mml:mspace width="1em"/><mml:mo>∀</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mspace width="0.3em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.3em"/><mml:mo>∀</mml:mo><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P31"><bold>Theorem 1.</bold> <italic>Under the non-explosivity assumption</italic> (<xref ref-type="disp-formula" rid="FD4">2</xref>), <italic>the conditional distribution π(<italic>t,x</italic>) is the unique (up to indistinguishability) non-negative solution of the filtering equation</italic> (<xref ref-type="disp-formula" rid="FD7">4</xref>) <italic>and</italic> (<xref ref-type="disp-formula" rid="FD8">5</xref>) <italic>that starts from</italic> <italic>π</italic>(0, ·) <italic>and satisfies</italic> <disp-formula id="FD9"><mml:math id="M28"><mml:mrow><mml:msubsup><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>∫</mml:mo></mml:mstyle><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:munder><mml:mstyle mathsize="140%" displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:mspace width="0.2em"/><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:munderover><mml:mspace width="0.2em"/><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>s</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>∞</mml:mi><mml:mspace width="1em"/><mml:mo>∀</mml:mo><mml:mi>t</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mspace width="0.3em"/><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>m</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mspace width="0.3em"/><mml:mi>s</mml:mi><mml:mi>u</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>y</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P32">The proof of this theorem is presented in <xref ref-type="supplementary-material" rid="SD1">Section S.1.3</xref> of the supplementary material, where it is structured into two distinct parts: initially proving the validity of the filtering equation, followed by demonstrating the uniqueness of the solution. The filtering equation (<xref ref-type="disp-formula" rid="FD7">4</xref>) is nonlinear due to the last term (being quadratic in <italic>π</italic>(<italic>t,x)</italic>), which brings many difficulties to solving this equation. To tackle this issue, [<xref ref-type="bibr" rid="R26">26</xref>] provided a Monte-Carlo method based on a linear equation characterising the un-normalised conditional probability <italic>ρ</italic>(<italic>t, x</italic>), from which you can obtain the filtering distribution via normalisation. Specifically, this un-normalised distribution is given by <inline-formula><mml:math id="M29"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≜</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mrow><mml:mi>max</mml:mi><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msubsup><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:msub><mml:mrow><mml:msup><mml:mi>a</mml:mi><mml:mi mathvariant="script">O</mml:mi></mml:msup></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mstyle><mml:mi>d</mml:mi><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and therefore satisfies <disp-formula id="FD10"><label>(6)</label><mml:math id="M30"><mml:mrow><mml:mtable columnalign="right"><mml:mtr columnalign="right"><mml:mtd columnalign="right"><mml:mrow><mml:mfrac><mml:mi>d</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mstyle mathsize="140%" displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">U</mml:mi></mml:mrow></mml:munder><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:munderover><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="right"><mml:mtd columnalign="right"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>∀</mml:mo><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.3em"/><mml:mtext>and</mml:mtext><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula> and <disp-formula id="FD11"><label>(7)</label><mml:math id="M31"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>−</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mover><mml:mi>x</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>−</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mover><mml:mi>x</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:mfrac><mml:mspace width="1em"/><mml:mo>∀</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mspace width="0.3em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.3em"/><mml:mo>∀</mml:mo><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P33">Then, the authors in [<xref ref-type="bibr" rid="R26">26</xref>] related the linear equation (<xref ref-type="disp-formula" rid="FD10">6</xref>) with a new chemical reacting system and a random variable associated with that; afterward, a particle filter (a type of Monte-Carlo method) was proposed to compute the filtering equation. Different from this Monte-Carlo method, the literature [<xref ref-type="bibr" rid="R25">25</xref>, <xref ref-type="bibr" rid="R45">45</xref>, <xref ref-type="bibr" rid="R46">46</xref>] proposed moment closure for the filtering equation (<xref ref-type="disp-formula" rid="FD7">4</xref>) and (<xref ref-type="disp-formula" rid="FD8">5</xref>) to compute the conditional moments of π(t,x). More recently, an autonomous algorithm for this moment closure was proposed in [<xref ref-type="bibr" rid="R47">47</xref>].</p></sec><sec id="S6"><label>2.3</label><title>Filtered finite state projection method</title><p id="P34">Here, we introduce a new method for the aforementioned filtering problem using the finite state projection (FSP) approach proposed in [<xref ref-type="bibr" rid="R15">15</xref>]. The idea is that the filtering equation (<xref ref-type="disp-formula" rid="FD7">4</xref>) has a close resemblance to the CME (<xref ref-type="disp-formula" rid="FD5">3</xref>), and, therefore, it is reasonable to expect that the FSP (an effective approach for solving CME) would be applicable to this filtering problem after some extensions. In this paper, we name this new method for the filtering problem as filtered finite state projection (FFSP) method.</p><p id="P35">Similar to the FSP which solves the CME directly by truncating the system’s state space, the FFSP also straightforwardly solves the linear differential equation (<xref ref-type="disp-formula" rid="FD10">6</xref>) in the time intervals (<italic>t</italic><sub>k</sub>, t<sub>k+1</sub>) (for <inline-formula><mml:math id="M32"><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) by truncating the hidden species’ state space and updates the filter according to (<xref ref-type="disp-formula" rid="FD11">7</xref>) at the jump times <inline-formula><mml:math id="M33"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. After approximating the un-normalised distribution <italic>ρ</italic>(<italic>t, x</italic>), the FFSP obtain estimates of π(<italic>t, x</italic>) by normalisation. To be more specific, when solving (<xref ref-type="disp-formula" rid="FD10">6</xref>), the FFSP decomposes the hidden-state space <inline-formula><mml:math id="M34"><mml:mrow><mml:msubsup><mml:mi>Z</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> into a finite but large state space <inline-formula><mml:math id="M35"><mml:mrow><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:mo>⊆</mml:mo><mml:msubsup><mml:mi>Z</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and an infinite-dimensional space <inline-formula><mml:math id="M36"><mml:mrow><mml:msub><mml:mi>χ</mml:mi><mml:mrow><mml:msup><mml:mi>J</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:mo>≜</mml:mo><mml:msubsup><mml:mi>Z</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>\</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>J</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>J</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>; then the FFSP only solves (<xref ref-type="disp-formula" rid="FD7">4</xref>) on the finite space <inline-formula><mml:math id="M37"><mml:mrow><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. More precisely, by denoting <inline-formula><mml:math id="M38"><mml:mi>ρ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>ρ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>ρ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:math></inline-formula> and <inline-formula><mml:math id="M39"><mml:mi>ρ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mrow><mml:msup><mml:mi>J</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>ρ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>J</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>ρ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>J</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>⊤</mml:mo></mml:msup></mml:math></inline-formula>, the linear equation (<xref ref-type="disp-formula" rid="FD7">4</xref>) can be equivalently written as <disp-formula id="FD12"><label>(8)</label><mml:math id="M40"><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mover accent="true"><mml:mi>ρ</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mover accent="true"><mml:mi>ρ</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mrow><mml:msup><mml:mi>J</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:munder><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mrow><mml:msup><mml:mi>J</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mi>J</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mrow><mml:msup><mml:mi>J</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mi>J</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mrow><mml:msup><mml:mi>J</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">︸</mml:mo></mml:munder><mml:mrow><mml:mi mathvariant="double-struck">A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mrow><mml:msup><mml:mi>J</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mspace width="1em"/><mml:mo>∀</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mspace width="0.3em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.3em"/><mml:mo>∀</mml:mo><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:math></disp-formula> where <inline-formula><mml:math id="M41"><mml:mrow><mml:mi mathvariant="double-struck">A</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is an infinite dimensional matrix with each element defined by <disp-formula id="FD13"><label>(9)</label><mml:math id="M42"><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mo>−</mml:mo><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if</mml:mtext><mml:mspace width="0.3em"/><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">U</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mn>𝟙</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>b</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if</mml:mtext><mml:mspace width="0.3em"/><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow><mml:mo>,</mml:mo></mml:math></disp-formula> and <inline-formula><mml:math id="M43"><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mrow><mml:mi>J</mml:mi><mml:msup><mml:mi>J</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mrow><mml:mi>J</mml:mi><mml:msup><mml:mi>J</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="M44"><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mrow><mml:msup><mml:mi>J</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> are sub-matrices of <inline-formula><mml:math id="M45"><mml:mrow><mml:mi mathvariant="double-struck">A</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> with proper dimensions. Instead of solving the infinite dimensional ODE (<xref ref-type="disp-formula" rid="FD12">8</xref>), the FFSP only implements a finite dimensional ODE to approximate (<xref ref-type="disp-formula" rid="FD12">8</xref>). the FFSP only implements a finite dimensional ODE <disp-formula id="FD14"><mml:math id="M46"><mml:msub><mml:mover accent="true"><mml:mi>ρ</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mrow><mml:mi>FFSP</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>FFSP</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="1em"/><mml:mo>∀</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mspace width="0.3em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.3em"/><mml:mo>∀</mml:mo><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></disp-formula> to approximate (<xref ref-type="disp-formula" rid="FD12">8</xref>). Here, <inline-formula><mml:math id="M47"><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> is the FFSP’s estimates to the the un-normalised filter <inline-formula><mml:math id="M48"><mml:mi>ρ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.3em"/><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>, and the solution of this finite dimensional ODE is <disp-formula id="FD15"><label>(10)</label><mml:math id="M49"><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>exp</mml:mi><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="1em"/><mml:mo>∀</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mspace width="0.3em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.3em"/><mml:mo>∀</mml:mo><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math></disp-formula></p><p id="P36">The detailed algorithm for the FFSP method is presented as <xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref>.</p><boxed-text id="BX2" position="anchor"><label>Algorithm 1</label><caption><title>Filtered finite state projection (FFSP)</title></caption><p id="P37"><bold>Require:</bold>The observation <bold>Y</bold>(<italic>t<sub>k</sub></italic>) and the initial distribution of the hidden states <italic>π</italic>(0, <italic>x</italic>).</p><p id="P38">  1: Initialization: π<sub>FFSP</sub>(0, <italic>x</italic>) = <italic>π</italic>(0, <italic>x</italic>), <inline-formula><mml:math id="M50"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and <italic>π</italic><sub>FFSP</sub>(0, <italic>x</italic>) = 0.</p><p id="P39">  2: <bold>for</bold> <italic>k</italic> = 0,1,2,…,<bold>do</bold></p><p id="P40">  3:      Approximate the un-normalised filter before the next jump event: <disp-formula id="FD16"><mml:math id="M51"><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>exp</mml:mi><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="1em"/><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p id="P41">  4:      Normalisation: <inline-formula><mml:math id="M52"><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> for all <inline-formula><mml:math id="M53"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M54"><mml:mrow><mml:mi>t</mml:mi><mml:mspace width="0.3em"/><mml:mo>∈</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p id="P42">  5:      Approximate the filter at the next jump event: <disp-formula id="FD17"><mml:math id="M55"><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mstyle mathsize="normal"><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mstyle mathsize="normal"><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>−</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mstyle mathsize="normal"><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>−</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:mfrac><mml:mspace width="1em"/><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow></mml:math></disp-formula></p><p id="P43">  6:  <bold>end for</bold></p></boxed-text><p id="P44">In general, both the original FSP approach and our FFSP method solve their associated problems in a straightforward manner, and they therefore can reach good accuracy at a potential cost of high computational complexity in large dimensional systems. However, they still have some major differences in their structures. For instance, compared with the original FSP [<xref ref-type="bibr" rid="R15">15</xref>] which only solves one single finite-dimensional ODE, our FFSP algorithm needs to compute the ODEs (<xref ref-type="disp-formula" rid="FD15">10</xref>) recursively for each time interval (<italic>t</italic><sub><italic>k</italic></sub>,<italic>t</italic><sub><italic>k</italic>+1</sub>) due to the recursive structure of the filtering equation. Furthermore, as can be seen in <xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref>, the approximated FFSP solution π<sub>FFSP</sub>(<italic>t, x</italic>) is not consistently component-wise upper bounded by the exact filter π(<italic>t,x</italic>) due to the normalization step. This phenomenon could be described as a ’dominance property’ held by the exact solution, which is maintained in the original FSP algorithm and results in an exact error certification. However, in this context, the normalization procedures cause the loss of this property, making precise error bounds more challenging to establish.</p><p id="P45">Also, our approach has several advantages over other existing computational methods for solving the filtering equation (<xref ref-type="disp-formula" rid="FD7">4</xref>) and (<xref ref-type="disp-formula" rid="FD8">5</xref>). Compared with the moment-closure approach in [<xref ref-type="bibr" rid="R45">45</xref>, <xref ref-type="bibr" rid="R46">46</xref>], our FFSP method provides more detailed information about the conditional distribution, e.g., the specific conditional probability of being in any subset of the state-space, in addition to the conditional moments. Moreover, as a Monte-Carlo method, the particle filtering approach can provide good estimates for summary statistics (e.g., conditional mean and variance) but less accurate estimates for specific conditional probabilities (especially for the rare events). In contrast, our method (as a direct approach) can consistently provide very accurate estimates of the conditional probability at each state. More detailed comparisons between the particle filtering and the FFSP are presented in <xref ref-type="sec" rid="S8">Section 3</xref>.</p><p id="P46">Once the FFSP method is established, we are interested in the estimation error of this algorithm, which characterises the reliability of this method. In the following, we perform error analysis for the FFSP. For technical reasons, we only consider the case where the propensity function <inline-formula><mml:math id="M56"><mml:msup><mml:mi>a</mml:mi><mml:mi mathvariant="script">O</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> is upper bounded for each fixed <inline-formula><mml:math id="M57"><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:math></inline-formula> i.e., <disp-formula id="FD18"><label>(11)</label><mml:math id="M58"><mml:mrow><mml:mtext>there</mml:mtext><mml:mspace width="0.3em"/><mml:mtext>exists</mml:mtext><mml:mspace width="0.3em"/><mml:mtext>a</mml:mtext><mml:mspace width="0.3em"/><mml:mtext>function</mml:mtext><mml:msup><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi mathvariant="script">O</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width="0.3em"/><mml:mtext>such</mml:mtext><mml:mspace width="0.3em"/><mml:mtext>that</mml:mtext><mml:mspace width="0.3em"/><mml:munder><mml:mrow><mml:mi>sup</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:mspace width="0.3em"/><mml:msup><mml:mi>a</mml:mi><mml:mi mathvariant="script">O</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi mathvariant="script">O</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P47">Moreover, we also assume that the network with only unobserved reactions <disp-formula id="FD19"><mml:math id="M59"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>X</mml:mi></mml:mstyle><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>X</mml:mi></mml:mstyle><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">U</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:mstyle><mml:msub><mml:mi>R</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>X</mml:mi></mml:mstyle><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula> satisfies the conditions <disp-formula id="FD20"><label>(12)</label><mml:math id="M60"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mstyle displaystyle="true"><mml:msubsup><mml:mi>∑</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:msubsup><mml:mi mathvariant="double-struck">E</mml:mi></mml:mstyle><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>X</mml:mi></mml:mstyle><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>s</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>&lt;</mml:mo><mml:mi>∞</mml:mi><mml:mspace width="0.3em"/><mml:mo>∀</mml:mo><mml:mi>t</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mspace width="0.3em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.3em"/><mml:mo>∀</mml:mo><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtext>as</mml:mtext><mml:mspace width="0.3em"/><mml:mtext>long</mml:mtext><mml:mspace width="0.3em"/><mml:mtext>as</mml:mtext><mml:mspace width="0.3em"/><mml:mi mathvariant="double-struck">E</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>X</mml:mi></mml:mstyle><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn><mml:mi>q</mml:mi></mml:msubsup></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>&lt;</mml:mo><mml:mo>+</mml:mo><mml:mi>∞</mml:mi><mml:mspace width="0.3em"/><mml:mtext>for</mml:mtext><mml:mspace width="0.3em"/><mml:mtext>all</mml:mtext><mml:mspace width="0.3em"/><mml:mi>q</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula> which guarantees the process to be non-explosive when initial conditions have finite moments. Both of these assumptions are reasonable and easily checkable in practice. Usually, under a microscope, scientists observe fluorescent reporters, which are catalytically produced and spontaneously degraded. In this setting, all the observable reactions satisfy (<xref ref-type="disp-formula" rid="FD18">11</xref>) because of the saturation of catalytic production rates (due to the limited resources) and the independence of the degradation rate with other species. Also, some easily checkable conditions for the assumption (<xref ref-type="disp-formula" rid="FD20">12</xref>) have already been provided in [<xref ref-type="bibr" rid="R51">51</xref>], and those conditions are shown to cover a large class of practical biochemical reacting systems.</p><p id="P48">An upper bound for the estimation error of <xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref> is given in the following theorem.</p><p id="P49"><bold>Theorem 2.</bold><italic> Let us denote filters</italic> <inline-formula><mml:math id="M61"><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≜</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>⊤</mml:mo></mml:msup></mml:math></inline-formula> <italic>and</italic> <inline-formula><mml:math id="M62"><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≜</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>π</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>⊤</mml:mo></mml:msup></mml:math></inline-formula> <italic>Then, under the conditions</italic> (<xref ref-type="disp-formula" rid="FD4">2</xref>), (<xref ref-type="disp-formula" rid="FD18">11</xref>), <italic>and</italic> (<xref ref-type="disp-formula" rid="FD20">12</xref>), <italic><xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref> almost surely has an estimation error</italic> <disp-formula id="FD21"><mml:math id="M63"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>χ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>π</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>χ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mi>ϵ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>ϵ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mover accent="true"><mml:mi>ϵ</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mspace width="0.3em"/><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mspace width="0.3em"/><mml:mo>∀</mml:mo><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula> <italic>where</italic> <disp-formula id="FD22"><mml:math id="M64"><mml:mrow><mml:mover accent="true"><mml:mi>ϵ</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>χ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:mrow><mml:msup><mml:mn>1</mml:mn><mml:mo>⊤</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:mstyle><mml:mi mathvariant="double-struck">A</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></disp-formula> <italic>for all</italic> <inline-formula><mml:math id="M65"><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <italic>t</italic> ∈ (<italic>t<sub>k</sub></italic>, <italic>t</italic><sub>k+1</sub>), <italic>and</italic> <disp-formula id="FD23"><mml:math id="M66"><mml:mrow><mml:mi>ϵ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo>∉</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mi>π</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>min</mml:mi><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>ϵ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mover accent="true"><mml:mi>ϵ</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mi>k</mml:mi><mml:mo>−</mml:mo></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>ρ</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>χ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula> <italic>with</italic> <inline-formula><mml:math id="M67"><mml:mrow><mml:msup><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo>≜</mml:mo><mml:msub><mml:mrow><mml:mi>sup</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:msub><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p id="P50">The proof of this theorem is provided in the supporting material, specifically in <xref ref-type="supplementary-material" rid="SD1">section S.2.2</xref>. A significant advantage of this proof is that the computable error bound it offers relies solely on the FFSP solution. The error bound provided in <xref ref-type="other" rid="P63">Theorem 2</xref> is computable because the FFSP solution <inline-formula><mml:math id="M68"><mml:mrow><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> contains only finitely many non-zero elements at each time point. This computable error bound allows us to evaluate the performance of the FFSP algorithm and assess its reliability. Moreover, as the size of the truncated state space <inline-formula><mml:math id="M69"><mml:mrow><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> approaches the full (infinite) state-space <inline-formula><mml:math id="M70"><mml:mi>χ</mml:mi></mml:math></inline-formula>, both <italic>ϵ(t<sub>0</sub>)</italic> and <inline-formula><mml:math id="M71"><mml:mrow><mml:mover accent="true"><mml:mi>ϵ</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> tend toward zero. This suggests that <italic>ϵ</italic>(<italic>t<sub>k</sub></italic>) for <italic>k</italic> = 1, 2,…,also converges to zero, indicating that the accuracy of the algorithm can be indefinitely improved by expanding the size of the truncated state space. However, a major drawback of this error bound is its exponential growth in response to observable jump events, as <italic>ϵ</italic>(<italic>t<sub>k</sub></italic>) is multiplied by <inline-formula><mml:math id="M72"><mml:mrow><mml:msup><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> during error updating. This exponential growth can cause the error bound to reach large values quickly in some scenarios (see <xref ref-type="sec" rid="S8">Section 3</xref>).</p><p id="P51">However, a significant challenge in this proof is analyzing the discrepancy between the un-normalized filter, <italic>ρ(t, x),</italic> and the FFSP estimate, ρ<sub>FFSP</sub>(<italic>t, x</italic>). Since the total mass of ρ(t,x) is not conserved, traditional techniques such as those in [<xref ref-type="bibr" rid="R15">15</xref>] are inapplicable. Instead, we propose an extended FSP theorem that leverages the structure of <inline-formula><mml:math id="M73"><mml:mrow><mml:mi mathvariant="double-struck">A</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, notably the Metzler matrix property and the non-positivity of its column sums. This extended FSP theorem is crucial in proving <xref ref-type="other" rid="P63">Theorem 2</xref> and, due to its versatile form, may be applicable in other scenarios where, for example, the initial distribution is uncertain or the total mass of the distribution is not conserved, as demonstrated in [<xref ref-type="bibr" rid="R52">52</xref>]. In [<xref ref-type="bibr" rid="R52">52</xref>], a non-linear partial differential equation is formulated to describe the probability of protein concentration in a population of dividing cells. Given the complexity of this non-linear equation, a linear version is proposed, featuring a non-constant total mass. The extended FSP theorem is thus well-suited to more accurately characterize the evolution of total mass in such contexts.</p><p id="P52"><bold>Theorem 3</bold> (Extended FSP theorem for un-normalised probability distributions). <italic>We consider a set of un-normalised probability distributions</italic> <inline-formula><mml:math id="M74"><mml:mrow><mml:msub><mml:mrow><mml:mo>{</mml:mo><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> <italic>defined on a discrete state space</italic> <inline-formula><mml:math id="M75"><mml:mrow><mml:mi>χ</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> <italic>and evolving according to</italic> <disp-formula id="FD24"><mml:math id="M76"><mml:mrow><mml:mover accent="true"><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>˙</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="double-struck">A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width="1em"/><mml:mo>∀</mml:mo><mml:mi>t</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></disp-formula> where <inline-formula><mml:math id="M77"><mml:mrow><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≜</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.3em"/><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.3em"/><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>⊤</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, <italic>the variable <italic>y</italic> is a vector in <inline-formula><mml:math id="M78"><mml:mrow><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, and the matrix <inline-formula><mml:math id="M79"><mml:mrow><mml:mi mathvariant="double-struck">A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is defined in</italic> (<xref ref-type="disp-formula" rid="FD13">9</xref>). <italic>We also consider an FSP system of this infinite dimensional ODE, denoted by</italic> <inline-formula><mml:math id="M80"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <italic>which is defined on the same state space but evolves according to</italic> <disp-formula id="FD25"><mml:math id="M81"><mml:msub><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mrow><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"/><mml:mtd columnalign="left"><mml:mo>|</mml:mo></mml:mtd><mml:mtd columnalign="left"/></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mo>|</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo>−</mml:mo><mml:mo>−</mml:mo><mml:mo>−</mml:mo><mml:mo>−</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mo>−</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>−</mml:mo><mml:mo>−</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mo>|</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"/><mml:mtd columnalign="left"><mml:mo>|</mml:mo></mml:mtd><mml:mtd columnalign="left"/></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width="1em"/><mml:mo>∀</mml:mo><mml:mi>t</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:math></disp-formula> <italic>where</italic> <inline-formula><mml:math id="M82"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.3em"/><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≜</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.3em"/><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.3em"/><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>⊤</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, <italic>the matrix</italic> <inline-formula><mml:math id="M83"><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> <italic>is the first</italic> <italic>J</italic> × <italic>J</italic> <italic>sub-matrix of</italic> <inline-formula><mml:math id="M84"><mml:mrow><mml:mi mathvariant="double-struck">A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <italic>and p<sub>FSP</sub></italic>(0,<italic>x</italic>) = 0 <italic>for all <inline-formula><mml:math id="M85"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∉</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula></italic></p><p id="P53"><italic>Then, under conditions</italic> (<xref ref-type="disp-formula" rid="FD20">12</xref>) <italic>and</italic> <inline-formula><mml:math id="M86"><mml:mrow><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mrow></mml:mstyle><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>s</mml:mi><mml:mo>&lt;</mml:mo><mml:mo>+</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:math></inline-formula>, <italic>the difference in the L1 norm between these two sets of measures can be evaluated by</italic> <disp-formula id="FD26"><mml:math id="M87"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>&lt;</mml:mo><mml:mi>ϵ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mspace width="1em"/><mml:mo>∀</mml:mo><mml:mi>t</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></disp-formula> <italic>where</italic> <inline-formula><mml:math id="M88"><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>χ</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:mrow><mml:msup><mml:mn>1</mml:mn><mml:mo>⊤</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:mstyle><mml:mi mathvariant="double-struck">A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>·</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.3em"/><mml:mi>ϵ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> <italic>is computable because the function P<sub>FSP</sub></italic>(t, ·) <italic>has finite support.)</italic></p><p id="P54"><italic>Proof.</italic> The proof is given in the <xref ref-type="supplementary-material" rid="SD1">section S.2.1</xref> of the supplementary material.</p><p id="P55">Thanks to theorem <xref ref-type="other" rid="P69">Theorem 3</xref>, we were able to establish an error bound for <xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref>. However, as previously noted, the exponential growth of the error complicates assessing the actual accuracy of the algorithm. Although a large error bar does not necessarily indicate that <xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref> is inaccurate—as evidenced by numerous examples in Section 3—it does tend to undermine confidence in this computational approach among practitioners. To address this issue, we next introduce an alternative FFSP algorithm that offers a tighter error bound, albeit with more limited applicability.</p></sec><sec id="S7"><label>2.4</label><title>Another FFSP algorithm with tighter error bounds</title><p id="P56">In this section, we introduce a new FFSP algorithm designed to achieve tighter error bounds. In [<xref ref-type="bibr" rid="R15">15</xref>], the error of the original FSP algorithm can be precisely calculated due to the dominance property, where the FSP solution is consistently less than or equal to the exact solution component-wise. However, this property is lost in <xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref> immediately after the normalization step. Once the total mass of the FFSP solution equals one, it cannot be universally dominated by any other probability distribution unless they are exactly identical, which is rare. This loss complicates the error analysis for <xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref> and results in a somewhat conservative error bound as documented in <xref ref-type="other" rid="P63">Theorem 2</xref>.</p><p id="P57">The first FFSP algorithm utilizes a straightforward strategy ideal for addressing the filtering problem in noise-free scenarios and is versatile enough for most chemical reacting systems. Nevertheless, it yields a conservative error estimate for the approximate solution. To refine this, our new algorithm modifies the normalization step to ensure the exact solution always dominates the FFSP solution, allowing us to explicitly define the error. Specifically, when approximating the filter at the next observable jump time, this algorithm divides ρ<sub>FFSp</sub>(<italic>t<sub>K+1</sub></italic>,<italic>x</italic>) by a quantity that exceeds the denominator used in (<xref ref-type="disp-formula" rid="FD8">5</xref>) rather than the sum <inline-formula><mml:math id="M89"><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>−</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:math></inline-formula>. It is crucial to note that both algorithms yield the same result up to a normalization constant. While the first algorithm adopts the most intuitive approach for the noise-free filtering problem, the second employs a distinct normalization strategy that leads to an exact error certificate for the approximate solution. However, a limitation of the second algorithm is that the stochastic reaction network it applies to must meet specific conditions, as outlined in (<xref ref-type="disp-formula" rid="FD18">11</xref>).</p><p id="P58">We present the new computational approach in <xref ref-type="boxed-text" rid="BX3">Algorithm 2</xref> and its estimation error in <xref ref-type="other" rid="P80">Theorem 4</xref></p><p id="P59"><bold>Theorem 4.</bold><italic>Under conditions</italic> (<xref ref-type="disp-formula" rid="FD4">2</xref>) <italic>and</italic> (<xref ref-type="disp-formula" rid="FD18">11</xref>), <italic><xref ref-type="boxed-text" rid="BX3">Algorithm 2</xref> has the properties that</italic> <list list-type="bullet" id="L"><list-item><p id="P60"><italic>πFFSP(t, x)</italic> ≤ <italic>π(t, x)</italic> for all t ≥ 0 and <inline-formula><mml:math id="M90"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>Z</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, and, therefore,</p></list-item><list-item><p id="P61"><italic>the estimation error is given by</italic> <inline-formula><mml:math id="M91"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> <italic>for all t ≥ 0,where</italic> <inline-formula><mml:math id="M92"><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≜</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M93"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>⊤</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M94"><mml:mrow><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≜</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>π</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>⊤</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>.</p></list-item></list></p><p id="P62"><italic>Proof.</italic> The proof is given in <xref ref-type="supplementary-material" rid="SD1">section S.2.1</xref>.</p><p id="P63">The second part of <xref ref-type="other" rid="P80">Theorem 4</xref> tells that we can exactly estimate the error of <xref ref-type="boxed-text" rid="BX3">Algorithm 2</xref> rather than obtaining a conservative error bound. This benefit mainly comes from the new normalization step, where we divide the un-normalised FFSP solution by a quantity larger than the actual normalization factors in (<xref ref-type="disp-formula" rid="FD7">4</xref>) and (<xref ref-type="disp-formula" rid="FD8">5</xref>). In addition to this theoretical result, our numerical examples in <xref ref-type="sec" rid="S8">Section 3</xref> also show that this second FFSP algorithm can provide a much tighter error bound than the first algorithm. All these results suggest that, the second FFSP algorithm (<xref ref-type="boxed-text" rid="BX3">Algorithm 2</xref>) can provide estimates of lower error bounds than the first FFSP algorithm (<xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref>).</p><p id="P64">However, we need to mention that the tighter error bound of <xref ref-type="boxed-text" rid="BX3">Algorithm 2</xref> does not necessarily mean that this second FFSP algorithm is always more accurate than the first one. Mainly, this tighter error bound is obtained by a more elegant analysis technique which does not work for the first algorithm, but we cannot preclude the possibility that the first algorithm is actually more accurate than the second one. Our numerical examples in <xref ref-type="sec" rid="S8">Section 3</xref> also illustrate that the actual error of the first FFSP algorithm can be extremely tiny even though its error bound is very large. Moreover, by requiring the dominance property for the second FFSP algorithm, the solution of <xref ref-type="boxed-text" rid="BX3">Algorithm 2</xref> has a leaky property (similar to the original FSP in [<xref ref-type="bibr" rid="R15">15</xref>]) that its total mass constantly flows out of the truncated state space. Consequently, the second FFSP can lose most of its mass at some time point and stop being functioning after that. This leakiness is also observed in some numerical examples in <xref ref-type="sec" rid="S8">Section 3</xref>, and in these cases, the first FFSP can perform much more accurately than the second one.</p><boxed-text id="BX3" position="anchor"><label>Algorithm 2</label><caption><title>Another FFSP algorithm with a tighter error bound only valid under condition (<xref ref-type="disp-formula" rid="FD18">11</xref>)</title></caption><p id="P65"><bold>Require:</bold> The observation <bold>Y</bold>(<italic>t<sub>k</sub></italic>) and the initial distribution of the hidden states π(0, x).</p><p id="P66">  1: Initialization: <inline-formula><mml:math id="M95"><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>∀</mml:mo><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p><p id="P67">  2: <bold>for</bold> <italic>k</italic>= 0,1,2,…,<bold>do</bold></p><p id="P68">  3:      Approximate the un-normalised filter before the next jump event: <disp-formula id="FD27"><mml:math id="M96"><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>exp</mml:mi><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">A</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="1em"/><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p id="P69">  4:      Estimate an upper bound for the normalisation factor before the next jump: <disp-formula id="FD28"><mml:math id="M97"><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mi>t</mml:mi></mml:msubsup><mml:mrow><mml:msup><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle><mml:mi>T</mml:mi></mml:msup></mml:mrow></mml:mrow></mml:mstyle><mml:mi mathvariant="double-struck">A</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>s</mml:mi><mml:mspace width="1em"/><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p id="P70">  5:      Estimate an upper bound for the normalisation factor at the next jump: <disp-formula id="FD29"><mml:math id="M98"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mi>FFSP</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub></mml:mrow></mml:munder><mml:mspace width="0.2em"/><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>−</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mrow><mml:mo>+</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>−</mml:mo></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>−</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mi>χ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p id="P71">  6:      with <inline-formula><mml:math id="M99"><mml:mrow><mml:msup><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo>≜</mml:mo><mml:msub><mml:mrow><mml:mi>sup</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:msub><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> whose existence is provided by (<xref ref-type="disp-formula" rid="FD18">11</xref>).</p><p id="P72">  6:      Normalisation: for every <italic>x</italic> ∈<italic>X <sub>J</sub></italic>, we compute <disp-formula id="FD30"><label>(1)</label><mml:math id="M100"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>−</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mtext>FFSP</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:mtd><mml:mtd/></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p id="P73">  7: <bold>end for</bold></p></boxed-text><p id="P74">To summarise, <xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref> and <xref ref-type="boxed-text" rid="BX3">Algorithm 2</xref> are equivalent up to a constant of normalisation, as their unnormalised filters follow the same linear equation and the algorithms only differs in the normalization step. The key difference is, that, the former employs a more natural strategy for solving the filtering problem, which gives rise to a probability distribution as an output. The latter, instead, utilises a different constant of normalisation to recover the dominance property, which therefore outputs an un-normalised probability distribution, which can then be normalised afterwards.</p><p id="P75">Also, the second FFSP has a narrower working range compared to the first FFSP algorithm. In the normalization step, the second FFSP algorithm requires the system to satisfy the condition (<xref ref-type="disp-formula" rid="FD18">11</xref>), whereas the first FFSP algorithm does not. This suggests that the first FFSP can be applied to a broader class of chemical reacting systems. Nevertheless, both algorithms need condition (<xref ref-type="disp-formula" rid="FD18">11</xref>) to generate error bounds.</p><p id="P76">Comparisons of these two FFSP algorithms are summarized in <xref ref-type="table" rid="T1">Table 1</xref>.</p></sec></sec><sec id="S8"><label>3</label><title>Numerical Results</title><p id="P77">Now, we illustrate our filters using several biologically relevant examples. The experiments were performed on a laptop with a 2.3 GHz Dual-Core CPU, and the code is available on GitHub: Numerical Experiments Code.</p><sec id="S9"><label>3.1</label><title>A Simple Transcription-Translation Model</title><p id="P78">We start by considering a simple transcription-translation network containing basic patterns in the central dogma of molecular biology. The network consists of three reactions: <disp-formula id="FD31"><label>(13)</label><mml:math id="M101"><mml:mrow><mml:mtext>mRNA</mml:mtext><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mover><mml:mtext>mRNA</mml:mtext><mml:mo>+</mml:mo><mml:mtext>Protein</mml:mtext><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:mo>∅</mml:mo><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mover><mml:mtext>mRNA</mml:mtext><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:mtext>mRNA</mml:mtext><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mover><mml:mo>∅</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula> where an mRNA molecule translates proteins as well as being transcribed and degraded. We also assume that the protein degradation proceeds much slower than the above reactions so that in a relatively short time interval, the protein degradation can be ignored. In this example, we choose to continuously observe protein dynamics and estimate the mRNA copy number, and therefore we let <inline-formula><mml:math id="M102"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>X</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> keep track of the mRNA copy number and <inline-formula><mml:math id="M103"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> keep track of the protein copy number.</p><sec id="S10"><label>3.1.1</label><title>FFSP vs. Kalman Filter and Particle Filter</title><p id="P79">We first compare the performance of our FFSP to the classical Kalman filter and the particle filter introduced in [<xref ref-type="bibr" rid="R26">26</xref>]. We generated the hidden and observation process trajectories using a Gillespie simulation algorithm. To construct the Kalman filter, we approximate the dynamics of the concentrations <inline-formula><mml:math id="M104"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mtext>X</mml:mtext><mml:mo>Ω</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mtext>Y</mml:mtext><mml:mo>Ω</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mtext>X</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>Ω</mml:mo></mml:mfrac><mml:mo>,</mml:mo><mml:mfrac><mml:mrow><mml:mtext>Y</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>Ω</mml:mo></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> (where Ωis a sampling volume) with the diffusion approximation (see [<xref ref-type="bibr" rid="R19">19</xref>] for a review) and establish Kalman filters on top of it. Then, we used the generated observation process trajectory as input for the first FFSP algorithm (<xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref>) and the bootstrap particle filter (BPF); whereas, for the Kalman filter, we employed the same observation trajectory re-scaled with sampling volume Ω (see <xref ref-type="supplementary-material" rid="SD1">section S3</xref> of the Supporting Material for more details). The generated hidden process trajectory functions as a mean to test the quality of the estimates provided by the three filters. Moreover, we chose <inline-formula><mml:math id="M105"><mml:mrow><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>500</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> as the truncated state space for the FFSP, <italic>N<sub>tot</sub></italic> = 10000 as the particle size of the particle filter, Ω = 100 as sampling volume, and <italic>t<sub>f</sub></italic> = 1s as final simulation time, and <bold>Z</bold><sub>0</sub> = [0, 0] as initial state. We assumed that the network follows mass-action kinetics and the propensity functions are <italic>a<sub>1</sub>(z<sub>1</sub>, z<sub>2</sub>)</italic> = <italic>c<sub>1</sub> z<sub>1</sub>, a<sub>2</sub>(z<sub>1</sub>, z<sub>2</sub>)</italic> = <italic>c<sub>2</sub>, a<sub>3</sub>(z<sub>1</sub>, z<sub>2</sub>)</italic> = <italic>c<sub>3</sub>z<sub>1</sub></italic>. For the reaction rates, we set <italic>c<sub>1</sub></italic> = 100, <italic>c<sub>2</sub></italic> = 10, <italic>c<sub>3</sub></italic> = 5.</p><p id="P80">The numerical results are shown in <xref ref-type="fig" rid="F3">Fig. 3</xref>. In this figure, the observation process is monotonically increasing as protein degradation is absent in our model. To evaluate the performance of the three filters, we plot all their estimates together with the exact trajectory of the hidden process.</p><p id="P81">As shown, all filters capture the general trend of the hidden process well. Contrary to the introduction, the Kalman filter performs acceptably in reconstructing the trajectory of the hidden process for a linear network with no feedback. Additionally, the observation process trajectory resembles that of an SDE (Stochastic Differential Equation), given the moderately high copy number regimes, causing the filter to mistake Poisson-type noise for Gaussian-like noise. Therefore, in such scenarios, the Kalman filter remains a valuable inference tool. On the other hand, the FFSP and BPF show excellent agreement in their estimations.</p></sec><sec id="S11"><label>3.1.2</label><title>Comparison of two FFSP algorithms</title><p id="P82">We focus now on comparing the performance of the two proposed FFSP algorithms concerning the error propagation of the approximate filtering solution. To this end, we test the chemical reaction network in <xref ref-type="disp-formula" rid="FD31">Eq. (13)</xref> with the same hidden (mRNA) and observed (protein) processes. To be consistent with the error analysis hypotheses, we chose the following propensity functions: <inline-formula><mml:math id="M106"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>4</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, and <italic>a</italic><sub>3</sub>(<italic>z</italic><sub>1</sub>, <italic>z</italic><sub>2</sub>) = <italic>c</italic><sub>3</sub><italic>z</italic><sub>1</sub> so that the propensity of the observable reaction (the first one) is upper bounded. The propensity functions of the observable reactions play a crucial role in the error bound behaviour (see <xref ref-type="other" rid="P63">Theorem 2</xref>). Therefore, for different values of the parameters <italic>c<sub>1</sub></italic> and <italic>c<sub>4</sub></italic>, we may obtain distinct error bounds and dynamic scenarios. In <xref ref-type="fig" rid="F4">Figs. 4</xref> to <xref ref-type="fig" rid="F6">6</xref> we show three different behaviours of the error bounds and of the dynamics over time. In all the three settings, we again simulated the observation and hidden process trajectories with a Gillespie algorithm and fed the former as input to both FFSPs algorithms. Furthermore, we set <inline-formula><mml:math id="M107"><mml:mrow><mml:msub><mml:mi>χ</mml:mi><mml:mi>J</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>500</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> as hidden species truncated state, <bold>Z</bold><sub>0</sub> = [5, 0] as initial condition and <italic>t<sub>f</sub></italic> = 2s.</p><sec id="S12"><title>Scenario 1: Low protein production rate</title><p id="P83">In this first case, we set <italic>c<sub>1</sub></italic> = 25, c<sub>2</sub> =4, <italic>c<sub>3</sub></italic> = 1, and c<sub>4</sub> = 10, so that the protein production rate saturates at a relatively low value 25. From the numerical result shown in <xref ref-type="fig" rid="F4">Fig. 4</xref>, we can see that the observation process (the protein dynamics) still increases quite rapidly, in contrast to the mRNA copy number, which in turn fluctuates around the same value set as initial condition. Moreover, the two FFSP algorithms perform incredibly well in estimating the hidden process and show a very good agreement on all the estimates.</p><p id="P84">However, the error-bound growth tends to behave differently in the two algorithms (see <xref ref-type="table" rid="T2">Table 2</xref>).</p><p id="P85">For this choice of parameters, the propensity <italic>a</italic><sub>1</sub>(<italic>z</italic><sub>1</sub>, <italic>z</italic><sub>2</sub>) tends to have lower values at each jump time; therefore, every time it gets pre-multiplied with the error of the previous jump time (see <xref ref-type="other" rid="P63">Theorem 2</xref>), there is less accumulation of the error over time. Nevertheless, as it can be seen in <xref ref-type="table" rid="T2">Table 2</xref>, the error bound of the first FFSP algorithm grows immediately after the first few jump times. Such a feature can be expected, given the conservative upper bound. On the contrary, the error bound of the second FFSP algorithm is incredibly small for the first few jump times; then, we can notice a moderately rapid growth, but it stays pretty low until the last jump time with an order of magnitude of 10<sup>−4</sup>).</p><p id="P86">The last row of <xref ref-type="table" rid="T2">Table 2</xref> shows the <italic>L</italic><sub>1</sub> difference in the values of the conditional distributions obtained with the two FFSP algorithms, which suggests that these two filters provide very similar results. To be more specific, the difference between the two filters is almost indistinguishable until <italic>t</italic><sub>14</sub>(order of magnitude from 10<sup>−15</sup> to 10<sup>−12</sup>) and slowly grows towards the end of the simulation, remaining appreciably low (10<sup>−4</sup>). We recall that <xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref> and <xref ref-type="boxed-text" rid="BX3">Algorithm 2</xref> are equivalent up to a constant of normalisation, which is very different in the two algorithms. The diverse normalisation strategy might be responsible for the difference in the filters values displayed towards the end of the simulation. To summarise, the second FFSP algorithm is notably very accurate, and the estimates provided by the first FFSP algorithm are considerably close to the result obtained by second one. Therefore, we can claim that <xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref> is also very accurate, even though its conservative error bound grows incredibly fast from the beginning. Moreover, it is misleading to say that one algorithm is better than the other. Specifically, with the triangle inequality, it is possible to show that the <italic>L</italic><sub>1</sub> distance of the approximate solution provided by <xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref> <inline-formula><mml:math id="M108"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> from the exact one <inline-formula><mml:math id="M109"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, namely <inline-formula><mml:math id="M110"><mml:mrow><mml:msub><mml:mi>ℰ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, is included in the following interval <inline-formula><mml:math id="M111"><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>ℰ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>ℰ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>P</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>ℰ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>ℰ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>P</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Here <italic>ε<sub>FFSPs</sub></italic> represents the <italic>L</italic><sub>1</sub> distance between the two approximate solutions obtained with <xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref> <inline-formula><mml:math id="M112"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <xref ref-type="boxed-text" rid="BX3">Algorithm 2</xref> <inline-formula><mml:math id="M113"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>P</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>; whereas, <inline-formula><mml:math id="M114"><mml:mrow><mml:msub><mml:mi>ℰ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>P</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the <italic>L<sub>1</sub></italic> distance between the approximate solution obtained with <xref ref-type="boxed-text" rid="BX3">Algorithm 2</xref> <italic>(ρ<sub>FFsp</sub>2(t,</italic>X)) and the exact one <inline-formula><mml:math id="M115"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>χ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Then, we can observe that, for example, during the early stages of the simulation (up to <italic>t</italic><sub>8</sub>), <inline-formula><mml:math id="M116"><mml:msub><mml:mi>ℰ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:math></inline-formula> is included in an interval with a significant gap in the order of magnitude (10<sup>−16</sup> to 10<sup>−14</sup>), while <inline-formula><mml:math id="M117"><mml:msub><mml:mi>ℰ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>P</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:math></inline-formula> has the order of 10<sup>−15</sup>. Therefore, we may conclude that both filters are appreciably accurate.</p></sec><sec id="S13"><title>Scenario 2: High protein production rate</title><p id="P87">In this case, we set <italic>c</italic><sub>1</sub> = 40, <italic>c</italic><sub>2</sub> = 4, <italic>c</italic><sub>3</sub> = 1, <italic>c</italic><sub>4</sub> = 20 so that the protein production rate saturates at a relatively high value 40. In <xref ref-type="fig" rid="F5">Fig. 5</xref>, we again show the observation process dynamics on the left side and the hidden dynamics, together with the filter estimates for the conditional means and standard deviations on the right. We can notice a large number of jump times in the protein dynamics, leading to rapid growth in a brief time. On the other hand, the mRNA copy number stays around the same value as the initial condition, like in the previous case. Again, the two FFSP algorithms show a good match in estimating the hidden process’ conditional expectations and standard deviations, but their estimates diverge after 1.8 seconds.</p><p id="P88">In this setting, the choice of parameters may lead to higher propensity values and, therefore, to a significant accumulation of the error bound over time. This is, in fact, confirmed by the error bound dynamics shown in <xref ref-type="table" rid="T3">Table 3</xref>. We can notice that the error bound of the first FFSP algorithm overgrows already from the start of the simulation. This behaviour is to be expected again, given the conservative error estimate. In contrast, the error bound of the second FFSP algorithm tends to be very low until the 18th jump time but then grows quite fast, reaching a relatively high order of magnitude (10<sup>−1</sup>). Even though the second FFSP algorithm is not as accurate as in the first case, it can still be considered accurate before 1.8 seconds. After 1.9 seconds, the second FFSP algorithm loses more than one third of the total mass and therefore can not be regarded as an accurate filter.</p><p id="P89">Despite this large gap in error bounds, the difference in the conditional distribution estimated values obtained by the two filters (last row of <xref ref-type="table" rid="T3">Table 3</xref>) again shows that the two algorithms produce appreciably similar approximated solutions up to <italic>t</italic><sub>18</sub>, when the second filter is still accurate. Therefore, until <italic>t</italic><sub>18</sub>, we can assert that both filters produce truly accurate estimates, without preferring one filter over the other, for the same reasons as in <bold>Scenario 1</bold>. Afterwards, the second filter tends to become inaccurate and we do not have means for discussing the accuracy of the first filter, given its poor error bound. In summary, we can conclude that the values of the observable propensity functions and the number of jumps of the observation process deeply impact the accuracy of the filters.</p></sec><sec id="S14"><title>Example 3: High protein production rate but less observable jumps</title><p id="P90">Now, we investigate how different observation trajectories affect the filters’ performance. To this end, we still keep <italic>c</italic><sub>1</sub> = 40, <italic>c</italic><sub>2</sub> = 4, <italic>c</italic><sub>3</sub> = 1, <italic>c</italic><sub>4</sub> = 20 as in the previous example but collect a simulation where the observation process jumps less frequently. In this case, we should observe less error propagation over time, and the error bounds should attain lower values at the final jump time.</p><p id="P91">As can be seen in <xref ref-type="fig" rid="F6">Fig. 6</xref>, the two FFSP algorithms satisfactorily capture the behaviour of the hidden process. However, as shown in <xref ref-type="table" rid="T4">Table 4</xref>, the error bound of the first FFSP algorithm still grows very fast after the second jump time; whereas the error bound of the second FFSP algorithm behaves overall nicely and tends to grow slower than in the previous example, attaining an order of magnitude of 10<sup>−4</sup> at the final time. From these results, we can conclude that the for the same system, the error bound of the second FFSP algorithm is largely influenced by the shape of the observation trajectory, especially the number of observable jumps. On the contrast, the error bound of the first FFSP algorithm does not show such an influence.</p></sec></sec><sec id="S15"><label>3.1.3</label><title>FFSP vs. Particle filter: Conditional Distribution Estimation</title><p id="P92">Now, we consider the same network (<xref ref-type="disp-formula" rid="FD31">13</xref>) but switch the observed and hidden species, i.e., we let <bold>X</bold>(<italic>t</italic>) keep track of the protein copy number and <bold>Y</bold>(<italic>t</italic>) of the mRNA copy number. In this setting, the protein copy number is solely determined by the first reaction channel, and therefore the conditional distribution <italic>π</italic>(<italic>t, x</italic>) follows a Poisson distribution with parameter <inline-formula><mml:math id="M118"><mml:mi>λ</mml:mi><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:mstyle><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>s</mml:mi></mml:math></inline-formula>. We again assume mass-action kinetics for the network and therefore the propensity functions remain the same as the first example. However, for reaction rates parameters, we set <italic>c</italic><sub>1</sub> = 1, <italic>c</italic><sub>2</sub>= 5, <italic>c</italic><sub>3</sub> = 1.</p><p id="P93">In this case, we test the performance of the FFSP filter (<xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref>) against the particle filter [<xref ref-type="bibr" rid="R26">26</xref>] in estimating the hidden dynamics, together with the conditional distribution. We again employed the Gillespie algorithm to generate the hidden and observed trajectories, and we then used the generated observation trajectory as input for both filters. We set the hidden species state space to be <inline-formula><mml:math id="M119"><mml:mi>χ</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>200</mml:mn><mml:mo>}</mml:mo></mml:math></inline-formula> for the FFSP filter, <italic>N<sub>tot</sub> = </italic> 10000 as particle size, <italic>t<sub>f</sub></italic> = 5<italic>s</italic> as final time and <bold>Z</bold><sub>0</sub> = [0, 5] as initial state. The numerical experiments are then shown in <xref ref-type="fig" rid="F7">Fig. 7</xref>.</p><p id="P94">As we can notice in the top left plot, the mRNA copy number fluctuates over time, with rapid outbursts that enhance protein translation. In this regard, we plotted the hidden process (protein) copy number in the bottom left plot as a validation of the filters estimates (conditional expectations). We can observe that the protein copy number increases rapidly over time, with the exception of some regions in which the mRNA copy numbers suddenly decreases. Overall, the two filters agree on all the estimates over time, with a general underestimation of the actual values towards at the beginning and at the end of the simulation analysis. The underestimation of the protein copy number might be due to the fact that the protein increases very rapidly at the initial time even though the mRNA copies tend to decrease. Therefore, the filters fail to follow this unexpected sharp increase at the beginning and keep underestimating the values for this whole interval.</p><p id="P95">Although the particle filter performs accurately in estimating the conditional means and standard deviations, we can discern, in the top right plot, that FFSP is more accurate in reproducing the exact conditional distribution, e.g., when estimating the peak probability. Such a behaviour can be expected, as the FFSP is a direct method, and therefore more accurate at depicting the behaviour of probability distributions. On the contrary, being particle filter a Monte-Carlo method, its performance depends on the number of particles being employed in the algorithm and how well they locate at a certain state. More specifically, let <italic>V</italic><sub>1</sub>(<italic>t</italic>),…,<italic>V<sub>N</sub></italic>(<italic>t</italic>) be <italic>N</italic> particles sampled from the conditional distribution; a particle filter use a scaled binomial distribution <inline-formula><mml:math id="M120"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:mstyle displaystyle="true"><mml:msubsup><mml:mi>∑</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup><mml:mrow><mml:mn>𝟙</mml:mn><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>x</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> to approximate the conditional probability at the state <italic>x.</italic> In this case, the coefficient of error (the ratio between the standard deviation and the mean of this scaled binomial distribution) becomes <inline-formula><mml:math id="M121"><mml:mfrac><mml:mrow><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msqrt></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mi>N</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:math></inline-formula> with <italic>p</italic> being the probability of finding the particle in that specific state, suggesting that the particle filter is not particularly suited in estimating rare events when <italic>p</italic> is small. This phenomenon is spotted in the bottom right plot of <xref ref-type="fig" rid="F7">Fig. 7</xref>: the particle filter has very big relative error when estimating the state <italic>x</italic> = 0 whose conditional probability value is approximately 4.5 × 10<sup>−5</sup>. In contrast, the relative error of the FFSP is always considerably small, even in estimating rare events.</p><p id="P96">In conclusion, though the FFSP and the particle filter have similar performance in estimating the conditional mean and variance, the FFSP has a much higher accuracy when estimating specific conditional probability, especially the rare events.</p></sec></sec><sec id="S16"><label>3.2</label><title>Genetic Toggle Switch</title><p id="P97">We consider now the following network, also known in biology as Toggle Switch: <disp-formula id="FD32"><label>(14)</label><mml:math id="M122"><mml:mrow><mml:mo>∅</mml:mo><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msubsup><mml:mi>k</mml:mi><mml:mn>2</mml:mn><mml:mn>8</mml:mn></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow></mml:mover><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mover><mml:mo>→</mml:mo><mml:mn>1</mml:mn></mml:mover><mml:mo>∅</mml:mo><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:mo>∅</mml:mo><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msubsup><mml:mi>ε</mml:mi><mml:mn>1</mml:mn><mml:mi>γ</mml:mi></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow></mml:mover><mml:msub><mml:mi>S</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:msub><mml:mi>S</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mover><mml:mo>→</mml:mo><mml:mn>1</mml:mn></mml:mover><mml:mo>∅</mml:mo></mml:mrow></mml:math></disp-formula> which is composed of two species mutually repressing each other. This elementary network shows properties like multi-stability and fluctuations that are desirable in different contexts in biology. Along these lines, a relatively new synthetic biology advance was implementing a genetic toggle switch in <italic>Escherichia Coli</italic> [<xref ref-type="bibr" rid="R53">53</xref>]. In this example, we decide to continuously observe the <italic>S</italic><sub>2</sub> copy number and estimate the dynamics of <italic>S</italic><sub>1</sub>, and therefore we let <inline-formula><mml:math id="M123"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>X</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> keep track of the <italic>S</italic><sub>1</sub> copy number and <inline-formula><mml:math id="M124"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> of <italic>S</italic><sub>2</sub>. To be consistent with the mutual repression of the two species, we chose the subsequent propensity functions: <inline-formula><mml:math id="M125"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msubsup><mml:mi>z</mml:mi><mml:mn>2</mml:mn><mml:mi>β</mml:mi></mml:msubsup></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M126"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msubsup><mml:mi>z</mml:mi><mml:mn>1</mml:mn><mml:mtext>γ</mml:mtext></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> and <italic>a<sub>4</sub> (z<sub>1</sub>, z<sub>2</sub>) = z<sub>2</sub></italic></p><p id="P98">The following scenarios test the two FFSP algorithms on the latent states’ estimates and error bound computations. Specifically, we chose two different parameter sets so that distinct dynamics and accuracy analyses arise. In all the examples, we set <bold>Z</bold><sub>0</sub> = [0, 0] as initial state and <inline-formula><mml:math id="M127"><mml:mrow><mml:mi>χ</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>200</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> as hidden species truncated state space and <italic>t<sub>f</sub></italic> = 5<italic>s</italic> as final simulation time. We again generated the observed and hidden process trajectories with a Gillespie algorithm and fed the former as input to both the filters.</p><sec id="S17"><title>Strong Repression</title><p id="P99">In this case, we set <italic>α</italic><sub>1</sub> = 16, <italic>α</italic><sub>2</sub> = 14, <italic>β</italic> = 1, <italic>γ</italic> = 1 so that the the two species strongly repress each other’s production. For this choice of parameters, switching behaviour is almost always guaranteed. Any time one of the two species is present in higher abundances, the other species’ values shrink to zero almost immediately. Such a behaviour can be seen in <xref ref-type="fig" rid="F8">Fig. 8</xref>. The left-sided plot shows an initial slow increase of the observed (<italic>S</italic><sub>2</sub>) species until time <italic>t</italic> = 4s, with a sharp outburst towards the end. In contrast, the right-sided plot shows the rapid increase of the hidden process from the beginning of the simulation and a rapid shrinking of its values towards the simulation’s final time, as expected. Moreover, the right-sided plot, in <xref ref-type="fig" rid="F8">Fig. 8</xref>, also shows the stochastic filters’ estimates and their standard deviations. Generally, we can see that both FFSP filters capture the hidden process dynamics everywhere; for the error behaviour, both filters behave nicely, providing very low error bounds, especially second FFSP algorithm whose error is always below 10<sup>−15</sup>. In this case, we cannot distinguish whether it is an error of our algorithm or an error of the floating point.</p></sec></sec><sec id="S18"><title>Mild Repression</title><p id="P100">In this case, we chose <italic>α</italic><sub>1</sub> = 18, <italic>α</italic><sub>2</sub> = 15, <italic>β</italic> = 1.5, <italic>γ</italic> = 0.01, so that the first species repress the second one very mildly. In <xref ref-type="fig" rid="F9">Fig. 9</xref>, we plot the observed and hidden process trajectories and filters’ estimates, together with their standard deviations (on the left and right side of the plot, respectively). In the first part of the simulation, both filters agree on the estimations and succeed in following the trend of the hidden process. However, both filters underestimate the outbreak of the hidden species because the size of this outbreak is unexpectedly large. Even when there is no repression, every second there are 7.5 newly produced <italic>S</italic><sub>2</sub> copies in average, which is only half of the size of this outbreak (see <xref ref-type="fig" rid="F9">Fig. 9</xref>). In the second part of the simulation, when the hidden process values shrink, both filters can capture such a rapid decrease.</p><p id="P101">Initially, the two filters can be both very accurate: as it can be seen in <xref ref-type="table" rid="T5">Table 5</xref>, the difference in their estimates is incredibly small. Moreover, the second filter error bound tends to stay appreciably low until <italic>t</italic><sub>12</sub>. Therefore, during the beginning of the simulation, both filters are to be considered very accurate. However, after 3 seconds, the second FFSP algorithm stops functioning as it loses almost all of its mass (see <xref ref-type="fig" rid="F9">Fig. 9</xref> and <xref ref-type="table" rid="T5">Table 5</xref>). In contrast, the first filter is functioning till the end though its error bound is very large (see <xref ref-type="fig" rid="F9">Fig. 9</xref> and <xref ref-type="table" rid="T5">Table 5</xref>). To conclude, there is no strict preference among the two filters during the early stages of the simulation; the first FFSP algorithm is preferred over the final time, when it can still capture the behaviour of the hidden process despite the large error bound dynamics.</p></sec><sec id="S19"><label>3.3</label><title>Genetic Switch with Feedback: FFSP vs Particle Filter</title><p id="P102">We consider now the following network: <disp-formula id="FD33"><label>(15)</label><mml:math id="M128"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msup><mml:mi>G</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>+</mml:mo><mml:mtext>Protein</mml:mtext><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mover><mml:mi>G</mml:mi></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mi>G</mml:mi><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mover><mml:msup><mml:mi>G</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>+</mml:mo><mml:mtext>Protein</mml:mtext></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:msup><mml:mi>G</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mover><mml:msup><mml:mi>G</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>+</mml:mo><mml:mtext>mRNA</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtext>mRNA</mml:mtext><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>4</mml:mn></mml:msub></mml:mrow></mml:mover><mml:mo>∅</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>mRNA</mml:mtext><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>5</mml:mn></mml:msub></mml:mrow></mml:mover><mml:mtext>mRNA</mml:mtext><mml:mo>+</mml:mo><mml:mtext>Protein</mml:mtext></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>Protein</mml:mtext><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>6</mml:mn></mml:msub></mml:mrow></mml:mover><mml:mo>∅</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula> where <italic>G</italic> and <italic>G*</italic> are inactive and active genes, respectively activated and inactivated by the protein. Moreover, the active gene <italic>G*</italic> transcribes mRNA copy number, which can degrade. In turn, mRNA is responsible for the protein translation, which also degrades. For this network, we decided to employ mass-action kinetics and, thus, the propensity functions are <italic>a</italic><sub>1</sub>(<italic>z</italic><sub>1</sub>, <italic>z</italic><sub>2</sub>, <italic>z</italic><sub>3</sub>, <italic>z</italic><sub>4</sub>) = <italic>c</italic><sub>1</sub><italic>z</italic><sub>2</sub><italic>z</italic><sub>4</sub>, <italic>a</italic><sub>2</sub>(<italic>z</italic><sub>1</sub>, <italic>z</italic><sub>2</sub>, <italic>z</italic><sub>3</sub>, <italic>z</italic><sub>4</sub>) = <italic>c</italic><sub>2</sub><italic>z</italic><sub>1</sub>, <italic>a</italic><sub>3</sub>(<italic>z</italic><sub>1</sub>, <italic>z</italic><sub>2</sub>, <italic>z</italic><sub>3</sub>, <italic>z</italic><sub>4</sub>) = <italic>c</italic><sub>3</sub><italic>z</italic><sub>2</sub>, <italic>a</italic><sub>4</sub>(<italic>z</italic><sub>1</sub>, <italic>z</italic><sub>2</sub>, <italic>z</italic><sub>3</sub>, <italic>z</italic><sub>4</sub>) = <italic>c</italic><sub>4</sub><italic>z</italic><sub>3</sub>, <italic>a</italic><sub>5</sub>(<italic>z</italic><sub>1</sub>, <italic>z</italic><sub>2</sub>, <italic>z</italic><sub>3</sub>, <italic>z</italic><sub>4</sub>) = <italic>c</italic><sub>5</sub><italic>z</italic><sub>3</sub>, and <italic>a</italic><sub>6</sub>(<italic>z</italic><sub>1</sub>, <italic>z</italic><sub>2</sub>, <italic>z</italic><sub>3</sub>, <italic>z</italic><sub>4</sub>) = <italic>c</italic><sub>4</sub><italic>z</italic><sub>3</sub>. We continuously observe protein dynamics and estimate the other remaining species;</p><p id="P103">therefore, we let <inline-formula><mml:math id="M129"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>X</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mn>3</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula> keep track of <italic>G, G*,</italic> and the mRNA and <inline-formula><mml:math id="M130"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> keep track of the protein.</p><p id="P104">In this numerical experiment, we compare the performance of the FFSP and the particle filter in estimating the various hidden species. To this end, we simulated the observed and hidden process trajectories with a Gillespie algorithm, and we fed the former as input to both filters. Moreover, we set <italic>c</italic><sub>1</sub> = 1, <italic>c</italic><sub>2</sub> = 5, <italic>c</italic><sub>3</sub> = 8, <italic>c</italic><sub>4</sub>= 2, <italic>c</italic><sub>5</sub> = 4, <italic>c</italic><sub>6</sub> = 1, <italic>t<sub>f</sub></italic> = 5<italic>s</italic> as final simulation time, and <italic>χ</italic> = {0,… 100} as hidden species truncated state space for the mRNA copy number.</p><p id="P105">In <xref ref-type="fig" rid="F10">Fig. 10</xref>, we can spot the observation and hidden process trajectories, together with the filters’ estimates and standard deviations. We can notice how the protein copy number starts with a slow increase, given that the active gene alternates periods of inactivity to activity and then experiences a sharp outburst once the gene stays mostly active. The same behaviour is overall held also by the mRNA copy number. Regarding the estimations carried out by the filters, we can see that the both filters perform well in tracking both the activated gene and mRNA dynamics.</p></sec><sec id="S20"><label>3.4</label><title>Genetic Switch in a Hybrid Experimental Setup</title><p id="P106">In this subsection, we test the performance of the first FFSP algorithm in genetic switches operated in a hybrid experimental setup, where the protein dynamics is simulated in computers according to the trajectory of fluorescent mRNA molecules in real cells. With this aim, we consider the same genetic switch as before, but without the protein feedback: <disp-formula id="FD34"><label>(16)</label><mml:math id="M131"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msup><mml:mi>G</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mover><mml:mi>G</mml:mi></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mi>G</mml:mi><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mover><mml:msup><mml:mi>G</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:msup><mml:mi>G</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mover><mml:msup><mml:mi>G</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>+</mml:mo><mml:mtext>mRNA</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtext>mRNA</mml:mtext><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>4</mml:mn></mml:msub></mml:mrow></mml:mover><mml:mo>∅</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>mRNA</mml:mtext><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>5</mml:mn></mml:msub></mml:mrow></mml:mover><mml:mtext>mRNA</mml:mtext><mml:mo>+</mml:mo><mml:mtext>Protein</mml:mtext></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>Protein</mml:mtext><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>6</mml:mn></mml:msub></mml:mrow></mml:mover><mml:mo>∅</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula> where <italic>G</italic>and <italic>G</italic>* are inactive and active genes. The active gene <italic>G*</italic> transcribes mRNA copy number, which can degrade. In turn, the mRNA is responsible for the protein translation, which also degrades. Given the lack of feedback, the gene switching together with the mRNA transcription parts of the circuit can be decoupled from the protein translation, resulting in the following reduced models: <disp-formula id="FD35"><label>(17)</label><mml:math id="M132"><mml:mrow><mml:msup><mml:mi>G</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mover><mml:mi>G</mml:mi><mml:mspace width="1em"/><mml:mi>G</mml:mi><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mover><mml:msup><mml:mi>G</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mspace width="1em"/><mml:msup><mml:mi>G</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mover><mml:msup><mml:mi>G</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>+</mml:mo><mml:mtext>mRNA</mml:mtext><mml:mspace width="1em"/><mml:mtext>mRNA</mml:mtext><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>4</mml:mn></mml:msub></mml:mrow></mml:mover><mml:mo>∅</mml:mo><mml:mspace width="0.3em"/><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mtext>First</mml:mtext><mml:mspace width="0.3em"/><mml:mtext>Circuit</mml:mtext></mml:mstyle><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula> and <disp-formula id="FD36"><label>(18)</label><mml:math id="M133"><mml:mrow><mml:mo>∅</mml:mo><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>5</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mtext>mRNA</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:mover><mml:mtext>Protein</mml:mtext><mml:mspace width="1em"/><mml:mtext>Protein</mml:mtext><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>6</mml:mn></mml:msub></mml:mrow></mml:mover><mml:mo>∅</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mtext>Second</mml:mtext><mml:mspace width="0.3em"/><mml:mtext>Circuit</mml:mtext></mml:mstyle><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P107">In particular, the first circuit (<xref ref-type="disp-formula" rid="FD35">17</xref>) was implemented in yeast cells, which were made light-sensitive by tagging the mRNA molecules with fluorescent reporters. Upon a constant light stimulation, the mRNAs’ fluorescence was recorded for four hours under a microscope in an optogenetic platform [<xref ref-type="bibr" rid="R48">48</xref>, <xref ref-type="bibr" rid="R49">49</xref>]. In the experiment, we collected data from 60 yeast cells simultaneously. The second circuit (<xref ref-type="disp-formula" rid="FD36">18</xref>) was simulated <italic>in-silico</italic> through time-varying Gillespie algorithms. Mass-action kinetics were employed for the protein translation and degradation propensities. Furthermore, the mRNA trajectories from the circuit (<xref ref-type="disp-formula" rid="FD35">17</xref>), acquired with microscope measurements, were used as inputs of distinct Gillespie algorithms to generate the protein trajectories. To be more specific, between the mRNA jump times <italic>t<sub>i</sub></italic> ≤ <italic>t</italic> &lt; <italic>t</italic><sub><italic>i</italic>+1</sub>, the mRNA molecular abundance, mRNA(ti), was fed as input parameter of the propensity function responsible for protein translation. Consequently the full protein trajectory was generated as a succession of iterative Gillespie algorithms with the different mRNA molecular abundances as inputs.</p><p id="P108">The main objective, then, is in using these protein trajectories as observation processes and predicting the mRNA dynamics with the first FFSP algorithm. To this end, we considered the whole circuit (<xref ref-type="disp-formula" rid="FD34">16</xref>) and continuously observed protein dynamics and estimated the other remaining species; therefore, we let <inline-formula><mml:math id="M134"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>X</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mn>3</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula> keep track of <italic>G*, G,</italic> and the mRNA and <inline-formula><mml:math id="M135"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> keep track of the protein. Mass action kinetics type propensities were used with the following parameters: <italic>c</italic><sub>1</sub> = 0.2, <italic>c</italic><sub>2</sub> = 0.1, <italic>c</italic><sub>3</sub> = 23, <italic>c</italic><sub>4</sub> = 0.5, <italic>c</italic><sub>5</sub> = 1, <italic>c</italic><sub>6</sub> = 1. Then, the initial condition was set to <bold>X</bold><sub>0</sub> = [0, 1, 0, 0]. The results are shown in <xref ref-type="fig" rid="F11">Fig. 11</xref>. In particular, the top part shows the protein trajectory, generated with the Gillespie algorithm, with the corresponding mRNA abundance as an input; the bottom subplots display the <italic>in-vivo</italic> mRNA trajectories, together with the filters’ estimations. As can be seen in all the three representative cells, the first FFSP algorithm is able to reconstruct the <italic>in-vivo</italic> mRNA trajectories with a very good agreement, showing the potential use of the algorithm for real biological applications.</p></sec></sec><sec id="S21" sec-type="conclusions"><label>4</label><title>Conclusion</title><p id="P109">In this paper, we developed a direct approach to solve the filtering equation for a noise-free observation process in stochastic reaction networks. Specifically, we considered a continuous-time discrete-state Markov Chain <inline-formula><mml:math id="M136"><mml:mrow><mml:mtext>Z</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and assumed to exactly observe the dynamics of some chemical species. To postulate the filtering problem, we subsequently decomposed the network into <inline-formula><mml:math id="M137"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>X</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>χ</mml:mi><mml:mo>⊆</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> hidden species and <inline-formula><mml:math id="M138"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℤ</mml:mi><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> with <italic>n</italic><sub>2</sub> = <italic>n – n<sub>1</sub></italic>, observed species. Thus, we assumed to exactly (noise-free) and time-continuously observe the trajectory of <bold>Y</bold>(<italic>t</italic>) and estimate the hidden species copy number <bold>X</bold>(<italic>t</italic>) dynamics. To be more specific, we wish to compute the conditional distribution <italic>π<sub>t</sub></italic> of the hidden process <bold>X</bold>(<italic>t</italic>) given the trajectory of the observed process <bold>Y</bold>(s) 0 ≤ <italic>s</italic> ≤ <italic>t</italic>. In this setting, such conditional distribution is a piece-wise deterministic Markov process (PDMP): it evolves according to a non-linear dynamical equation and jumps when the observation process does so.</p><p id="P110">This conditional distribution admits an un-normalised version that is also a PDMP and evolves according to a linear evolution equation between the observation process jump times. Moreover, the evolution matrix is similar to the generator matrix of the Chemical Master Equation (CME) and shares several valuable properties. Therefore, we solved the filtering problem by iteratively applying the Finite State Projection Method [<xref ref-type="bibr" rid="R15">15</xref>] to the linear system satisfied by the un-normalised distribution between the observation process jump times. We then recovered the filtering equation’s solution by normalising it before each jump time. This procedure gives rise to the Filtered Finite State Projection Method. Compared to the standard Finite State Projection method, the FFSP’s solution does not have a conserved total mass in time. To be able to carry out the accuracy analysis, we developed a modified FSP theorem to include also such distributions. The modified FSP theorem provides an exact error certificate for setting in which the initial probability distribution is not fully exact. Thanks to this theorem, we then then performed an accuracy analysis which results in a conservative error bound for the approximated solution. To resolve this issue, we provided an alternative algorithm, which exploits a different normalisation technique and results in an exact error certificate as in the FSP theorem [<xref ref-type="bibr" rid="R15">15</xref>], at a cost of narrower applicability.</p><p id="P111">From the numerical experiments in Section <xref ref-type="sec" rid="S8">Section 3</xref>, we observe that the FFSP method accurately estimates the hidden dynamics of several biological networks. Moreover, in the introduction, we demonstrated via a numerical example that our method outperforms established filters, such as the Kalman and Extended Kalman filters, in complex nonlinear networks with feedback and Poisson-type noise. However, in the presence of a linear network and in higher copy number regimes where the observation process mimics Gaussian-type noise, the Kalman filter in section <xref ref-type="sec" rid="S10">Section 3.1.1</xref> shows performance similar to that of the FFSP and particle filters.</p><p id="P112">Additionally, the FFSP exhibits superior performance in estimating the full conditional distribution and rare events compared to the bootstrap particle filters, as shown in section <xref ref-type="sec" rid="S15">Section 3.1.3</xref>. Furthermore, our filter produces accurate estimates when examining the error behavior of the proposed second algorithm. Finally, the FFSP algorithm performs well in reconstructing several <italic>in vivo</italic> mRNA trajectories recorded with a microscope in yeast cells for a genetic switch-type circuit, as seen in Section <xref ref-type="sec" rid="S20">Section 3.4</xref>.</p><p id="P113">All these results suggest that our algorithm could be further employed to explore other biological circuits of interest, whose behaviors are still not fully understood in terms of latent state dynamics.</p><p id="P114">In the future, this work could be extended in several directions. One possible direction is to mitigate the curse of dimensionality. Since our algorithm has to solve an extensive linear system between each observation process jump time, the computational cost grows exponentially with the number of species. Therefore, developing more scalable approaches for high-dimensional filtering equation in the stochastic reaction network framework is needed. A possible approach may reside in using deep learning, as it has been shown to cope quite well with high-dimensional problems in the stochastic reaction networks framework [<xref ref-type="bibr" rid="R54">54</xref>] and other fields [<xref ref-type="bibr" rid="R55">55</xref>]. Second, the algorithm could further be extended by including parameters’ uncertainty, as the exact parameter values are usually unknown to scientists. Moreover, the FFSP can also be applied to solving CMEs with the Rao-Blackwell technique, which entails uncoupling the entire network into two parts and then marginalising out one by computing its conditional probability (see [<xref ref-type="bibr" rid="R56">56</xref>, <xref ref-type="bibr" rid="R57">57</xref>] for the Rao-Blackwell technique and [<xref ref-type="bibr" rid="R45">45</xref>, <xref ref-type="bibr" rid="R46">46</xref>] for the application of this idea together with moment closure to CMEs). The advantage of the Rao-Blackwell method is guaranteed by the Rao-Blackwell theorem (a variant of the law of total variance), suggesting that this method is more accurate than the Monte Carlo one under the same sample size. In this framework, our FFSP is ideal for the marginalisation part of the Rao-Blackwell technique when applied to biochemical reacting systems; some attempts in this direction were reported in [<xref ref-type="bibr" rid="R24">24</xref>].</p></sec><sec sec-type="supplementary-material" id="SM"><title>Supplementary Material</title><supplementary-material content-type="local-data" id="SD1"><label>https://github.com/EleSofi/FFSP_2024_code_data</label><media xlink:href="EMS198840-supplement-https___github_com_EleSofi_FFSP_2024_code_data.pdf" mimetype="application" mime-subtype="pdf" id="d8aAcFbB" position="anchor"/></supplementary-material></sec></body><back><ack id="S22"><title>Acknowledgments</title><p>This work was funded by a grant from the Swiss National Science Foundation (Grant No. 182653).</p></ack><fn-group><fn id="FN1"><label>1</label><p id="P115">The well-posedness of <italic>π</italic>(<italic>t,x</italic>) is guaranteed by [29, Theorem 2.24], and we provide a more detailed discussion about it in the <xref ref-type="supplementary-material" rid="SD1">supplementary material</xref>.</p></fn></fn-group><ref-list><ref id="R1"><label>1</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zhang</surname><given-names>J</given-names></name><name><surname>Campbell</surname><given-names>RE</given-names></name><name><surname>Ting</surname><given-names>AY</given-names></name><name><surname>Tsien</surname><given-names>RY</given-names></name></person-group><article-title>Creating new fluorescent probes for cell biology</article-title><source>Nature reviews Molecular cell biology</source><year>2002</year><volume>3</volume><issue>12</issue><fpage>906</fpage><lpage>918</lpage><pub-id pub-id-type="pmid">12461557</pub-id></element-citation></ref><ref id="R2"><label>2</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stephens</surname><given-names>DJ</given-names></name><name><surname>Allan</surname><given-names>VJ</given-names></name></person-group><article-title>Light microscopy techniques for live cell imaging</article-title><source>science</source><year>2003</year><volume>300</volume><issue>5616</issue><fpage>82</fpage><lpage>86</lpage><pub-id pub-id-type="pmid">12677057</pub-id></element-citation></ref><ref id="R3"><label>3</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Locke</surname><given-names>JC</given-names></name><name><surname>Elowitz</surname><given-names>MB</given-names></name></person-group><article-title>Using movies to analyse gene circuit dynamics in single cells</article-title><source>Nature Reviews Microbiology</source><year>2009</year><volume>7</volume><issue>5</issue><fpage>383</fpage><lpage>392</lpage><pub-id pub-id-type="pmcid">PMC2853934</pub-id><pub-id pub-id-type="pmid">19369953</pub-id><pub-id pub-id-type="doi">10.1038/nrmicro2056</pub-id></element-citation></ref><ref id="R4"><label>4</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rodriguez</surname><given-names>EA</given-names></name><name><surname>Campbell</surname><given-names>RE</given-names></name><name><surname>Lin</surname><given-names>JY</given-names></name><name><surname>Lin</surname><given-names>MZ</given-names></name><name><surname>Miyawaki</surname><given-names>A</given-names></name><name><surname>Palmer</surname><given-names>AE</given-names></name><etal/></person-group><article-title>The growing and glowing toolbox of fluorescent and photoactive proteins</article-title><source>Trends in biochemical sciences</source><year>2017</year><volume>42</volume><issue>2</issue><fpage>111</fpage><lpage>129</lpage><pub-id pub-id-type="pmcid">PMC5272834</pub-id><pub-id pub-id-type="pmid">27814948</pub-id><pub-id pub-id-type="doi">10.1016/j.tibs.2016.09.010</pub-id></element-citation></ref><ref id="R5"><label>5</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wansink</surname><given-names>DG</given-names></name><name><surname>Schul</surname><given-names>W</given-names></name><name><surname>Van Der Kraan</surname><given-names>I</given-names></name><name><surname>Van Steensel</surname><given-names>B</given-names></name><name><surname>Van Driel</surname><given-names>R</given-names></name><name><surname>De Jong</surname><given-names>L</given-names></name></person-group><article-title>Fluorescent labeling of nascent RNA reveals transcription by RNA polymerase II in domains scattered throughout the nucleus</article-title><source>The Journal of cell biology</source><year>1993</year><volume>122</volume><issue>2</issue><fpage>283</fpage><lpage>293</lpage><pub-id pub-id-type="pmcid">PMC2119648</pub-id><pub-id pub-id-type="pmid">8320255</pub-id><pub-id pub-id-type="doi">10.1083/jcb.122.2.283</pub-id></element-citation></ref><ref id="R6"><label>6</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>McAdams</surname><given-names>HH</given-names></name><name><surname>Arkin</surname><given-names>A</given-names></name></person-group><article-title>Stochastic mechanisms in gene expression</article-title><source>Proceedings of the National Academy of Sciences</source><year>1997</year><volume>94</volume><issue>3</issue><fpage>814</fpage><lpage>819</lpage><pub-id pub-id-type="pmcid">PMC19596</pub-id><pub-id pub-id-type="pmid">9023339</pub-id><pub-id pub-id-type="doi">10.1073/pnas.94.3.814</pub-id></element-citation></ref><ref id="R7"><label>7</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Eldar</surname><given-names>A</given-names></name><name><surname>Elowitz</surname><given-names>MB</given-names></name></person-group><article-title>Functional roles for noise in genetic circuits</article-title><source>Nature</source><year>2010</year><volume>467</volume><issue>7312</issue><fpage>167</fpage><lpage>173</lpage><pub-id pub-id-type="pmcid">PMC4100692</pub-id><pub-id pub-id-type="pmid">20829787</pub-id><pub-id pub-id-type="doi">10.1038/nature09326</pub-id></element-citation></ref><ref id="R8"><label>8</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Elowitz</surname><given-names>MB</given-names></name><name><surname>Levine</surname><given-names>AJ</given-names></name><name><surname>Siggia</surname><given-names>ED</given-names></name><name><surname>Swain</surname><given-names>PS</given-names></name></person-group><article-title>Stochastic gene expression in a single cell</article-title><source>Science</source><year>2002</year><volume>297</volume><issue>5584</issue><fpage>1183</fpage><lpage>1186</lpage><pub-id pub-id-type="pmid">12183631</pub-id></element-citation></ref><ref id="R9"><label>9</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Raser</surname><given-names>JM</given-names></name><name><surname>O’shea</surname><given-names>EK</given-names></name></person-group><article-title>Noise in gene expression: origins, consequences, and control</article-title><source>Science</source><year>2005</year><volume>309</volume><issue>5743</issue><fpage>2010</fpage><lpage>2013</lpage><pub-id pub-id-type="pmcid">PMC1360161</pub-id><pub-id pub-id-type="pmid">16179466</pub-id><pub-id pub-id-type="doi">10.1126/science.1105891</pub-id></element-citation></ref><ref id="R10"><label>10</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Suter</surname><given-names>DM</given-names></name><name><surname>Molina</surname><given-names>N</given-names></name><name><surname>Gatfield</surname><given-names>D</given-names></name><name><surname>Schneider</surname><given-names>K</given-names></name><name><surname>Schibler</surname><given-names>U</given-names></name><name><surname>Naef</surname><given-names>F</given-names></name></person-group><article-title>Mammalian genes are transcribed with widely different bursting kinetics</article-title><source>science</source><year>2011</year><volume>332</volume><issue>6028</issue><fpage>472</fpage><lpage>474</lpage><pub-id pub-id-type="pmid">21415320</pub-id></element-citation></ref><ref id="R11"><label>11</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Thomas</surname><given-names>P</given-names></name><name><surname>Popović</surname><given-names>N</given-names></name><name><surname>Grima</surname><given-names>R</given-names></name></person-group><article-title>Phenotypic switching in gene regulatory networks</article-title><source>Proceedings of the National Academy of Sciences</source><year>2014</year><volume>111</volume><issue>19</issue><fpage>6994</fpage><lpage>6999</lpage><pub-id pub-id-type="pmcid">PMC4024914</pub-id><pub-id pub-id-type="pmid">24782538</pub-id><pub-id pub-id-type="doi">10.1073/pnas.1400049111</pub-id></element-citation></ref><ref id="R12"><label>12</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Anderson</surname><given-names>DF</given-names></name><name><surname>Kurtz</surname><given-names>TG</given-names></name></person-group><source>Stochastic analysis of biochemical systems</source><year>2015</year><volume>674</volume><publisher-name>Springer</publisher-name></element-citation></ref><ref id="R13"><label>13</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kaern</surname><given-names>M</given-names></name><name><surname>Elston</surname><given-names>TC</given-names></name><name><surname>Blake</surname><given-names>WJ</given-names></name><name><surname>Collins</surname><given-names>JJ</given-names></name></person-group><article-title>Stochasticity in gene expression: from theories to phenotypes</article-title><source>Nature Reviews Genetics</source><year>2005</year><volume>6</volume><issue>6</issue><fpage>451</fpage><lpage>464</lpage><pub-id pub-id-type="pmid">15883588</pub-id></element-citation></ref><ref id="R14"><label>14</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gillespie</surname><given-names>DT</given-names></name></person-group><article-title>Exact stochastic simulation of coupled chemical reactions</article-title><source>The journal of physical chemistry</source><year>1977</year><volume>81</volume><issue>25</issue><fpage>2340</fpage><lpage>2361</lpage></element-citation></ref><ref id="R15"><label>15</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Munsky</surname><given-names>B</given-names></name><name><surname>Khammash</surname><given-names>M</given-names></name></person-group><article-title>The finite state projection algorithm for the solution of the chemical master equation</article-title><source>The Journal of chemical physics</source><year>2006</year><volume>124</volume><issue>4</issue><elocation-id>044104</elocation-id><pub-id pub-id-type="pmid">16460146</pub-id></element-citation></ref><ref id="R16"><label>16</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gillespie</surname><given-names>DT</given-names></name></person-group><article-title>A general method for numerically simulating the stochastic time evolution of coupled chemical reactions</article-title><source>Journal of computational physics</source><year>1976</year><volume>22</volume><issue>4</issue><fpage>403</fpage><lpage>434</lpage></element-citation></ref><ref id="R17"><label>17</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gibson</surname><given-names>MA</given-names></name><name><surname>Bruck</surname><given-names>J</given-names></name></person-group><article-title>Efficient exact stochastic simulation of chemical systems with many species and many channels</article-title><source>The journal of physical chemistry A</source><year>2000</year><volume>104</volume><issue>9</issue><fpage>1876</fpage><lpage>1889</lpage></element-citation></ref><ref id="R18"><label>18</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Anderson</surname><given-names>DF</given-names></name></person-group><article-title>A modified next reaction method for simulating chemical systems with time dependent propensities and delays</article-title><source>The Journal of chemical physics</source><year>2007</year><volume>127</volume><issue>21</issue><elocation-id>214107</elocation-id><pub-id pub-id-type="pmid">18067349</pub-id></element-citation></ref><ref id="R19"><label>19</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schnoerr</surname><given-names>D</given-names></name><name><surname>Sanguinetti</surname><given-names>G</given-names></name><name><surname>Grima</surname><given-names>R</given-names></name></person-group><article-title>Approximation and inference methods for stochastic biochemical kinetics—a tutorial review</article-title><source>Journal of Physics A: Mathematical and Theoretical</source><year>2017</year><volume>50</volume><issue>9</issue><elocation-id>093001</elocation-id></element-citation></ref><ref id="R20"><label>20</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schnoerr</surname><given-names>D</given-names></name><name><surname>Sanguinetti</surname><given-names>G</given-names></name><name><surname>Grima</surname><given-names>R</given-names></name></person-group><article-title>Comparison of different moment-closure approximations for stochastic chemical kinetics</article-title><source>The Journal of Chemical Physics</source><year>2015</year><volume>143</volume><issue>18</issue><elocation-id>11B610_1</elocation-id><pub-id pub-id-type="pmid">26567686</pub-id></element-citation></ref><ref id="R21"><label>21</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Grima</surname><given-names>R</given-names></name></person-group><article-title>A study of the accuracy of moment-closure approximations for stochastic chemical kinetics</article-title><source>The Journal of chemical physics</source><year>2012</year><volume>136</volume><issue>15</issue><elocation-id>04B616</elocation-id><pub-id pub-id-type="pmid">22519313</pub-id></element-citation></ref><ref id="R22"><label>22</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ullah</surname><given-names>M</given-names></name><name><surname>Wolkenhauer</surname><given-names>O</given-names></name></person-group><article-title>Investigating the two-moment characterisation of subcellular biochemical networks</article-title><source>Journal of theoretical biology</source><year>2009</year><volume>260</volume><issue>3</issue><fpage>340</fpage><lpage>352</lpage><pub-id pub-id-type="pmid">19500597</pub-id></element-citation></ref><ref id="R23"><label>23</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rathinam</surname><given-names>M</given-names></name><name><surname>Yu</surname><given-names>M</given-names></name></person-group><article-title>Stochastic Filtering of Reaction Networks Partially Observed in Time Snapshots</article-title><source>arXiv preprint</source><year>2023</year><elocation-id>arXiv:230716734</elocation-id></element-citation></ref><ref id="R24"><label>24</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fang</surname><given-names>Z</given-names></name><name><surname>Gupta</surname><given-names>A</given-names></name><name><surname>Khammash</surname><given-names>M</given-names></name></person-group><article-title>A scalable approach for solving chemical master equations based on modularization and filtering</article-title><source>bioRxiv</source><year>2022</year><fpage>2022</fpage><lpage>10</lpage></element-citation></ref><ref id="R25"><label>25</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Huang</surname><given-names>L</given-names></name><name><surname>Pauleve</surname><given-names>L</given-names></name><name><surname>Zechner</surname><given-names>C</given-names></name><name><surname>Unger</surname><given-names>M</given-names></name><name><surname>Hansen</surname><given-names>AS</given-names></name><name><surname>Koeppl</surname><given-names>H</given-names></name></person-group><article-title>Reconstructing dynamic molecular states from single-cell time series</article-title><source>Journal of The Royal Society Interface</source><year>2016</year><volume>13</volume><issue>122</issue><elocation-id>20160533</elocation-id><pub-id pub-id-type="pmcid">PMC5046952</pub-id><pub-id pub-id-type="pmid">27605167</pub-id><pub-id pub-id-type="doi">10.1098/rsif.2016.0533</pub-id></element-citation></ref><ref id="R26"><label>26</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rathinam</surname><given-names>M</given-names></name><name><surname>Yu</surname><given-names>M</given-names></name></person-group><article-title>State and parameter estimation from exact partial state observation in stochastic reaction networks</article-title><source>The Journal of Chemical Physics</source><year>2021</year><volume>154</volume><issue>3</issue><elocation-id>034103</elocation-id><pub-id pub-id-type="pmid">33499627</pub-id></element-citation></ref><ref id="R27"><label>27</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fang</surname><given-names>Z</given-names></name><name><surname>Gupta</surname><given-names>A</given-names></name><name><surname>Khammash</surname><given-names>M</given-names></name></person-group><article-title>Convergence of regularized particle filters for stochastic reaction networks</article-title><source>SIAM Journal on Numerical Analysis</source><year>2023</year><volume>61</volume><issue>2</issue><fpage>399</fpage><lpage>430</lpage></element-citation></ref><ref id="R28"><label>28</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Fang</surname><given-names>Z</given-names></name><name><surname>Gupta</surname><given-names>A</given-names></name><name><surname>Khammash</surname><given-names>M</given-names></name></person-group><source>Stochastic filters based on hybrid approximations of multiscale stochastic reaction networks</source><conf-name>2020 59th IEEE Conference on Decision and Control (CDC)</conf-name><year>2020</year><fpage>4616</fpage><lpage>4621</lpage><conf-sponsor>IEEE</conf-sponsor></element-citation></ref><ref id="R29"><label>29</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Bain</surname><given-names>A</given-names></name><name><surname>Crisan</surname><given-names>D</given-names></name></person-group><source>Fundamentals of stochastic filtering</source><year>2009</year><volume>3</volume><publisher-name>Springer</publisher-name></element-citation></ref><ref id="R30"><label>30</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Briat</surname><given-names>C</given-names></name><name><surname>Khammash</surname><given-names>M</given-names></name></person-group><article-title>Noise in biomolecular systems: Modeling, analysis, and control implications</article-title><source>Annual Review of Control Robotics, and Autonomous Systems</source><year>2023</year><volume>6</volume><fpage>283</fpage><lpage>311</lpage></element-citation></ref><ref id="R31"><label>31</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kalman</surname><given-names>RE</given-names></name></person-group><article-title>A new approach to linear filtering and prediction problems</article-title><source>Journal of Fluids Engineering, Transactions of the ASME</source><year>1960</year></element-citation></ref><ref id="R32"><label>32</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kalman</surname><given-names>RE</given-names></name><name><surname>Bucy</surname><given-names>RS</given-names></name></person-group><article-title>New Results in Linear Filtering and Prediction Theory</article-title><source>Journal of Basic Engineering</source><year>1961</year><volume>83</volume><issue>1</issue><fpage>95</fpage><lpage>108</lpage><pub-id pub-id-type="doi">10.1115/1.3658902</pub-id></element-citation></ref><ref id="R33"><label>33</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Grewal</surname><given-names>MS</given-names></name><name><surname>Andrews</surname><given-names>AP</given-names></name></person-group><article-title>Applications of Kalman filtering in aerospace 1960 to the present [historical perspectives]</article-title><source>IEEE Control Systems Magazine</source><year>2010</year><volume>30</volume><issue>3</issue><fpage>69</fpage><lpage>78</lpage></element-citation></ref><ref id="R34"><label>34</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stratonovich</surname><given-names>RL</given-names></name></person-group><article-title>Conditional Markov Processes</article-title><source>Theory of Probability &amp; Its Applications</source><year>1960</year></element-citation></ref><ref id="R35"><label>35</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kushner</surname><given-names>HJ</given-names></name></person-group><article-title>On the dynamical equations of conditional probability density functions, with applications to optimal stochastic control theory</article-title><source>Journal of Mathematical Analysis and Applications</source><year>1964</year></element-citation></ref><ref id="R36"><label>36</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Maurel</surname><given-names>MC</given-names></name><name><surname>Michel</surname><given-names>D</given-names></name></person-group><article-title>Des resultats de non existence de filtre de dimension finie</article-title><source>Stochastics</source><year>1984</year></element-citation></ref><ref id="R37"><label>37</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gordon</surname><given-names>N</given-names></name><name><surname>Salmond</surname><given-names>DJ</given-names></name><name><surname>Smith</surname><given-names>AFM</given-names></name></person-group><source>Novel approach to nonlinear and linear Bayesian state estimation</source><year>1993</year></element-citation></ref><ref id="R38"><label>38</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sun</surname><given-names>X</given-names></name><name><surname>Jin</surname><given-names>L</given-names></name><name><surname>Xiong</surname><given-names>M</given-names></name></person-group><article-title>Extended Kalman filter for estimation of parameters in nonlinear state-space models of biochemical networks</article-title><source>PloS one</source><year>2008</year><volume>3</volume><issue>11</issue><elocation-id>e3758</elocation-id><pub-id pub-id-type="pmcid">PMC2582954</pub-id><pub-id pub-id-type="pmid">19018286</pub-id><pub-id pub-id-type="doi">10.1371/journal.pone.0003758</pub-id></element-citation></ref><ref id="R39"><label>39</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chuang</surname><given-names>CH</given-names></name><name><surname>Lin</surname><given-names>CL</given-names></name><etal/></person-group><article-title>Robust estimation of stochastic gene-network systems</article-title><source>Journal of Biomedical Science and Engineering</source><year>2013</year><volume>6</volume><issue>02</issue><fpage>213</fpage></element-citation></ref><ref id="R40"><label>40</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Calderazzo</surname><given-names>S</given-names></name><name><surname>Brancaccio</surname><given-names>M</given-names></name><name><surname>Finkenstädt</surname><given-names>B</given-names></name></person-group><article-title>Filtering and inference for stochastic oscillators with distributed delays</article-title><source>Bioinformatics</source><year>2019</year><volume>35</volume><issue>8</issue><fpage>1380</fpage><lpage>1387</lpage><pub-id pub-id-type="pmcid">PMC6477979</pub-id><pub-id pub-id-type="pmid">30202930</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/bty782</pub-id></element-citation></ref><ref id="R41"><label>41</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>X</given-names></name><name><surname>Niranjan</surname><given-names>M</given-names></name></person-group><article-title>State and parameter estimation of the heat shock response system using Kalman and particle filters</article-title><source>Bioinformatics</source><year>2012</year><volume>28</volume><issue>11</issue><fpage>1501</fpage><lpage>1507</lpage><pub-id pub-id-type="pmid">22539674</pub-id></element-citation></ref><ref id="R42"><label>42</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Boys</surname><given-names>RJ</given-names></name><name><surname>Wilkinson</surname><given-names>DJ</given-names></name><name><surname>Kirkwood</surname><given-names>TB</given-names></name></person-group><article-title>Bayesian inference for a discretely observed stochastic kinetic model</article-title><source>Statistics and Computing</source><year>2008</year><volume>18</volume><issue>2</issue><fpage>125</fpage><lpage>135</lpage></element-citation></ref><ref id="R43"><label>43</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Golightly</surname><given-names>A</given-names></name><name><surname>Wilkinson</surname><given-names>DJ</given-names></name></person-group><article-title>Bayesian sequential inference for stochastic kinetic biochemical network models</article-title><source>Journal of Computational Biology</source><year>2006</year><volume>13</volume><issue>3</issue><fpage>838</fpage><lpage>851</lpage><pub-id pub-id-type="pmid">16706729</pub-id></element-citation></ref><ref id="R44"><label>44</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fang</surname><given-names>Z</given-names></name><name><surname>Gupta</surname><given-names>A</given-names></name><name><surname>Khammash</surname><given-names>M</given-names></name></person-group><article-title>Stochastic filtering for multiscale stochastic reaction networks based on hybrid approximations</article-title><source>Journal of Computational Physics</source><year>2022</year><volume>467</volume><elocation-id>111441</elocation-id></element-citation></ref><ref id="R45"><label>45</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zechner</surname><given-names>C</given-names></name><name><surname>Koeppl</surname><given-names>H</given-names></name></person-group><article-title>Uncoupled analysis of stochastic reaction networks in fluctuating environments</article-title><source>PLoS computational biology</source><year>2014</year><volume>10</volume><issue>12</issue><elocation-id>e1003942</elocation-id><pub-id pub-id-type="pmcid">PMC4256010</pub-id><pub-id pub-id-type="pmid">25473849</pub-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1003942</pub-id></element-citation></ref><ref id="R46"><label>46</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Duso</surname><given-names>L</given-names></name><name><surname>Zechner</surname><given-names>C</given-names></name></person-group><article-title>Selected-node stochastic simulation algorithm</article-title><source>The Journal of chemical physics</source><year>2018</year><volume>148</volume><issue>16</issue><elocation-id>164108</elocation-id><pub-id pub-id-type="pmid">29716216</pub-id></element-citation></ref><ref id="R47"><label>47</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Wiederanders</surname><given-names>HJ</given-names></name><name><surname>Moor</surname><given-names>AL</given-names></name><name><surname>Zechner</surname><given-names>C</given-names></name></person-group><source>Automated Generation of Conditional Moment Equations for Stochastic Reaction Networks</source><conf-name>International Conference on Computational Methods in Systems Biology</conf-name><year>2022</year><fpage>286</fpage><lpage>293</lpage><conf-sponsor>Springer</conf-sponsor></element-citation></ref><ref id="R48"><label>48</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kumar</surname><given-names>S</given-names></name><name><surname>Rullan</surname><given-names>M</given-names></name><name><surname>Khammash</surname><given-names>M</given-names></name></person-group><article-title>Rapid prototyping and design of cybergenetic single-cell controllers</article-title><source>Nature communications</source><year>2021</year><volume>12</volume><issue>1</issue><fpage>1</fpage><lpage>13</lpage><pub-id pub-id-type="pmcid">PMC8463601</pub-id><pub-id pub-id-type="pmid">34561433</pub-id><pub-id pub-id-type="doi">10.1038/s41467-021-25754-6</pub-id></element-citation></ref><ref id="R49"><label>49</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rullan</surname><given-names>M</given-names></name><name><surname>Benzinger</surname><given-names>D</given-names></name><name><surname>Schmidt</surname><given-names>GW</given-names></name><name><surname>Milias-Argeitis</surname><given-names>A</given-names></name><name><surname>Khammash</surname><given-names>M</given-names></name></person-group><article-title>An Optogenetic Platform for Real-Time, Single-Cell Interrogation of Stochastic Transcriptional Regulation</article-title><source>Molecular Cell</source><year>2018</year><volume>70</volume><issue>4</issue><fpage>745</fpage><lpage>756</lpage><elocation-id>e6</elocation-id><pub-id pub-id-type="pmcid">PMC5971206</pub-id><pub-id pub-id-type="pmid">29775585</pub-id><pub-id pub-id-type="doi">10.1016/j.molcel.2018.04.012</pub-id></element-citation></ref><ref id="R50"><label>50</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Confortola</surname><given-names>F</given-names></name><name><surname>Fuhrman</surname><given-names>M</given-names></name></person-group><article-title>Filtering of continuous-time Markov chains with noise-free observation and applications</article-title><source>Stochastics An International Journal of Probability and Stochastic Processes</source><year>2013</year><volume>85</volume><issue>2</issue><fpage>216</fpage><lpage>251</lpage></element-citation></ref><ref id="R51"><label>51</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gupta</surname><given-names>A</given-names></name><name><surname>Briat</surname><given-names>C</given-names></name><name><surname>Khammash</surname><given-names>M</given-names></name></person-group><article-title>A scalable computational framework for establishing long-term behavior of stochastic reaction networks</article-title><source>PLoS computational biology</source><year>2014</year><volume>10</volume><issue>6</issue><elocation-id>e1003669</elocation-id><pub-id pub-id-type="pmcid">PMC4072526</pub-id><pub-id pub-id-type="pmid">24968191</pub-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1003669</pub-id></element-citation></ref><ref id="R52"><label>52</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lunz</surname><given-names>D</given-names></name><name><surname>Batt</surname><given-names>G</given-names></name><name><surname>Ruess</surname><given-names>J</given-names></name><name><surname>Bonnans</surname><given-names>JF</given-names></name></person-group><article-title>Beyond the chemical master equation: stochastic chemical kinetics coupled with auxiliary processes</article-title><source>PLoS Computational Biology</source><year>2021</year><volume>17</volume><issue>7</issue><elocation-id>e1009214</elocation-id><pub-id pub-id-type="pmcid">PMC8352075</pub-id><pub-id pub-id-type="pmid">34319979</pub-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1009214</pub-id></element-citation></ref><ref id="R53"><label>53</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gardner</surname><given-names>TS</given-names></name><name><surname>Cantor</surname><given-names>CR</given-names></name><name><surname>Collins</surname><given-names>JJ</given-names></name></person-group><article-title>Construction of a genetic toggle switch in Escherichia coli</article-title><source>Nature</source><year>2000</year><volume>403</volume><issue>6767</issue><fpage>339</fpage><lpage>342</lpage><pub-id pub-id-type="pmid">10659857</pub-id></element-citation></ref><ref id="R54"><label>54</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gupta</surname><given-names>A</given-names></name><name><surname>Schwab</surname><given-names>C</given-names></name><name><surname>Khammash</surname><given-names>M</given-names></name></person-group><article-title>DeepCME: A deep learning framework for computing solution statistics of the chemical master equation</article-title><source>PLoS computational biology</source><year>2021</year><volume>17</volume><issue>12</issue><elocation-id>e1009623</elocation-id><pub-id pub-id-type="pmcid">PMC8687598</pub-id><pub-id pub-id-type="pmid">34879062</pub-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1009623</pub-id></element-citation></ref><ref id="R55"><label>55</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Han</surname><given-names>J</given-names></name><name><surname>Jentzen</surname><given-names>A</given-names></name><name><surname>E</surname><given-names>W</given-names></name></person-group><article-title>Solving high-dimensional partial differential equations using deep learning</article-title><source>Proceedings of the National Academy of Sciences</source><year>2018</year><volume>115</volume><issue>34</issue><fpage>8505</fpage><lpage>8510</lpage><pub-id pub-id-type="pmcid">PMC6112690</pub-id><pub-id pub-id-type="pmid">30082389</pub-id><pub-id pub-id-type="doi">10.1073/pnas.1718942115</pub-id></element-citation></ref><ref id="R56"><label>56</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Rao</surname><given-names>CR</given-names></name></person-group><chapter-title>Information and the accuracy attainable in the estimation of statistical parameters</chapter-title><source>Breakthroughs in statistics</source><year>1992</year><fpage>235</fpage><lpage>247</lpage><publisher-name>Springer</publisher-name></element-citation></ref><ref id="R57"><label>57</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Blackwell</surname><given-names>D</given-names></name></person-group><article-title>Conditional expectation and unbiased sequential estimation</article-title><source>The Annals of Mathematical Statistics</source><year>1947</year><fpage>105</fpage><lpage>110</lpage></element-citation></ref></ref-list></back><floats-group><boxed-text id="BX1" position="float" orientation="portrait"><caption><title>Author Summary</title></caption><p>The aim of this paper is to introduce a novel computational approach for numerically solving high-dimensional filtering problems associated with stochastic reaction network models in intracellular processes. This method, termed the Filtered Finite State Projection (FFSP) method, can reliably predict the dynamics of hidden species in reaction systems based on time-course measurements of the stochastic trajectories of certain species. While stochastic filtering is extensively utilised in engineering, its application in biology has been limited, primarily due to the nonlinear nature of biological interactions and the discrete, non-Gaussian nature of state variables. Traditional filtering techniques, such as the Kalman filter, often encounter difficulties under these conditions. We demonstrate that the FFSP method provides an accurate solution to the stochastic filtering problem, complete with a computable error bound. We present several numerical examples to showcase the effectiveness of FFSP and its superior performance compared to other filtering methodologies. Additionally, we apply FFSP to biological data, successfully reconstructing the hidden dynamics of a yeast transcription system from partial measurements obtained through time-lapse microscopy. We believe that FFSP could be a valuable tool for elucidating hidden intracellular dynamics and understanding stochastic cellular behaviours.</p></boxed-text><fig id="F1" position="float"><label>Fig. 1</label><caption><title>Non-Linear Network with Feedback.</title><p><bold>a). Chemical Reaction Network Structure:</bold>The hidden species <italic>Z</italic><sub>1</sub> and <italic>Z</italic><sub>2</sub>, highlighted in red, are produced and jointly degraded. They also catalytically influence the production of <italic>X</italic><sub>1</sub>, the observed species in the network.</p><p><bold>b). Observation SSA Process Trajectory:</bold>The trajectory of species <italic>X</italic><sub>1</sub> is fed as input to the filters in panel (d).</p><p><bold>c). Chemical Reactions Structure:</bold>The network’s chemical reactions are structured with the following parameters: <italic>c</italic><sub>1</sub> = 10, <italic>c</italic><sub>2</sub> = 10, <italic>c</italic><sub>3</sub> = 0.5, <italic>c</italic><sub>4</sub> = 0, <italic>c</italic><sub>5</sub> = 0.5, <italic>k</italic><sub>1</sub> = 1000, <italic>k</italic><sub>2</sub> = 1, <italic>k</italic><sub>3</sub> = 1000, <italic>k</italic><sub>4</sub> = 0.04. The initial condition is [<italic>z</italic><sub>10</sub>,<italic>Z</italic><sub>20</sub>, <italic>X</italic><sub>10</sub>]<sup><italic>T</italic></sup> = [0, 0, 0]<sup><italic>T</italic></sup>.</p><p><bold>d). Filter Performance and Estimations:</bold>The Kalman and Extended Kalman filters, Bootstrap Particle Filter (BPF), and FFSP conditional expectations and variance estimations are plotted against the exact hidden trajectories of <italic>Z</italic><sub>1</sub> and <italic>Z</italic><sub>2</sub>, corresponding to the observation process trajectory shown in panel (b).</p></caption><graphic xlink:href="EMS198840-f001"/></fig><fig id="F2" position="float"><label>Fig. 2</label><caption><title>Transcription-Translation Network</title><p><bold>a). Chemical Reaction Network Structure</bold>: The hidden species <italic>P</italic>, highlighted in blue, is being translated by the observed species <italic>M</italic>, highlighted in red, which in turn is being produced and degraded.</p><p><bold>b). Observation SSA Process Trajectory</bold>: The trajectory of species <italic>M</italic> for which the conditional distribution and the relative errors have been computed in panel (d).</p><p><bold>c). Chemical Reactions Structure</bold>: The network’s chemical reactions are structured with the following parameters: <italic>c</italic><sub>1</sub> = 1, <italic>c</italic><sub>2</sub> =5, <italic>c</italic><sub>3</sub> = 1 and initial conditions [<italic>p</italic><sub>0</sub>, <italic>m<sub>0</sub>]<sup>T</sup></italic> = [0, 5]<sup><italic>T</italic></sup></p><p><bold>d). Conditional Distribution Comparison</bold>: Estimation of the conditional distribution of the network for the trajectory given in panel (b) computed with a bootstrap particle filtering (BPF) with <italic>N =</italic> 1000 particles and compared with the exact analytic expression.</p><p><bold>e). Relative Errors</bold> for different particle sizes of the <italic>L<sub>1</sub></italic> difference of the exact and estimated conditional distributions.</p><p><bold>f). Computational Times</bold> for the different particle filters sizes.</p></caption><graphic xlink:href="EMS198840-f002"/></fig><fig id="F3" position="float"><label>Fig. 3</label><caption><title>Performance of the FFSP, Kalman filter, and bootstrap particle filter (BPF) in the simple transcription-translation model.</title><p>The first plot shows protein dynamics (the observation process) up to the final time. The second plot shows the exact trajectory of the mRNA dynamics (the hidden process) and the conditional mean estimates by three stochastic filters together with their standard deviations.</p></caption><graphic xlink:href="EMS198840-f003"/></fig><fig id="F4" position="float"><label>Fig. 4</label><caption><title>Comparison of the two FFSP algorithms in the simple transcription-translation model with a low protein production rate.</title><p>The first plot shows the protein dynamics (the observation process) up to the final time. The second plot shows the exact trajectory of the mRNA dynamics (the hidden process) and the conditional mean estimates by the two FFSP algorithms (FFSP 1 and FFSP 2) together with their standard deviations. Specifically, the FFSP algorithms succeed in following the trend of the mRNA dyanmics and show a good agreement on their estimates, corroborating their equivalence.</p></caption><graphic xlink:href="EMS198840-f004"/></fig><fig id="F5" position="float"><label>Fig. 5</label><caption><title>Comparison of the two FFSP algorithms in the simple transcription-translation model with a high protein production rate.</title><p>The first plot shows protein dynamics (the observation process) up to the final time. The second plot shows the exact trajectory of the mRNA dynamics (the hidden process) and the conditional mean estimates by the two FFSP algorithm together with their standard deviations. Both the FFSP algorithms (FFSP 1 and FFSP 2) perform really well in estimating the hidden process dynamics, but their mean estimates diverge after around 1.8 seconds.</p></caption><graphic xlink:href="EMS198840-f005"/></fig><fig id="F6" position="float"><label>Fig. 6</label><caption><title>Comparison of the two FFSP algorithms in the simple transcription-translation model with a high protein production rate but less observable jumps.</title><p>The first plot shows protein dynamics (the observation process) up to the final time. The second plot shows the exact trajectory of the mRNA dynamics (the hidden process) and the conditional mean estimates by the two stochastic filters together with their standard deviations. The two FFSP algorithms (FFSP 1 and FFSP 2) agree on all their estimates of the hidden process.</p></caption><graphic xlink:href="EMS198840-f006"/></fig><fig id="F7" position="float"><label>Fig. 7</label><caption><title>Comparison of the FFSP and bootstrap particle filter (BPF) in the simple transcription-translation model (observing the mRNA dynamics).</title><p>The left column shows the observation and hidden process trajectories, together with the stochastic filters estimates and standard deviations, until the final simulation time. The top right plot, instead, displays a comparison between the exact conditional distribution and the ones estimated by the FFSP (<xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref>) and the particle filter at t=3s. The bottom right plot, instead, depicts the relative error of the filters from the exact conditional distribution. The result shows that the two filters have a similar performance in estimating the conditional mean and variance, but the FFSP is far more accurate in approximating the exact conditional distribution. Moreover, the particle filter takes 29.9s to be executed and the FFSP, in contrast, 11.3s, being 3 times faster.</p></caption><graphic xlink:href="EMS198840-f007"/></fig><fig id="F8" position="float"><label>Fig. 8</label><caption><title>Performance of the two FFSP algorithms in the genetic toggle switch model (strong repression).</title><p>The first plot shows the <italic>S<sub>2</sub></italic> (the observation process) copy number up to the final time. The second plot shows the exact trajectory of the <italic>S</italic><sub>1</sub> dynamics (the hidden process) and the conditional mean estimates by the two stochastic filters together with their standard deviations. The two FFSP algorithms (FFSP 1 and FFSP 2 in the figure’s legend) agree on all the estimations of the hidden process and succeed in following the trend of the hidden process.</p></caption><graphic xlink:href="EMS198840-f008"/></fig><fig id="F9" position="float"><label>Fig. 9</label><caption><title>Performance of two FFSP algorithms in the genetic toggle switch model (mild repression).</title><p>The first plot shows the <italic>S</italic><italic>2</italic> (the observation process) copy number up to the final time. The second plot shows the exact trajectory of the Si dynamics (the hidden process) and the conditional mean estimates by the two stochastic filters together with their standard deviations. The two FFSP algorithms (FFSP 1 and FFSP 2 in the figure’s legend) agree on all the estimations of the hidden process until time <italic>t</italic> = 3<sub><italic>s</italic></sub>, after which only the first FFSP filter is still able to better capture the latent states.</p></caption><graphic xlink:href="EMS198840-f009"/></fig><fig id="F10" position="float"><label>Fig. 10</label><caption><title>Performance of the FFSP and bootstrap particle filter (BPF) algorithms in the genetic switch model.</title><p>The first plot shows the protein copy number up to the final time. The second and third plots show the exact trajectory of the activated gene and mRNA dynamics, respectively; also, we present their conditional mean estimates by the two stochastic filters together with the standard deviations. The FFSP shows a better performance in estimating both the activated gene and mRNA copy number over the particle filter, which instead underestimates the actual values overall.</p></caption><graphic xlink:href="EMS198840-f010"/></fig><fig id="F11" position="float"><label>Fig. 11</label><caption><title>Performance of the FFSP algorithm in reconstructing the <italic>in-vivo</italic> mRNA trajectories of genetic switches operated in a hybrid experimental setup.</title><p>The top subplots depict the protein trajectories employed as observation processes to predict the <italic>in-vivo</italic> mRNA trajectories. The bottom subplots show the in-vivo mRNA trajectories recorded with the microscope together with the FFSP estimates. The filter reproduces remarkably well all the three cases. Source data are provided in the source data file.</p></caption><graphic xlink:href="EMS198840-f011"/></fig><table-wrap id="T1" position="float" orientation="portrait"><label>Table 1</label><caption><p>Comparisons of the two FFSP algorithm in terms of the error bound, actual accuracy, and applicability. The first FFSP algorithm can be applied to any chemical reacting system, while the second one requires the network to satisfy condition (<xref ref-type="disp-formula" rid="FD18">11</xref>). However, both algorithms need condition (<xref ref-type="disp-formula" rid="FD18">11</xref>) to be satisfied by the chemical reacting system in order to apply the accuracy analysis theorems.</p></caption><table frame="box" rules="all"><tbody><tr><td align="center" valign="top"/><td align="center" valign="top">First FFSP algorithm (<xref ref-type="boxed-text" rid="BX2">Algorithm 1</xref>)</td><td align="center" valign="top">Second FFSP algorithm (<xref ref-type="boxed-text" rid="BX3">Algorithm 2</xref>)</td></tr><tr><td align="center" valign="top">Error bound</td><td align="center" valign="top">A loose error bound</td><td align="center" valign="top">An exact error bound <inline-graphic xlink:href="EMS198840-i001.jpg"/></td></tr><tr><td align="center" valign="top">Actual accuracy</td><td align="center" valign="top">Unknown</td><td align="center" valign="top">Computable</td></tr><tr><td align="center" valign="top">Applicability</td><td align="center" valign="top">All chemical reacting systems <inline-graphic xlink:href="EMS198840-i002.jpg"/></td><td align="center" valign="top">Chemical reacting systems satisfying (<xref ref-type="disp-formula" rid="FD18">11</xref>)</td></tr></tbody></table></table-wrap><table-wrap id="T2" position="float" orientation="portrait"><label>Table 2</label><caption><p>Error bounds of the two FFSP algorithms in case of the low protein production rate. The last line shows the <italic>L</italic><sub>1</sub> distance between the conditional distributions provided by the two FFSP algorithms.</p></caption><table frame="box" rules="all"><thead><tr><th align="center" valign="top"/><th align="center" valign="top"><italic>t</italic><sub>0</sub></th><th align="center" valign="top"><italic>t</italic><sub>1</sub></th><th align="center" valign="top"><italic>t</italic><sub>4</sub></th><th align="center" valign="top"><italic>t</italic><sub>8</sub></th><th align="center" valign="top"><italic>t</italic><sub>14</sub></th><th align="center" valign="top"><italic>t</italic><sub>17</sub></th><th align="center" valign="top"><italic>t</italic><sub>21</sub></th></tr></thead><tbody><tr><td align="left" valign="top">Jump times</td><td align="center" valign="top">0</td><td align="center" valign="top">0.09</td><td align="center" valign="top">0.43</td><td align="center" valign="top">0.78</td><td align="center" valign="top">0.92</td><td align="center" valign="top">1.3</td><td align="center" valign="top">1.9</td></tr><tr><td align="left" valign="top">1<sup>st</sup> FFSP’s error bound</td><td align="center" valign="top">0</td><td align="center" valign="top">1 × 10<sup>−1</sup></td><td align="center" valign="top">2</td><td align="center" valign="top">2</td><td align="center" valign="top">2</td><td align="center" valign="top">2</td><td align="center" valign="top">2</td></tr><tr><td align="left" valign="top">2<sup>nd</sup>FFSP’s error bound</td><td align="center" valign="top">0</td><td align="center" valign="top">&lt; 10<sup>−15</sup></td><td align="center" valign="top">&lt; 10<sup>−15</sup></td><td align="center" valign="top">4.9 ×10<sup>−15</sup></td><td align="center" valign="top">8.2 ×10<sup>−2</sup></td><td align="center" valign="top">6.9 ×10<sup>−9</sup></td><td align="center" valign="top">1.6 ×10<sup>−4</sup></td></tr><tr><td align="left" valign="top">Filter difference</td><td align="center" valign="top">0</td><td align="center" valign="top">&lt; 10<sup>−15</sup></td><td align="center" valign="top">&lt; 10<sup>−15</sup></td><td align="center" valign="top">4.9 ×10<sup>−15</sup></td><td align="center" valign="top">8.2 ×10<sup>−12</sup></td><td align="center" valign="top">6.9 ×10<sup>−9</sup></td><td align="center" valign="top">1.6 ×10<sup>−4</sup></td></tr></tbody></table></table-wrap><table-wrap id="T3" position="float" orientation="portrait"><label>Table 3</label><caption><title>Error bounds of the two FFSP algorithms in case of the high protein production rate. The last line shows the <italic>L</italic><sub>1</sub> distance between the conditional distributions provided by the two FFSP algorithms.</title></caption><table frame="box" rules="all"><thead><tr><th align="center" valign="top"/><th align="center" valign="top"><italic>t</italic><sub>0</sub></th><th align="center" valign="top"><italic>t</italic><sub>1</sub></th><th align="center" valign="top"><italic>t</italic><sub>2</sub></th><th align="center" valign="top"><italic>t</italic><sub>5</sub></th><th align="center" valign="top"><italic>t</italic><sub>18</sub></th><th align="center" valign="top"><italic>t</italic><sub>21</sub></th><th align="center" valign="top"><italic>t</italic><sub>23</sub></th><th align="center" valign="top"><italic>t</italic><sub>24</sub></th></tr></thead><tbody><tr><td align="left" valign="top">Jump times</td><td align="center" valign="top">0</td><td align="center" valign="top">1.8 ×10<sup>−3</sup></td><td align="center" valign="top">0.19</td><td align="center" valign="top">0.52</td><td align="center" valign="top">1.2</td><td align="center" valign="top">1.5</td><td align="center" valign="top">1.8</td><td align="center" valign="top">1.9</td></tr><tr><td align="left" valign="top">1<sup>st</sup>FFSP’s error bound</td><td align="center" valign="top">0</td><td align="center" valign="top">8.8 ×10<sup>−5</sup></td><td align="center" valign="top">0.47</td><td align="center" valign="top">2</td><td align="center" valign="top">2</td><td align="center" valign="top">2</td><td align="center" valign="top">2</td><td align="center" valign="top">2</td></tr><tr><td align="left" valign="top">2<sup>nd</sup>FFSP’s error bound</td><td align="center" valign="top">0</td><td align="center" valign="top">&lt; 10<sup>−15</sup></td><td align="center" valign="top">&lt; 10<sup>−15</sup></td><td align="center" valign="top">&lt; 10<sup>−15</sup></td><td align="center" valign="top">1.2 ×10<sup>−7</sup></td><td align="center" valign="top">1.9 ×10<sup>−4</sup></td><td align="center" valign="top">2.9 ×10<sup>−2</sup></td><td align="center" valign="top">3.7 ×10<sup>−1</sup></td></tr><tr><td align="left" valign="top">Filters difference</td><td align="center" valign="top">0</td><td align="center" valign="top">&lt; 10<sup>−15</sup></td><td align="center" valign="top">&lt; 10<sup>−15</sup></td><td align="center" valign="top">&lt; 10<sup>−15</sup></td><td align="center" valign="top">1.2 ×10<sup>−7</sup></td><td align="center" valign="top">1.9 ×10<sup>−4</sup></td><td align="center" valign="top">2.9 ×10<sup>−2</sup></td><td align="center" valign="top">3.8 ×10<sup>−1</sup></td></tr></tbody></table></table-wrap><table-wrap id="T4" position="float" orientation="portrait"><label>Table 4</label><caption><title>Error bounds of the two FFSP algorithms in case of the high protein production rate but less observable jumps. The last line shows the <italic>L<sub>1</sub></italic> distance between the conditional distributions provided by the two FFSP algorithms.</title></caption><table frame="box" rules="all"><thead><tr><th align="center" valign="top"/><th align="center" valign="top"><italic>t</italic><sub>0</sub></th><th align="center" valign="top"><italic>t</italic><sub>1</sub></th><th align="center" valign="top"><italic>t</italic><sub>2</sub></th><th align="center" valign="top"><italic>t</italic><sub>3</sub></th><th align="center" valign="top"><italic>t</italic><sub>5</sub></th><th align="center" valign="top"><italic>t</italic><sub>8</sub></th><th align="center" valign="top"><italic>t</italic><sub>10</sub></th><th align="center" valign="top"><italic>t</italic><sub>11</sub>(=<italic>t</italic><sub>f</sub>)</th></tr></thead><tbody><tr><td align="left" valign="top">Jump times</td><td align="center" valign="top">0</td><td align="center" valign="top">0.033</td><td align="center" valign="top">0.31</td><td align="center" valign="top">0.39</td><td align="center" valign="top">0.83</td><td align="center" valign="top">1.2</td><td align="center" valign="top">1.5</td><td align="center" valign="top">1.7</td></tr><tr><td align="left" valign="top">1<sup>st</sup>FFSP’s error bound</td><td align="center" valign="top">0</td><td align="center" valign="top">2.4 ×10<sup>−2</sup></td><td align="center" valign="top">2</td><td align="center" valign="top">2</td><td align="center" valign="top">2</td><td align="center" valign="top">2</td><td align="center" valign="top">2</td><td align="center" valign="top">2</td></tr><tr><td align="left" valign="top">2<sup>nd</sup>FFSP’s error bound</td><td align="center" valign="top">0</td><td align="center" valign="top">&lt; 10<sup>−15</sup></td><td align="center" valign="top">&lt; 10<sup>−15</sup></td><td align="center" valign="top">2.1 ×10<sup>−15</sup></td><td align="center" valign="top">1.5 ×10<sup>−12</sup></td><td align="center" valign="top">2.7 ×10<sup>−9</sup></td><td align="center" valign="top">8.6 ×10<sup>−7</sup></td><td align="center" valign="top">1.6 ×10<sup>−4</sup></td></tr><tr><td align="left" valign="top">Filters difference</td><td align="center" valign="top">0</td><td align="center" valign="top">&lt; 10<sup>−15</sup></td><td align="center" valign="top">&lt; 10<sup>−15</sup></td><td align="center" valign="top">2.1 ×10<sup>−15</sup></td><td align="center" valign="top">1.4 ×10<sup>−12</sup></td><td align="center" valign="top">2.7 ×10<sup>−9</sup></td><td align="center" valign="top">2.5 ×10<sup>−5</sup></td><td align="center" valign="top">1.6 ×10<sup>−4</sup></td></tr></tbody></table></table-wrap><table-wrap id="T5" position="float" orientation="portrait"><label>Table 5</label><caption><title>Error behaviour of the two FFSP algorithms in the example of genetic toggle switch with mild inhibition</title></caption><table frame="box" rules="all"><thead><tr><th align="center" valign="top"/><th align="center" valign="top"><italic>t</italic><sub>0</sub></th><th align="center" valign="top"><italic>t</italic><sub>1</sub></th><th align="center" valign="top"><italic>t</italic><sub>2</sub></th><th align="center" valign="top"><italic>t</italic><sub>5</sub></th><th align="center" valign="top"><italic>t</italic><sub>12</sub></th><th align="center" valign="top"><italic>t</italic><sub>21</sub></th><th align="center" valign="top"><italic>t</italic><sub>42</sub></th><th align="center" valign="top"><italic>t</italic><sub>60</sub></th></tr></thead><tbody><tr><td align="left" valign="top">Jump times</td><td align="center" valign="top">0</td><td align="center" valign="top">4.1 ×10<sup>−2</sup></td><td align="center" valign="top">6.6 ×10</td><td align="center" valign="top">8.7 ×10<sup>−i</sup></td><td align="center" valign="top">1.4</td><td align="center" valign="top">2.2</td><td align="center" valign="top">2.9</td><td align="center" valign="top">3.6</td></tr><tr><td align="left" valign="top">1<sup>st</sup>FFSP’s error bound</td><td align="center" valign="top">0</td><td align="center" valign="top">2.6 ×10<sup>−2</sup></td><td align="center" valign="top">9.6 ×10<sup>−i</sup></td><td align="center" valign="top">2</td><td align="center" valign="top">2</td><td align="center" valign="top">2</td><td align="center" valign="top">2</td><td align="center" valign="top">2</td></tr><tr><td align="left" valign="top">2<sup>nd</sup>FFSP’s error bound</td><td align="center" valign="top">0</td><td align="center" valign="top">&lt; 10<sup>−i</sup>5</td><td align="center" valign="top">3.6 ×10<sup>−i</sup>4</td><td align="center" valign="top">3.2 ×10<sup>−i</sup>3</td><td align="center" valign="top">1.2 ×10<sup>−9</sup></td><td align="center" valign="top">9 ×10<sup>−5</sup></td><td align="center" valign="top">7.8 ×10<sup>−</sup></td><td align="center" valign="top">1</td></tr><tr><td align="left" valign="top">Filters difference</td><td align="center" valign="top">0</td><td align="center" valign="top">&lt; 10<sup>−i</sup>5</td><td align="center" valign="top">3.6 ×10<sup>−i</sup>4</td><td align="center" valign="top">3.2 ×10<sup>−i</sup>3</td><td align="center" valign="top">1.2 ×10<sup>−9</sup></td><td align="center" valign="top">9 ×10<sup>−5</sup></td><td align="center" valign="top">7.8 ×10<sup>−</sup></td><td align="center" valign="top">1</td></tr></tbody></table></table-wrap></floats-group></article>