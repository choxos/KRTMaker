<!DOCTYPE article
 PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2 20190208//EN" "JATS-archivearticle1.dtd">
<article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="preprint"><?all-math-mml yes?><?use-mml?><?origin ukpmcpa?><front><journal-meta><journal-id journal-id-type="nlm-ta">bioRxiv</journal-id><journal-title-group><journal-title>bioRxiv : the preprint server for biology</journal-title></journal-title-group><issn pub-type="epub">2692-8205</issn></journal-meta><article-meta><article-id pub-id-type="manuscript">EMS206991</article-id><article-id pub-id-type="doi">10.1101/2025.06.15.659750</article-id><article-id pub-id-type="archive">PPR1039077</article-id><article-version-alternatives><article-version article-version-type="status">preprint</article-version><article-version article-version-type="number">1</article-version></article-version-alternatives><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>FastGA: Fast Genome Alignment</article-title></title-group><contrib-group><contrib contrib-type="author"><contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-6580-7839</contrib-id><name><surname>Myers</surname><given-names>Gene</given-names></name><email>gene.myers@gmail.com</email><aff id="A1">Okinawa Institute of Science and Technology, 1919-1 Tancha, Onna-son, Okinawa, Japan 904-0495 and, <institution-wrap><institution-id institution-id-type="ror">https://ror.org/05cy4wa09</institution-id><institution>Wellcome Sanger Institute</institution></institution-wrap><city>Hinxton</city>, <country country="GB">UK</country><postal-code>CB10 1SA</postal-code></aff></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-9130-1006</contrib-id><name><surname>Durbin</surname><given-names>Richard</given-names></name><email>rd109@cam.ac.uk</email><xref ref-type="fn" rid="FN1">∗</xref><aff id="A2">Department of Genetics, <institution-wrap><institution-id institution-id-type="ror">https://ror.org/013meh722</institution-id><institution>University of Cambridge</institution></institution-wrap><city>Cambridge</city>, <country country="GB">UK</country><postal-code>CB2 3EH</postal-code></aff></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-1735-2630</contrib-id><name><surname>Zhou</surname><given-names>Chenxi</given-names></name><xref ref-type="fn" rid="FN2">†</xref><email>cz370@cam.ac.uk</email><aff id="A3">Department of Genetics, <institution-wrap><institution-id institution-id-type="ror">https://ror.org/013meh722</institution-id><institution>University of Cambridge</institution></institution-wrap><city>Cambridge</city>, <country country="GB">UK</country><postal-code>CB2 3EH</postal-code></aff></contrib></contrib-group><author-notes><fn id="FN1"><label>∗</label><p id="P1">supported by Welcome Trust Grant 226548</p></fn><fn id="FN2"><label>†</label><p id="P2">supported by Welcome Trust Grant 226458</p></fn></author-notes><pub-date pub-type="nihms-submitted"><day>11</day><month>07</month><year>2025</year></pub-date><pub-date pub-type="preprint"><day>19</day><month>06</month><year>2025</year></pub-date><permissions><ali:free_to_read/><license><ali:license_ref>https://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p>This work is licensed under a <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 International license</ext-link>.</license-p></license></permissions><abstract><p id="P3">FastGA finds alignments between two genome sequences more than an order of magnitude faster than previous methods that have comparable sensitivity. Its speed is due to (a) a carefully engineered architecture involving only <italic>cache-coherent MSD radix sorts</italic> and merges, (b) a novel algorithm for finding <italic>adaptive seed</italic> hits in a linear merge of sorted k-mer tables, and (c) a variant of the Myers <italic>adaptive wave</italic> algorithm [<xref ref-type="bibr" rid="R1">1</xref>] to find alignments around a chain of seed hits that detects alignments with up to 25-30% variation. It further does not require pre-masking of repetitive sequence, and stores millions of alignments in a fraction of the space of a conventional CIGAR-string [<xref ref-type="bibr" rid="R2">2</xref>] using a <italic>trace-point</italic> encoding that is further compressed by the ONEcode data system [<xref ref-type="bibr" rid="R3">3</xref>] introduced here.</p><p id="P4">As an example, two bat genomes of size 2.2Gbp and 2.5Gbp can be compared in a little over 2 minutes using 8 threads on an Apple M4 Max laptop using 5.7GB of memory and producing 1.05 million alignments totaling 1.63Gbp of aligned sequence that cover about 60% of each genome. The output “ALN”-formatted file occupies 66MB. This file can be converted to a PAF file with CIGAR strings in 6 seconds, where the PAF representation is a significantly larger 1.03GB file.</p><p id="P5">FastGA is freely available at github: <ext-link ext-link-type="uri" xlink:href="http://www.github.com/thegenemyers/FASTGA">http://www.github.com/thegenemyers/FASTGA</ext-link> along with utilities for viewing inputs, intermediate files, and outputs and transforming outputs into other common formats. Specifically, FastGA can, in addition to its highly efficient ONEcode representation, output PSL-formatted alignments, or PAF-formatted alignments with or without CIGAR strings explicitly encoding the alignments. There is also a utility to chain FastGA’s alignments and display them in a dot-plot like view in Postscript files, and an interactive viewer is in development.</p></abstract></article-meta></front><body><sec id="S1" sec-type="intro"><label>1</label><title>Introduction &amp; Summary</title><p id="P6">Initiatives such as the Vertebrate Genomes Project (VGP), the Darwin Tree of Life project (DToL), and the Earth Biogenome Project (EBP) portend the <italic>de novo</italic> sequencing of tens of thousands of species to a near perfect standard [<xref ref-type="bibr" rid="R4">4</xref>, <xref ref-type="bibr" rid="R5">5</xref>, <xref ref-type="bibr" rid="R6">6</xref>] using single-molecule long-read sequencing technologies[<xref ref-type="bibr" rid="R7">7</xref>]. The reconstructions typically have chromosomal scaffolds with tens to a few hundred gaps between contigs and a consensus error rate of better than 10<sup>−5</sup> [<xref ref-type="bibr" rid="R8">8</xref>]. The number of genomes being so sequenced is increasing geometrically, and includes species with large genomes, 10Gbp or greater. Already as of this writing, several thousand such genomes have been produced, some concentrated on particular clades, for example, over 100 of the 1400 extant bat species have been sequenced [<xref ref-type="bibr" rid="R9">9</xref>]. We therefore anticipate that comparing such clade-based genome collections to understand evolution at the genetic and molecular level will be a major research thrust going forward. A central computational task for this endeavor is finding all statistically significant local alignments between two complete genome sequences. Achieving this computation efficiently and accurately is thus of importance. This paper presents a suite of engineering concepts and algorithms resulting in a software tool, FastGA, that is typically an order of magnitude faster than the current fastest tools, and almost two orders of magnitude faster than the most accurate of the current tools while delivering the same sensitivity.</p><p id="P7">Almost every efficient biosequence similarity search method involves a filter that limits the search to smaller pairs of regions to be aligned, followed by a deterministic alignment algorithm that verifies whether or not a good alignment is present. For example, Blast’s seed-and-extend strategy was an early example of this [<xref ref-type="bibr" rid="R10">10</xref>] and the five precursors to FastGA that we discuss here follow the same overarching design with the differences being in the methods for filtration and verification.</p><p id="P8">We carefully separate the problems of genome alignment and genome homology. The former is the problem of finding all regions that have a statistically significant alignment between them, and the latter is the problem of finding regions that evolved from the same region of an ancestral genome. Not all homologous sequences will have a statistically significant alignment, because there may have been too much mutation since the last common ancestor. On the other hand, repetitive sequences, while they may share a common ancestor in themselves due to deriving from the same mobile element, can be embedded in unrelated regions of a genome, making them misleading indicators of regional genome homology. In this paper we focus on the first problem of finding statistically significant alignment. FastGA finds pairs of segments that significantly align essentially across their whole sequences, with maximal gap sizes of approximately 40bp. It does not itself chain these alignments together across larger gaps, which would suggest homology across the intervening sequence, but rather leaves this to a second step. We provide a simple chaining tool as an initial step towards the second step, but also refer users interested in larger scale homology and genome evolution to existing tools that can take alignments as input, such as the multiple genome aligner Cactus [<xref ref-type="bibr" rid="R11">11</xref>, <xref ref-type="bibr" rid="R12">12</xref>]. We note that by not conflating these two steps, FastGA can be used for other downstream tasks such as finding recurrent insertions due to transposable elements[<xref ref-type="bibr" rid="R13">13</xref>].</p><p id="P9">One of the earlier genome alignment tools, and as our empirical results show still the most sensitive, is LastZ ([<xref ref-type="bibr" rid="R14">14</xref>, <xref ref-type="bibr" rid="R15">15</xref>, <xref ref-type="bibr" rid="R16">16</xref>]) developed by Webb Miller and his Ph.D. Student Robert Harris in the mid-2000’s when the only large genomes of a decent quality to compare were human and mouse. It compares every pair of assembly contigs using a Blast-like seed and extend strategy entailing zone-based dynamic programming to find alignments with a scoring function that favors transitions over transversions. It uses spaced seeds [<xref ref-type="bibr" rid="R17">17</xref>], where the seed pattern is user-specifiable, and provides a method for inferring an “optimal” alignment scoring function based on the overall similarity of the input genomes.</p><p id="P10">NUCmer ([<xref ref-type="bibr" rid="R18">18</xref>]) is another early but still frequently used aligner, whose underlying machinery is based on suffix arrays and the idea of maximal unique matches or MUMs as the seed hits. With suffix arrays, MUMs can be found in linear time and seed uniquely corresponding regions between genomes. NUCmer is part of an overall package MUMmer that predates LastZ and was developed primarily for aligning the bacterial genomes that were available at the time, but it is nonetheless general purpose. The suffix-array based seeding strategy is relatively more efficient than LastZ and simpler post-chaining alignment verification give it better time performance albeit it is less sensitive.</p><p id="P11">Minimap2 ([<xref ref-type="bibr" rid="R19">19</xref>, <xref ref-type="bibr" rid="R20">20</xref>]) is a more recent general-purpose DNA alignment approach that was originally developed with the goal of mapping reads to genomes. The key idea is to reduce the number of k-mers inspected for seed matches by using only those that are minimizers in a window of some small size [<xref ref-type="bibr" rid="R21">21</xref>]. Another notable feature is the use of affine gaps often of a very large size. Using such a gap function, a collinear run of alignments that FastGA would report individually are bundled into a single macro-alignment. This makes the results look less fragmented, but from our perspective conflates the detection of significant alignments with inference from them about regional homology, and once bundled it is cumbersome to have to consider the possibility that a reported synteny block is not homologous.</p><p id="P12">Wfmash ([<xref ref-type="bibr" rid="R22">22</xref>])is a more recent arrival, having been designed in the context of producing a pangenome graph of the human genome. Unlike other aligners, it uses a Min-hash estimate of the Jaccard similarity between two regions [<xref ref-type="bibr" rid="R23">23</xref>] as the filter for finding potentially similar regions and then a recent affine gap wave-alignment algorithm ([<xref ref-type="bibr" rid="R24">24</xref>]) for verification. The mash-map produced by the filter requires larger regions of similarity and higher levels of identity than k-mer seed approaches as reflected in the results of the empirical experiments in this paper. But it is faster to compute and sufficient when species are proximal, such as for example a human to human or human to gorilla comparison. The use of an affine wave as opposed to a unit cost wave does not increase sensitivity but does produce nicer looking alignments as we will show in <xref ref-type="sec" rid="S14">Subsection 3.2.2</xref>. It does however increase time several fold as it must compute a number of waves equal to the cost of the first gap. We advocate in this work that one should employ an affine gap penalty only as a means of refining found alignments for presentation to users.</p><p id="P13">FastGA attains its performance gains over these previous methods through both engineering and algorithmic innovations. The paper first covers the engineering ideas, specifically the importance of cache coherence and the repeated use of most-significant-digit (MSD) radix sorting to help achieve this. We use these to (1) build our version of a genome index, (2) find seed hits, and (3) find chains of seeds. The next section then treats the several algorithmic innovations in FastGA: (1) a linear index merge to find all adaptive seeds,</p><p id="P14">(2) the idea of tracepoints for the space efficient representation of alignments, and (3) alignment refinement under an affine gap model. A brief section then presents the software architecture of FastGA and its under-pinning in ONEcode, a general data handling framework. We conclude with an empirical comparison of the performance of FastGA versus LastZ, NUCmer, Minimap2, and wfmash under a number of scenarios. This last section importantly supports our claims of speed and sensitivity.</p><sec id="S2"><label>1.1</label><title>String Formalisms: Syncmers and Adaptamers</title><p id="P15">All strings <italic>A</italic> = <italic>a</italic><sub>1</sub><italic>a</italic><sub>2</sub> … <italic>a</italic><sub><italic>n</italic></sub> are assumed to be over the DNA alphabet Σ = {<italic>a, c, g, t</italic>}. Position <italic>i</italic> in <italic>A</italic> is the location <italic>between</italic> characters <italic>a</italic><sub><italic>i</italic></sub> and <italic>a</italic><sub><italic>i</italic>+1</sub>, so that the substring <italic>A</italic>[<italic>i, j</italic>] = <italic>a</italic><sub><italic>i</italic>+1</sub><italic>a</italic><sub><italic>i</italic>+2</sub> … <italic>a</italic><sub><italic>j</italic></sub> and is of length <italic>j</italic> − <italic>i</italic>. A <italic>k</italic>-mer is any substring of length <italic>k</italic>. The <italic>complement</italic> of a DNA string is <italic>A</italic><sup><italic>c</italic></sup> = <italic>c</italic>(<italic>a</italic><sub><italic>n</italic></sub>)<italic>c</italic>(<italic>a</italic><sub><italic>n</italic>−1</sub>) … <italic>c</italic>(<italic>a</italic><sub>1</sub>) where <italic>c</italic> : [<italic>acgt</italic>] → [<italic>tgca</italic>]. We will assume throughout that there is a function <italic>Φ</italic> that assigns an integer value to any string and hence orders them. The <italic>canonical value</italic> Φ(<italic>α</italic>) of a string <italic>α</italic> is the smaller of the value of <italic>α</italic> or its complement, i.e. Φ(<italic>α</italic>) = <italic>min</italic>(<italic>ϕ</italic>(<italic>α</italic>), <italic>ϕ</italic>(<italic>α</italic><sup><italic>c</italic></sup>)).</p><p id="P16">Much work has focused on <italic>minimizers</italic> as a representative subset of the <italic>k</italic>-mers of a string [<xref ref-type="bibr" rid="R21">21</xref>]. In this work we will use the <italic>syncmer</italic> concept of Bob Edgar [<xref ref-type="bibr" rid="R25">25</xref>]. Given <italic>k</italic>-mer <italic>α</italic> and <italic>m &lt; k, α</italic> is a <italic>closed</italic> (<italic>k, m</italic>) <italic>syncmer</italic> if and only if the canonical value of the <italic>m</italic>-mer at the start or end of <italic>α</italic> is the smallest of all <italic>m</italic>-mers of <italic>α</italic>, i.e. <italic>min</italic>(Φ(<italic>α</italic>[0, <italic>m</italic>]), Φ(<italic>α</italic>[<italic>k</italic> − <italic>m, k</italic>])) = <italic>min</italic><sub><italic>i</italic>∈[0,<italic>k</italic>−<italic>m</italic>]</sub> Φ(<italic>α</italic>[<italic>i, i</italic> + <italic>m</italic>]). Edgar showed that the subsequence of <italic>k</italic>-mers of a long string <italic>A</italic> that are closed (<italic>k, m</italic>) syncmers are at most <italic>k</italic> − <italic>m</italic> positions apart and on average are slightly more than (<italic>k</italic> − <italic>m</italic>)<italic>/</italic>2 from each other. Thus a series of closed syncmers represent a sub-sampling of the <italic>k</italic>-mers of a long sequence with an average density of approximately 2<italic>/</italic>(<italic>k</italic> − <italic>m</italic>) that are further guaranteed to cover the sequence.</p><p id="P17">Most algorithms that search for approximate string matches use the concept of <italic>seed hits</italic> to filter the space of possible corresponding intervals between the two strings. The most basic of these is, for some <italic>k</italic>, to find pairs of positions for which the <italic>k</italic>-mers beginning at them are the same. Immediately there is the question of how to choose <italic>k</italic>: too small and there will be an overwhelming, quadratically growing number of seed pairs, too large and approximate matches will be missed. That is, there is a sensitivity:specificity trade-off that depends critically on the degree of similarity sought in a match and the size and repetitiveness of the underlying sequences. One interesting solution is to seek only the <italic>maximally unique matches</italic>, or <italic>MUMs</italic> [<xref ref-type="bibr" rid="R18">18</xref>], that is, a sequence that begins at a pair of positions in the two sequences that is of maximal length over all such sequences. While generally selective of matching regions it may not identify multiple similar regions. A related idea that is less stringent is that of <italic>adaptive seeds</italic> [<xref ref-type="bibr" rid="R26">26</xref>] that are locally maximal as opposed to globally maximal. We call such seeds <italic>adaptamers</italic> throughout this paper. At a given position <italic>i</italic> in a sequence, the adaptamer at position <italic>i</italic> is the longest string beginning there, that can also be found in the other sequence or its complement. Unlike MUMs, the concept is not symmetric, i.e., if <italic>A</italic>[<italic>i, i</italic> + <italic>p</italic>] is an adaptamer at <italic>i</italic> and it matches say<italic>B</italic>[<italic>j, j</italic> + <italic>p</italic>], it is not necessarily the case that <italic>B</italic>[<italic>j, j</italic> + <italic>p</italic>] is the adaptamer at <italic>j</italic> but a prefix of said. Given a threshold <italic>τ &gt;</italic> 0, we will deem an adaptamer <italic>repetitive</italic> if it or its complement occurs more than <italic>τ</italic> times in the other sequence.</p></sec></sec><sec id="S3"><label>2</label><title>Engineering</title><sec id="S4"><label>2.1</label><title>Cache Coherent Sorting for Speed</title><p id="P18">CPUs are designed to operate at the fastest clock rate possible, and memories are designed to provide the maximum density/capacity possible, at lower random access rates. So as computer hardware has advanced over the last several decades, the mismatch between the speed of the CPU and primary memory has increased, to the point where today memory latency is typically about 100 times the clock rate of the CPU. To alleviate this mismatch, multiple layers of cache, becoming increasing smaller and faster closer to the CPU, have been introduced. But it is still the case that a program that makes random accesses to a large data structure, e.g. a hash table of all 40-mers of a genome, suffers a cache miss at every layer almost every time a hash add or lookup is performed. On the other hand, <italic>cache-coherent</italic> programs that make a limited number of linear sweeps through memory at the same time, either increasing or decreasing, tend to suffer almost no memory latency as the cache hardware operates in multi-word blocks and can anticipate and preload blocks for such simple access patterns.</p><p id="P19">Let the notation <italic>κ</italic><sub><italic>i</italic></sub> refer to the <italic>k</italic>-mer that begins at position <italic>i</italic> in a sequence. A typical comparison between two genomes, <italic>G</italic> and <italic>H</italic>, would have the outline:</p><disp-quote id="Q1"><p id="P20">Create a <italic>k</italic>-mer index ℋ of <italic>H</italic> (e.g. suffix tree, hash table, FM-index)</p><p id="P21"><bold>For</bold> each position <italic>p</italic> in <italic>G</italic> in order <bold>do</bold></p><p id="P22">Look up <italic>κ</italic><sub><italic>p</italic></sub> in ℋ and for all positions <italic>q</italic> found, report (<italic>p, q</italic>)</p></disp-quote><p id="P23">There is almost no coherence between where the data for <italic>κ</italic><sub><italic>i</italic></sub> and <italic>κ</italic><sub><italic>i</italic>+1</sub> are located in the memory of ℋ (at least for all the data structures listed above) so the lookup will almost always entail a cache miss through all layers of cache if the index is large enough to index a gigabase-scale genome. Instead consider using a highly optimized cache coherent sort such as a Most-Significant Digit (MSD) radix sort[<xref ref-type="bibr" rid="R27">27</xref>] in the following outline:</p><disp-quote id="Q2"><p id="P24">Build a list 𝒜= {(<italic>p, κ</italic><sub><italic>p</italic></sub>)} of each position and its k-mer in <italic>G</italic> and MSD sort on the <italic>k</italic>-mer</p><p id="P25">Build a list ℬ= {(<italic>q, κ</italic><sub><italic>q</italic></sub>)} of each position and its k-mer in <italic>H</italic> and MSD sort on the <italic>k</italic>-mer</p><p id="P26">Merge 𝒜 and ℬ in order of <italic>k</italic>-mer and make a list C of pairs (<italic>p, q</italic>) with the same <italic>k</italic>-mer</p><p id="P27">Sort C in lexicographical order of <italic>p</italic> and then <italic>q</italic> with an MSD sort</p></disp-quote><p id="P28">First observe that the entire computation is cache coherent. Second, the final sorted list C is exactly the sequence of pairs output by the first approach. So in essence both methods produce the set of all seed hits, that is, pairs of locations in the underlying dynamic programming matrix that share the same <italic>k</italic>-mer. Naively, the first method might seem preferable as it involves fewer operations (<italic>O</italic>(<italic>N</italic>) not <italic>O</italic>(<italic>N</italic> log <italic>N</italic>)) and potentially less space, as the hits can be clustered and processed as they are discovered. But while the second approach excutes more operations and utilizes more space, there are no cache misses, so the average execution time of each instruction is much closer to that of the CPU clock. Moreover the space occupied by <italic>C</italic> is of the same order as the index <italic>ℋ</italic> of the first approach if one takes some care to avoid highly repetitive <italic>k</italic>-mers. As the empirical results of this paper will show, FastGA, which uses the sorting approach is typically an order of magnitude or more faster than other contemporary tools all of which use a form of the first, cache-incoherent approach. The speed of FastGA makes the point that algorithms/software should be designed with an awareness of cache coherence if speed is a primary consideration.</p></sec><sec id="S5"><label>2.2</label><title>A Simple Genome Index</title><p id="P29">FastGA takes the approach of finding the adaptamer seeds between two genomes, obviating the need for selecting a <italic>k</italic>-mer size as it adaptively uses longer substrings in unique regions and shorter substrings in repetitive regions. In the original adaptamer implementation [<xref ref-type="bibr" rid="R26">26</xref>] a suffix tree of the second genome was built and then the first genome was scanned, finding the adaptamer hits at each position using the suffix tree. As discussed in <xref ref-type="sec" rid="S4">Section 2.1</xref> this is cache incoherent. Using a cache coherent approach, FastGA, effectively builds suffix trees of each genome and then in a novel merge algorithm finds the adaptamers of the suffixes in the first tree in the second. One of the advantages of this approach is that each suffix tree can be built independently for a genome, and then used in multiple comparisons with other genomes. But there is the problem of how to build a space-efficient suffix tree in a cache coherent manner. Also note that both the forward and complement strand of the genome must be represented.</p><p id="P30">Rather than build a suffix tree, first observe that almost all adaptamers for a multi-gigabyte genome will not be longer than than some reasonable choice of <italic>K</italic>, say 40, and for longer adaptamers their first <italic>K</italic> bases already constitute a very specific match into the second genome. So we simply build a sorted list of all the <italic>K</italic>-mers in the genome and its complement that occur fewer than <italic>τ</italic> times (user specifiable) and for each <italic>K</italic>-mer record the positions at which it occurs and its orientation, i.e. from the forward (+) or reverse strand (-), in the sign bit of the position. This is readily accomplished with a cache coherent MSD radix sort of (<italic>K</italic>-mer, signed-position) pairs as suggested earlier. As we will subsequently show, it is easy to have the MSD radix sort further return the <italic>longest common prefix (lcp)</italic> of a given <italic>K</italic>-mer and its predecessor in the final <italic>K</italic>-mer sorted array. Together the sorted <italic>K</italic>-mer list and lcp array provide a simple <italic>genome index</italic> that is in effect a suffix array that has been truncated at depth <italic>K</italic>. Given two such indices, we can find all the non-repetitive adaptamers of a suffix in the first index with respect to the second, where the adaptamer length is capped at <italic>K</italic>. Almost all genomes encountered are less than 100Gbp in size, and given this limit, a <italic>K</italic> = 40-mer is generally more than long enough to specifically correlate two regions of interest. A constant larger than 40 can be specified at compilation, but we have yet to encounter an example where empirically a larger choice of <italic>K</italic> is beneficial.</p><p id="P31">For a genome of length <italic>N</italic>, roughly 26<italic>N</italic> bytes are required for an index in which every 40-mer in both the genome and its complement are represented, a rather large data structure. To ameliorate this we can keep only those <italic>K</italic>-mers whose first <italic>s</italic> bases are a closed (<italic>s, m</italic>) syncmer for some choice of <italic>s</italic> and <italic>m &lt; s</italic>. In practice we use (<italic>s, m</italic>) = (12, 8) effectively reducing the number of <italic>K</italic>-mers by a bit more than half. Note carefully that the complement of a syncmer is also a syncmer so in matching regions it is likely that both the forward and reverse adaptamers are synchronized implying only a slight loss in sensitivity. It further means that adaptamers of length less than <italic>m</italic> are lost, but again for <italic>s</italic> = 12 there are relatively few of these and they are not generally correlated with true matches.</p><p id="P32">Within FastGA <italic>K</italic> = 40, <italic>s</italic> = 12, and <italic>m</italic> = 8 are compile time parameters that could be retuned by a sophisticated user, e.g. a pair of very large, highly repetitive genomes, or lots of small, say bacterial, genomes, for a bit more performance. These selected values result in indices that occupy about 11GB per 1Gbp of genome and take about 15 seconds to construct on our laptop<sup><xref ref-type="fn" rid="FN3">1</xref></sup> per 1Gbp of genome, using 8 threads. A final note is that merging two indices is a linear scan of both, as seen in <xref ref-type="sec" rid="S8">Section 3</xref>, implying that the indices can be paged into memory as they are swept linearly thus requiring a very small memory footprint.</p></sec><sec id="S6"><label>2.3</label><title>Most Significant Digit (MSD) Radix Sorting</title><p id="P33">In the last decade a number of researchers have discovered the power of most-significant-digit (MSD) radix sorting as a linear time, in-place, cache coherent sort of very large numbers of fixed size records [<xref ref-type="bibr" rid="R27">27</xref>, <xref ref-type="bibr" rid="R28">28</xref>, <xref ref-type="bibr" rid="R29">29</xref>]. Consider an array <italic>A</italic>[0..<italic>N</italic> − 1] of <italic>N</italic> elements each consisting of <italic>K</italic> bytes. View each element as a string of length <italic>K</italic> over an alphabet of size Σ = 256. An MSD radix sort, starts by sorting the elements in place on the first byte/symbol, partitioning the array into Σ sub-arrays where all the elements in each sub-array have the same first byte. Recursively, each of these sub-arrays is then sorted on the second byte, further partitioning each into Σ parts, which in turn are each sorted on the third byte and so on until depth <italic>K</italic> is reached at which point the elements are sorted. In a very simple form the in-place sort is as follows:</p><preformat preformat-type="dialog">
      procedure MSD-sort(string a[0..N-1], int d)
      { int fing[0..Σ], part[0..Σ]
1.       for x = 0 to Σ do
2.         part[x] = 0
3.       for i = 0 to N-1 do
4.         part[a[i]<sub><italic>d</italic></sub>+1] += 1
5.       for x = 2 to Σ do
6.         fing[x] = part[x] += part[x-1]
7.       for x = 0 to Σ-1 do
8.         while fing[x] &lt; part[x+1] do
9.           { y = a[fing[x]]<sub><italic>d</italic></sub>
10.            swap a[fing[y]] and a[fing[x]]
11.            fing[y] += 1
          }
12.      if d &lt; K then
13.        for x = 0 to Σ-1 do
14.          MSD-sort(a[part[x]..part[x+1]-1],d+1)
      }
15.    MSD-sort(A[0..N-1],1)
</preformat><p id="P34">The first thing to observe is that the algorithm is cache-coherent as in any of its <monospace>for</monospace>-loops at most Σ + 1 regions of memory are being swept at any time. The number of steps is <italic>O</italic>(<italic>NK</italic>) but one must be careful as <italic>O</italic>(<italic>K</italic>) memory is being moved in step 10. for a complexity of <italic>O</italic>(<italic>NK</italic><sup>2</sup>). However, for any fixed data size the sort is <italic>O</italic>(<italic>N</italic>). Further observe that in effect any data can be sorted. For example, a 64-bit integer can be viewed as an 8 byte string over an alphabet of size 256. As another example, we compress 40-mer DNA strings into 10 bytes using 2-bits per base, and sort (40-mer, contig, position) records to produce the genome indices of the previous subsection. Typically, the contig number occupies 2 bytes and the position within the contig 4, so that each record is 16 bytes. The array of such records is then MSD sorted on the first 10 bytes encoding the 40-mer. Another advantage of an MSD sort is that carefully memory mapping the array to be sorted gives one an effective external sort that can work on an arbitrarily large file of data.</p><p id="P35">The simple form above is usually refined in several ways. First, instead of just swapping two records, the implied permutation of the fingers is determined up to some maximum length, and then the records along the chain are moved in a cyclical fashion roughly halving the amount of data movement. Also when at depth <italic>d</italic> only the last <italic>K</italic> − (<italic>d</italic> − 1) bytes of each record need to be moved as the first <italic>d</italic> − 1 bytes of every record in the current sub-array are identical, again roughly halving the number of bytes moved. The second refinement, is that when a partition becomes small enough, a more efficient sort for this size is employed. For example in RADULS [<xref ref-type="bibr" rid="R27">27</xref>], introspective sort is used for <italic>n</italic> ≤ 384, shell sort for <italic>n</italic> ≤ 100, and insertion sort for <italic>n</italic> ≤ 32. Lastly, it is generally desirable to distribute the sort over multiple threads. This is easy to do once the first digit has resulted in Σ segments that can be sorted on the remaining digits independently. But the top level sort is not so easily distributed and fairly complex solutions that achieve good parallelism can be found in [<xref ref-type="bibr" rid="R27">27</xref>] and [<xref ref-type="bibr" rid="R29">29</xref>].</p><p id="P36">Our MSD sort departs from previous work in the following ways where the design assumes that a modest number <italic>T</italic> of threads, e.g. 4 to 16, are available. First, in the context of FastGA, we found it readily possible to know the sizes of each top-level partition and the amount a given “load thread” will contribute to each, so that each of <italic>T</italic> load threads, handling balanced amounts of the data, can construct their array records in locations so that the top level sort is already performed when the loading is complete. We then very simply divide the 256 top level partitions as evenly as possible across the <italic>T</italic> threads and let each thread proceed independently. We thus completely avoid the problem of threading the top level sort and postulate that this circumvention is possible for most applications.</p><p id="P37">Second, observe that while the partitioning is usually into Σ = 256 parts for small <italic>d</italic>, as the depth increases, there are an increasing number of empty partition intervals especially when <italic>d</italic> becomes larger than log<sub>Σ</sub> <italic>N</italic>. Indeed, the number of non-empty partition intervals trends towards 1. So during the partitioning step (Lines 1-6 above) if we observe that only 1 partition interval is non-empty, we non-recursively increase <italic>d</italic> by 1 and repeat the partition step, as the <italic>d</italic><sup><italic>th</italic></sup> digit is equal for all entries. Thus, if a block of identical array elements occurs (e.g. ∼ 50 identical k-mers in a 50× shotgun data set), then this modification results in simply verifying that all the elements are equal and hence sorted in linear time with no data movement.</p><p id="P38">In all other cases, we detect the <italic>p</italic> partition intervals that are non-empty and only iterate over their <italic>p</italic> digit values as opposed to all Σ. As one approaches small problems, <italic>p</italic> tends to be very small, 2 or 3, so that with this modification we find that our MSD sort is competitive without resorting to the special terminal sorts of previous approaches.</p><p id="P39">A third, subtle modifiaction is to detect when an entry is already in its correct partition so that it is not moved. This simple test further reduces data movement by roughly 10% overall. But note that for the deep cases, where only 2 or 3 partition intervals are non-empty, it results in 50% and 33% less data movement, respectively. This also further explains why a distinct terminal sort is not needed in our realization of the sort.</p><p id="P40">Our final refinement, especially important to the adaptive seed merge of <xref ref-type="sec" rid="S8">Section 3</xref>, is to record the longest common prefix (lcp) of each element in the sorted array with its immediate predecessor. Simply, when sorting a sub-array on the <italic>d</italic><sup><italic>th</italic></sup> digit, the first element of each partition interval, except for the first element of the sub-array, has an lcp of <italic>d</italic> with its predecessor. If one is sorting 2-bit packed DNA strings a byte at a time, then the lcp of the first element of partition <italic>p</italic> with its predecessor is 4<italic>d</italic> + 3 − ⌊log<sub>4</sub> <italic>p</italic>ˆ<italic>q</italic>⌋ assuming its predecessor is in partition <italic>q &lt; p</italic> (remember, partition intervals can be empty), where <italic>p</italic>ˆ<italic>q</italic> is the bitwise exclusive-or operator. FastGA radix sorts on bytes (i.e. Σ = 256) and as the top level partition is recorded separately, we can conveniently stash the lcp for a genome index 40-mer in the first byte of each element.</p></sec><sec id="S7"><label>2.4</label><title>Finding Seed Chains and Alignments</title><p id="P41">We defer the algorithm for merging two genome indices (with lcps) to <xref ref-type="sec" rid="S9">Section 3.1</xref>. For the moment, in order to complete the overview of FastGA’s operation, we assert that the result of this merge is a set of pairs of positions in the two genomes and a length, (<italic>i, j, t</italic>), such that the string of length <italic>t</italic> starting at <italic>i</italic> is an adaptamer that matches the string of the same length starting at <italic>j</italic> in the second genome. In reality, each position say <italic>i</italic> is coded as a contig number <italic>c</italic><sub><italic>i</italic></sub> and then a position <italic>p</italic><sub><italic>i</italic></sub> within the contig. What we are seeking, in the dynamic programming matrix of contig <italic>c</italic><sub><italic>i</italic></sub> versus contig <italic>c</italic><sub><italic>j</italic></sub>, is a <italic>chain</italic> of adaptamer seed hits that lie in a narrow diagonal band of width say <italic>D</italic> that are fairly tightly spaced within that band, say no two seeds are further apart than <italic>A</italic> anti-diagonals.</p><p id="P42">To find these chains efficiently, we create a list of records (<italic>c</italic><sub><italic>i</italic></sub>, <italic>c</italic><sub><italic>j</italic></sub>, ⌊(<italic>p</italic><sub><italic>i</italic></sub>–<italic>p</italic><sub><italic>j</italic></sub>)<italic>/D</italic>⌋, <italic>p</italic><sub><italic>i</italic></sub>+<italic>p</italic><sub><italic>j</italic></sub>, (<italic>p</italic><sub><italic>i</italic></sub>–<italic>p</italic><sub><italic>j</italic></sub>) <italic>mod D, t</italic>) for each adaptamer seed hit ((<italic>c</italic><sub><italic>i</italic></sub>, <italic>p</italic><sub><italic>i</italic></sub>), (<italic>c</italic><sub><italic>j</italic></sub>, <italic>p</italic><sub><italic>j</italic></sub>), <italic>t</italic>). In terms of the dynamic programming matrix of contig <italic>c</italic><sub><italic>i</italic></sub> versus contig <italic>c</italic><sub><italic>j</italic></sub>, observe that the points (<italic>p</italic><sub><italic>i</italic></sub>, <italic>p</italic><sub><italic>j</italic></sub>) for which ⌊ (<italic>p</italic><sub><italic>i</italic></sub> − <italic>p</italic><sub><italic>j</italic></sub>)<italic>/D</italic>⌋ = <italic>b</italic> for a fixed value of <italic>b</italic> ∈ [−|<italic>c</italic><sub><italic>j</italic></sub>|<italic>/D</italic>, |<italic>c</italic><sub><italic>i</italic></sub>|<italic>/D</italic>] are all in a diagonal band of width <italic>D. p</italic><sub><italic>i</italic></sub> + <italic>p</italic><sub><italic>j</italic></sub> is the anti-diagonal for the pair, and the exact diagonal for the pair can be reconstructed because the remainder of <italic>p</italic><sub><italic>i</italic></sub> − <italic>p</italic><sub><italic>j</italic></sub> modulo <italic>D</italic> is kept in the second to last entry. To recap, given a list entry (<italic>c</italic><sub><italic>i</italic></sub>, <italic>c</italic><sub><italic>j</italic></sub>, <italic>b, a, r, t</italic>) both <italic>p</italic><sub><italic>i</italic></sub> = (<italic>a</italic> + (<italic>Db</italic> + <italic>r</italic>))<italic>/</italic>2 and <italic>p</italic><sub><italic>j</italic></sub> = (<italic>a</italic> − (<italic>Db</italic> + <italic>r</italic>))<italic>/</italic>2 are indirectly encoded therein.</p><p id="P43">We then MSD sort this list of sextuplets on their first 4 components in lexicographical order. Thereafter, all the seed hits between a pair of contigs <italic>c</italic><sub><italic>i</italic></sub> and <italic>c</italic><sub><italic>j</italic></sub> are grouped together in the sorted list. Moreover, the seeds in each diagonal band are consecutive and in order of their anti-diagonal within the band. Thus chains of seed hits in a given diagonal band <italic>b</italic> that are not separated by more than <italic>A</italic> anti-diagonals are easily found in a linear scan of the sorted list.</p><p id="P44">However, we seek chains that can occur in <italic>any</italic> band of width <italic>D</italic>. To do so, the seeds in each pair of adjacent bands, <italic>b</italic> and <italic>b</italic>+1, are merged in order of anti-diagonal and chains are sought in the merged output. This is still linear in time and captures all chains in a band of width <italic>D</italic>, but does also admit chains of width up to 2<italic>D</italic>. One could take further effort to only report chains of width <italic>D</italic> or less, but keeping in mind that the goal is to find pairs of regions that align, these extra wide chains only adversely affect search time (slightly) but not the sensitivity of FastGA. As chains are found in the linear sweep of the sorted hit list, FastGA tries to find a proper local alignment that passes through the <italic>tube</italic> of each chain. The tube is the rectangular region of the d.p. matrix that is bounded by the lowest and highest diagonals, <italic>d</italic><sub><italic>low</italic></sub> and <italic>d</italic><sub><italic>high</italic></sub>, amongst the seeds in the chain, and the lowest and highest anti-diagonals, <italic>a</italic><sub><italic>low</italic></sub> and <italic>a</italic><sub><italic>high</italic></sub>, where both ends of the seed hits are considered. This tube is easily derived as each chain is discovered.</p><p id="P45">FastGA uses the very rapid wave-based algorithm for finding local alignments that we reported previously in 2014 ([<xref ref-type="bibr" rid="R1">1</xref>]), so here we only describe the interface to it and will refer to it as the LA-finder. Given an anti-diagonal and an upper and lower diagonal bound, LA-finder finds the best local alignment that passes through the anti-diagonal between the diagonal bounds. It reports the end-points of this alignment, the number of differences within it, and a trace-point representation of the entire alignment (see <xref ref-type="sec" rid="S15">Section 4</xref>). LA-finder always returns an alignment, which can have length 0 if there is no significant similarity in the region.</p><p id="P46">For each tube of a chain, LA-finder is first called on the anti-diagonal <italic>a</italic><sub><italic>low</italic></sub> + 2<italic>D</italic>, or (<italic>a</italic><sub><italic>low</italic></sub> + <italic>a</italic><sub><italic>high</italic></sub>)<italic>/</italic>2 if <italic>a</italic><sub><italic>low</italic></sub> + <italic>D</italic> ≥ <italic>a</italic><sub><italic>high</italic></sub>. If the alignment returned is sufficiently long and sufficiently similar (both parameters that can be set by the user) then the alignment is collected for possible output. Suppose the anti-diagonal at the far end of the alignment returned by LA-finder is <italic>a</italic><sub><italic>top</italic></sub>. If <italic>a</italic><sub><italic>top</italic></sub> ≥ <italic>a</italic><sub><italic>high</italic></sub> then the tube is considered processed. Otherwise <italic>a</italic><sub><italic>low</italic></sub> is set to <italic>a</italic><sub><italic>top</italic></sub> and the now truncated tube is searched again. This continues until the entire tube has been searched with calls to LA-finder.</p><p id="P47">All the alignments for a given pair of contigs are collected and redundant alignments are removed. Exactly the same alignment or a prefix or suffix of a longer alignment can be found when disjoint chain tubes for the same alignment are found. Only one instance of the full alignment is kept. The <italic>bounding box</italic> of an alignment is the smallest rectangle that contains all the points on the alignment path. We further consider an alignment to be redundant if it is entirely within the bounding box of another alignment. For example, satellite repeats create waves of alignments that all fit in the bounding box of the alignment closest to the main diagonal. Finally, the resulting set of non-redundant alignments are output in order of their start coordinate in the first genome.</p></sec></sec><sec id="S8"><label>3</label><title>Algorithms</title><sec id="S9"><label>3.1</label><title>Finding Adaptamers</title><p id="P48">This subsection presents perhaps the most interesting algorithm within FastGA, where two genome indices, say 𝒢 and ℋ, of genomes <italic>G</italic> and <italic>H</italic>, are “merged” to find all the adaptamers of <italic>G</italic> and their matching positions in <italic>H</italic>. Previous work has shown that given a suffix array and its associated lcp array, one can build three “enhancing” arrays in linear time, such that one can then perform any operation possible on a suffix <italic>tree</italic> ([<xref ref-type="bibr" rid="R30">30</xref>]). This result transfers naturally to truncated suffix arrays. When viewed as suffix trees, our problem is in essence to find the intersection of the two suffix trees: a string is an adaptamer of <italic>G</italic> if it is spelled on a path to a vertex in the intersection that has an edge which is in the suffix tree of <italic>G</italic> but not <italic>H</italic>. This can be accomplished in time proportional to the number of edges in the uncompressed suffix trie of the intersection. However, the genome indices are very large objects, so building additional arrays to facilitate tree operations is prohibitive. So instead we developed an algorithm with the same time complexity that performs the task directly on <italic>𝒢</italic> and H with only <italic>O</italic>(<italic>K</italic>) auxiliary storage, where <italic>K</italic> (= 40 in our implementation) is the length of the <italic>k</italic>-mers in both indices.</p><p id="P49">The algorithm processes each <italic>K</italic>-mer in the first index in sequence, which by the design of the indices are in sorted order. Formally, let 𝒢 [<italic>i</italic>].<italic>kmer</italic> be the i’th <italic>K</italic>-mer in the index, 𝒢 [<italic>i</italic>].<italic>lcp</italic> = {<italic>lcp</italic>(𝒢 [<italic>i</italic> − 1].<italic>kmer</italic>, 𝒢 [<italic>i</italic>].<italic>kmer</italic>)} be the lcp of the i’th <italic>k</italic>-mer with its predecessor, and let 𝒢 [<italic>i</italic>].<italic>loc</italic> = <italic>j</italic> : <italic>G</italic>[<italic>j, j</italic> + <italic>K</italic>] = 𝒢 [<italic>i</italic>].<italic>kmer</italic> be the set of positions at which the i’th <italic>K</italic>-mer occurs in the source genome <italic>G</italic>. The problem then is for each <italic>K</italic>-mer in the first index, say <italic>α</italic> = 𝒢[<italic>i</italic>].<italic>kmer</italic>, to find the range [<italic>fst</italic><sub><italic>i</italic></sub>, <italic>lst</italic><sub><italic>i</italic></sub>), <italic>fst</italic><sub><italic>i</italic></sub> <italic>&lt; lst</italic><sub><italic>i</italic></sub> in the second index and length <italic>L</italic><sub><italic>i</italic></sub> such that <italic>lcp</italic>(<italic>α</italic>, ℋ[<italic>j</italic>].<italic>kmer</italic>) = <italic>L</italic><sub><italic>i</italic></sub> for all <italic>j</italic> ∈ [<italic>fst</italic><sub><italic>i</italic></sub>, <italic>lst</italic><sub><italic>i</italic></sub>) and <italic>lcp</italic>(<italic>α</italic>, ℋ[<italic>j</italic>].<italic>kmer</italic>) <italic>&lt; L</italic><sub><italic>i</italic></sub> for all other <italic>j</italic>. Clearly, the adaptamer at each position <italic>p</italic> in 𝒢[<italic>i</italic>].<italic>loc</italic> is the string <italic>α</italic>[0, <italic>L</italic><sub><italic>i</italic></sub>] = <italic>G</italic>[<italic>p, p</italic> + <italic>L</italic><sub><italic>i</italic></sub>] and each of these adaptamer instances matches at the locations <italic>q</italic> in <inline-formula><mml:math id="M1"><mml:mrow><mml:msub><mml:mstyle displaystyle="true"><mml:mo>∪</mml:mo></mml:mstyle><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mfenced close=")" open="["><mml:mrow><mml:mi>f</mml:mi><mml:mi>s</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mi>s</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>.</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:math></inline-formula> in the second genome. These pairs (<italic>p, q</italic>) of positions are appended to the match list for subsequent sorting as in the outline of <xref ref-type="sec" rid="S4">Section 2.1</xref> as long as the adaptamers are not repetitive, i.e. <inline-formula><mml:math id="M2"><mml:mrow><mml:mfenced close="|" open="|"><mml:mrow><mml:msub><mml:mstyle displaystyle="true"><mml:mo>∪</mml:mo></mml:mstyle><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mfenced close=")" open="["><mml:mrow><mml:mi>f</mml:mi><mml:mi>s</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mi>s</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:msub><mml:mi mathvariant="script">H</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>.</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>τ</mml:mi></mml:mrow></mml:math></inline-formula></p><p id="P50">To find the range and length in ℋ, we need to merge the two indices in sorted order of <italic>K</italic>-mer. That is, for <italic>K</italic>-mer <italic>α</italic> at index <italic>i</italic> in 𝒢, we find the index <italic>cur</italic><sub><italic>i</italic></sub> in ℋ such that ℋ[<italic>cur</italic><sub><italic>i</italic></sub> − 1].<italic>kmer &lt; α</italic> ≤ ℋ[<italic>cur</italic><sub><italic>i</italic></sub>].<italic>kmer</italic>. Immediately, observe that a longest prefix match to <italic>α</italic> in ℋ must occur at either <italic>cur</italic><sub><italic>i</italic></sub> − 1 or <italic>cur</italic><sub><italic>i</italic></sub>, i.e. <italic>L</italic><sub><italic>i</italic></sub> = <italic>max</italic>(<italic>lcp</italic>(<italic>α</italic>, ℋ[<italic>cur</italic><sub><italic>i</italic></sub> − 1].<italic>kmer</italic>), <italic>lcp</italic>(<italic>α</italic>, ℋ[<italic>cur</italic><sub><italic>i</italic></sub>].<italic>kmer</italic>)). Furthermore, <italic>cur</italic><sub><italic>i</italic></sub> must be in the interval [<italic>fst</italic><sub><italic>i</italic></sub>, <italic>lst</italic><sub><italic>i</italic></sub>]. Letting <italic>c</italic> be any index in [<italic>fst</italic><sub><italic>i</italic></sub>, <italic>lst</italic><sub><italic>i</italic></sub>), we can use the <italic>lcp</italic> information to quickly determine <italic>fst</italic><sub><italic>i</italic></sub> = <italic>max</italic><sub><italic>j</italic>≤<italic>c</italic></sub>ℋ[<italic>j</italic>].<italic>lcp &lt; L</italic><sub><italic>i</italic></sub> and <italic>lst</italic><sub><italic>i</italic></sub> = <italic>min</italic><sub><italic>j&gt;c</italic></sub>ℋ[<italic>j</italic>].<italic>lcp &lt; L</italic><sub><italic>i</italic></sub>. So intuitively if we can merge the two indices in order of <italic>K</italic>-mers we can use the <italic>lcp</italic>’s to find the desired intervals and adaptamer lengths. The task remaining is to do so as efficiently as possible.</p><p id="P51">Inductively, we seek to find <italic>cur</italic><sub><italic>i</italic></sub>, [<italic>fst</italic><sub><italic>i</italic>+1</sub>, <italic>lst</italic><sub><italic>i</italic>+1</sub>), and <italic>L</italic><sub><italic>i</italic>+1</sub> given these values for index <italic>i</italic> in 𝒢. To make the computation a bit more efficient, we will also maintain a <italic>K</italic> element vector <italic>wall</italic><sub><italic>i</italic></sub> such that for all <italic>k &lt; L</italic><sub><italic>i</italic></sub>, <italic>wall</italic>[<italic>k</italic>] = <italic>min</italic><sub><italic>j</italic></sub> <italic>lcp</italic>(<italic>α</italic>, ℋ[<italic>j</italic>].<italic>kmer</italic>) ≥ <italic>k</italic>. <xref ref-type="fig" rid="F1">Figure 1</xref> sketches the relationship of these variables in the second index ℋ. Observe that if <italic>cur</italic> = <italic>lst</italic> then ℋ[<italic>cur</italic>].<italic>lcp &lt; L</italic> and if <italic>cur &lt; lst</italic> then either <italic>L</italic> = <italic>K</italic> or [<italic>cur</italic>].<italic>kmer</italic>[<italic>L</italic> + 1] <italic>&gt; α</italic>[<italic>L</italic> + 1]. The algorithm in <xref ref-type="fig" rid="F2">Figure 2</xref> below gives the logic for updating the invariant variables <italic>fst, lst, L, cur</italic> and <italic>wall</italic> from those for the <italic>i</italic><sup><italic>th</italic></sup> entry of 𝒢 to its <italic>i</italic> + 1<sup><italic>st</italic></sup> entry. This logic is explained in the proof of correctness that now follows.</p><sec id="S10"><title>Theorem 1</title><p id="P52">The algorithm in <xref ref-type="fig" rid="F2">Figure 2</xref> finds all non-repetitive adaptamer matches in <italic>G</italic> to positions in <italic>H</italic> in a sweep of their indices 𝒢 and ℋ.</p></sec><sec id="S11"><title>Proof</title><p id="P53">To start the induction imagine that both indices begin with a special <italic>K</italic>-mer that consists entirely of a special symbol <italic>ζ</italic> that is not in the alphabet of the indices and is smaller than any symbol in said alphabet. Then clearly, the correct values for this − 1<sup><italic>st</italic></sup> entry of 𝒢 is [<italic>fst, lst</italic>) = [− 1, 0), <italic>L</italic> = <italic>K</italic> and <italic>cur</italic> = − 1 (Line 1).</p><p id="P54">The algorithm then proceeds to find the correct values for each index <italic>i</italic> in in order (Line 1) in the body of the for loop incrementing <italic>i</italic> (Lines 3 to 16) and further outputs the adaptamer matches for the locations of <italic>i</italic> if not repetitive (Lines 17-18).</p><p id="P55">So consider then that <italic>fst, lst, L, cur</italic> and <italic>wall</italic> have the correct values for index <italic>i</italic> − 1 as the loop of lines 3-18 is entered with index <italic>i</italic>. To ease notation let <italic>α</italic> = 𝒢 [<italic>i</italic> − 1].<italic>kmer, β</italic> = 𝒢 [<italic>i</italic> + 1].<italic>kmer</italic>, and <italic>l</italic> = 𝒢 [<italic>i</italic> + 1].<italic>lcp</italic>.</p><p id="P56">If <italic>l &gt; L</italic> then the answer for both <italic>i</italic> and <italic>i</italic>+1 are the same as <italic>β</italic>[0, <italic>L</italic>+1] = <italic>α</italic>[0, <italic>L</italic>+1] and a match longer than <italic>L</italic> to <italic>α</italic> is already known to not be possible. If <italic>l</italic> = <italic>L</italic> and <italic>cur</italic> = <italic>lst</italic> then <italic>β</italic>[0, <italic>L</italic>] = <italic>α</italic>[0, <italic>L</italic>] <italic>&lt;</italic> ℋ[<italic>lst</italic>].<italic>kmer</italic>[0, <italic>L</italic>] so again a match longer than <italic>L</italic> to <italic>β</italic> is not possible, so the variables remain unchanged. On the other hand if <italic>l</italic> = <italic>L</italic> and <italic>cur &lt; lst</italic> [Lines 6-7] then a longer match of <italic>β</italic> to ℋ[<italic>j</italic>].<italic>kmer</italic> for some <italic>j</italic> ≥ <italic>cur</italic> is possible and it is sought in the procedure <monospace>extension</monospace>. Lastly, if <italic>l &lt; L</italic> [Line 9] then <italic>β</italic>[0, <italic>L</italic>] <italic>&gt; α</italic>[0, <italic>L</italic>] implying <italic>cur</italic> ≥ <italic>lst</italic> (Line 8). Moreover as long as ℋ[<italic>cur</italic>].<italic>lcp &gt; l, β</italic>[0, <italic>l</italic> + 1] <italic>&gt; α</italic>[0, <italic>l</italic> + 1] = ℋ[<italic>cur</italic>].<italic>kmer</italic>[0, <italic>l</italic> + 1] and so <italic>cur</italic> should be advanced (Lines 9-10). If after advance <italic>cur</italic>, ℋ[<italic>cur</italic>].<italic>lcp &lt; l</italic> then <italic>beta</italic>[0, <italic>l</italic>] <italic>&lt;</italic> ℋ[<italic>cur</italic>].<italic>kmer</italic>[0, <italic>l</italic>] implying <italic>β &lt;</italic> ℋ[<italic>cur</italic>].<italic>kmer</italic> and <italic>β</italic>[0, <italic>l</italic>] is the longest match of <italic>β</italic> to the preceding values of <italic>cur</italic>. So <italic>cur</italic> = <italic>cur</italic><sub><italic>i</italic></sub> = <italic>lst</italic><sub><italic>i</italic></sub> and <italic>fst</italic><sub><italic>i</italic></sub> = <italic>wall</italic>[<italic>l</italic>] and <italic>L</italic><sub><italic>i</italic></sub> = <italic>l</italic>, so lines 11, 12, 15 and 16 are correct. Note in this case, the adaptamer range is a superset of the range for <italic>i</italic> − 1 with a smaller adaptamer length. On the other hand, if after advance <italic>cur</italic>, ℋ[<italic>cur</italic>].<italic>lcp</italic> = <italic>l</italic>, then <italic>β</italic>[0, <italic>l</italic>] = ℋ[<italic>cur</italic>].<italic>kmer</italic>[0, <italic>L</italic>] so a longer match is possible and sought by entering procedure <monospace>extension</monospace>.</p><p id="P57">Upon entry to <monospace>extension</monospace>, ℋ[<italic>cur</italic> − 1].<italic>kmer &lt; β</italic>, and <italic>β</italic>[0, <italic>L</italic>] = ℋ[<italic>cur</italic>].<italic>kmer</italic>[0, <italic>L</italic>] = ℋ[<italic>fst</italic>].<italic>kmer</italic>[0, <italic>L</italic>] <italic>&gt;</italic> ℋ[<italic>fst</italic> − 1].<italic>kmer</italic>[0, <italic>L</italic>]. The first goal is to advance <italic>cur</italic> until ℋ[<italic>cur</italic>].<italic>kmer</italic> ≥<italic>β</italic>. If <italic>L</italic> = <italic>K</italic> (Line 1) then we are done as it implies <italic>β</italic> = ℋ[<italic>cur</italic>].<italic>kmer</italic>. Otherwise if ℋ[<italic>cur</italic>].<italic>kmer</italic>[<italic>L</italic> + 1] <italic>&lt; β</italic>[<italic>L</italic> + 1] then ℋ[<italic>cur</italic>].<italic>kmer &lt; β</italic> so <italic>cur</italic> should be advanced to the next index (Lines 2-3). If the <italic>lcp</italic> at this next element is less than <italic>L</italic>, then ℋ[<italic>cur</italic>].<italic>kmer</italic>[0, <italic>L</italic>] <italic>&gt;</italic> ℋ[<italic>cur</italic> − 1].<italic>kmer</italic>[0, <italic>L</italic>] implying ℋ[<italic>cur</italic>].<italic>kmer &gt; β</italic> and moreover that the adaptamer length of <italic>β</italic> is <italic>L</italic> and <italic>lst</italic> = <italic>cur</italic> (Lines 4-6). The routine returns in this instance. Otherwise it continues the loop of Lines 2-6 with this new value of <italic>cur</italic>. If this loop exits then ℋ[<italic>cur</italic>].<italic>kmer</italic>[<italic>L</italic> + 1] ≥ <italic>β</italic>[<italic>L</italic> + 1]. If ℋ[<italic>cur</italic>].<italic>kmer</italic>[<italic>L</italic> + 1] <italic>&gt; β</italic>[<italic>L</italic> + 1] then we have found the new value of <italic>cur</italic> as ℋ[<italic>cur</italic>].<italic>kmer &gt; β</italic> and the extension loop of Lines 1-10 is exited. Otherwise the <italic>L</italic> + 1<sup><italic>st</italic></sup> symbols are equal, so <italic>L</italic> is increased by 1 and <italic>wall</italic>[<italic>L</italic>] is updated and is potentially the new value of <italic>fst</italic> unless further extensions occur in the loop (Lines 9-10).</p><p id="P58">So when (and if) the extension loop of Lines 1-10 exits ℋ[<italic>cur</italic>].<italic>kmer</italic> ≥ <italic>β, L</italic> = <italic>lcp</italic>(<italic>β</italic>, ℋ[<italic>cur</italic>].<italic>kmer</italic>) is the adaptamer length for <italic>β</italic>. In this instance <italic>lst &gt; cur</italic> as <italic>cur</italic> is within the range of indices in ℋ that match the adaptamer. If <italic>L</italic> = <italic>K</italic> then this range is just the index <italic>cur</italic> and <italic>lst</italic> = <italic>cur</italic> + 1 (Lines 11-12). Otherwise, we must search forward from <italic>cur</italic> to find the last index in ℋ that matches the adaptamer prefix of length <italic>L</italic>. As before this is simply a matter of finding the first index for which its <italic>lcp</italic> is less than <italic>L</italic> (Lines 13-14). There is in the worst case no strong bound on how many indices would need to be searched, so pragmatically we cap <italic>lst</italic> at <italic>fst</italic> + <italic>τ</italic> + 1 as this implies that the adaptamer is repetitive and so its pairs will not be reported in Lines 17-18 of the main loop. Revisiting the early parts of the proof one can see that this slight change in the inductive hypothesis, i.e. either <italic>lst</italic> has its desired value or is <italic>fst</italic> + <italic>τ</italic> + 1 if it is greater, does not affect the correctness of the algorithm.</p><p id="P59">Considering this algorithm in terms of intersecting two suffix tries, it takes time proportional to the number of edges in the intersection, save for vertices near the root where <italic>O</italic>(<italic>τ</italic>) time might be taken as opposed to <italic>O</italic>(1) time. Theoretically we could just consider <italic>τ</italic> a small constant. But to get an idea of how much work is done in a typical merge, we captured statistics for our running example of comparing two bats where the genomes are of size 2.23Gbp (<italic>G</italic>) and 2.56Gbp (<italic>H</italic>). 𝒢 has <italic>N</italic> = 1.603 billion K-mers that begin with (12, 8) syncmers. The intersection of this index with ℋ had only 2.646 billion edges indicating that most consecutive adaptamers differ in one or two characters at their end, that is, the intersection is <italic>O</italic>(<italic>N</italic>) in expectation (and not <italic>O</italic>(<italic>KN</italic>), the worst case). Moreover, the algorithm only makes 4.356 billion character comparisons, or less than 3 per adaptamer found. Finally, line 14 was executed only .807 billion times reflecting that in most cases the (<italic>fst, lst</italic>) interval is typically of size 1. While only a single data point, this is typical in our experience, and exemplifies why it is much more efficient to merge indices rather than to do single entry lookups.</p><p id="P60">The fact that an adaptamer in <italic>G</italic> is not necessarily an adaptamer in <italic>H</italic> gave us some concern. One can make matters symmetric by simply computing the union of the seed hits for the adaptamers of both genomes and FastGA will do this when the -S option is set. We achieve this by simply running the merge of 𝒢 versus ℋ and then of ℋ versus 𝒢, and taking the union of the seed locations found. We anecdotally observe that the difference is primarily that, with the union, FastGA finds additional short repetitive alignments in <italic>H</italic>. Thus for genome alignment where repetitive matches not flanked by homologous sequence are not of interest, we advise that the difference is not important enough to be worth the additional compute time. The one application where we would recommend using the -S option is for <italic>ab initio</italic> repeat finding and modeling.</p></sec></sec><sec id="S12"><label>3.2</label><title>Storing and Delivering Alignments</title><sec id="S13"><label>3.2.1</label><title>Trace Points</title><p id="P61">FastGA typically finds anywhere from several hundred thousand to tens of millions of alignments depending on genome size, evolutionary distance, and repetitiveness. Each alignment aligns an interval <italic>A</italic>[<italic>ab, ae</italic>] of the first genome against an interval <italic>B</italic>[<italic>bb, be</italic>] of the second. To encode the alignment there are two obvious approaches: (1) just record the 4 interval endpoints and recompute the details of the alignment when needed, or (2) record the details by noting where exactly each inserted and deleted base occurs so that the alignment can be delivered in linear time, e.g. via a CIGAR string [<xref ref-type="bibr" rid="R2">2</xref>]. For this discussion assume <italic>n</italic> = <italic>ae</italic> − <italic>ab</italic> and the sequence dissimilarity is <italic>ϵ</italic> = <italic>d/n</italic>, so that <italic>be</italic> − <italic>bb</italic> ≤ <italic>n</italic>(1 + <italic>ϵ</italic>) = <italic>o</italic>(<italic>n</italic>) and we use <italic>d</italic> or <italic>ϵ</italic> inter-changeably in characterizing complexities. So approach (1) requires <italic>o</italic>(1) space to store the alignment but <italic>O</italic>(<italic>nd</italic>) worst-case, <italic>O</italic>(<italic>n</italic> + <italic>d</italic><sup>2</sup>) expected time to deliver it when needed using the Myers-Ukkonen wave algorithm [<xref ref-type="bibr" rid="R31">31</xref>, <xref ref-type="bibr" rid="R32">32</xref>]. In contrast, approach (2) requires <italic>o</italic>(<italic>d</italic>) space for storage and only <italic>O</italic>(<italic>n</italic>) to deliver the alignment. Note in both cases the work-space product is <italic>O</italic>(<italic>nd</italic>).</p><p id="P62">The idea of <italic>trace points</italic> delivers a continuum of space-time tradeoffs between the two methods that is determined by a <italic>trace point spacing</italic> parameter <italic>δ</italic>. Consider the sequence <italic>A</italic> to be partitioned into a series of panels – <italic>A</italic>[0, <italic>δ</italic>], <italic>A</italic>[<italic>δ</italic>, 2<italic>δ</italic>], <italic>A</italic>[2<italic>δ</italic>, 3<italic>δ</italic>], … each of exactly <italic>δ</italic> symbols. Then <italic>A</italic>[<italic>ab, ae</italic>] is the concatenation of the panels <italic>A</italic>[<italic>ab, x</italic><sub>1</sub><italic>δ</italic>], <italic>A</italic>[<italic>x</italic><sub>1</sub><italic>δ, x</italic><sub>2</sub><italic>δ</italic>], … <italic>A</italic>[<italic>x</italic><sub><italic>t</italic></sub><italic>δ, ae</italic>] where <italic>x</italic><sub>1</sub> = ⌊<italic>ab/δ</italic> + 1 ⌋, <italic>x</italic><sub><italic>i</italic></sub> = <italic>x</italic><sub><italic>i</italic>−1</sub> + 1, and <italic>x</italic><sub><italic>t</italic></sub> = ⌊ (<italic>ae</italic> − 1)<italic>/δ</italic> ⌋. Obviously, the first and last panels may be shorter than <italic>δ</italic> but the point is that the division of the interval [<italic>ab, ae</italic>] is implicit, one only needs <italic>δ</italic> to know the partitioning. Next, observe that in an alignment between <italic>A</italic>[<italic>ab, ae</italic>] and <italic>B</italic>[<italic>bb, be</italic>], the <italic>B</italic> interval <italic>B</italic>[<italic>bb, be</italic>] is itself partitioned into the same number of panels as the partition <italic>A, B</italic>[<italic>y</italic><sub>0</sub>, <italic>y</italic><sub>1</sub>], <italic>B</italic>[<italic>y</italic><sub>1</sub>, <italic>y</italic><sub>2</sub>], … <italic>B</italic>[<italic>y</italic><sub><italic>t</italic></sub>, <italic>y</italic><sub><italic>t</italic>+1</sub>] where <italic>y</italic><sub>0</sub> = <italic>bb, y</italic><sub><italic>t</italic>+1</sub> = <italic>be</italic>, and the overall alignment is the concatenation of the subalignments between <italic>A</italic>[<italic>x</italic><sub><italic>i</italic></sub><italic>δ, x</italic><sub><italic>i</italic>+1</sub><italic>δ</italic>] versus <italic>B</italic>[<italic>y</italic><sub><italic>i</italic></sub>, <italic>y</italic><sub><italic>i</italic>+1</sub>]. This <italic>B</italic> partitioning is not unique, as the splitting of any symbols inserted in <italic>B</italic> between the symbols <inline-formula><mml:math id="M3"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>δ</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M4"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>δ</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> can be arbitrary. But all that is important is that such a division is possible and an instance easily determined (e.g. place all inserted <italic>B</italic> symbols in the left interval). <xref ref-type="fig" rid="F3">Figure 3</xref> illustrates the division. Immediately observe that the length of each <italic>B</italic> panel induced by the alignment, <italic>b</italic><sub><italic>i</italic></sub> = <italic>y</italic><sub><italic>i</italic>+1</sub> − <italic>y</italic><sub><italic>i</italic></sub> for <italic>i</italic> = 0 to <italic>t</italic>, is not fixed but generally varies between <italic>δ</italic>(1 − <italic>E</italic>) and <italic>δ</italic>(1 + <italic>E</italic>). We call the <italic>t</italic> + 1-element array of <italic>B</italic>-panel lengths, <italic>&lt; b</italic><sub>0</sub>, <italic>b</italic><sub>1</sub>, …, <italic>b</italic><sub><italic>t</italic></sub> <italic>&gt;</italic> the <italic>trace point array</italic> for the alignment.</p><p id="P63">The trace point array, along with the four endpoints, provides a record of an alignment with just <italic>t</italic> + 1 = <italic>o</italic>(<italic>n/δ</italic>) integers of magnitude <italic>O</italic>(<italic>δ</italic>), and we now show how to reconstruct the full alignment in <italic>O</italic>(<italic>n</italic> + <italic>δd</italic>) time. Given the array one can easily in <italic>O</italic>(<italic>n/δ</italic>) time reconstruct the <italic>y</italic><sub><italic>i</italic></sub>’s and <italic>x</italic><sub><italic>i</italic></sub>’s above, so the problem remains to deliver the <italic>t</italic> + 1 sub-alignments for <italic>A</italic>[<italic>x</italic><sub><italic>i</italic></sub><italic>δ, x</italic><sub><italic>i</italic>+1</sub><italic>δ</italic>] versus <italic>B</italic>[<italic>y</italic><sub><italic>i</italic></sub>, <italic>y</italic><sub><italic>i</italic>+1</sub>] in order of <italic>i</italic>. For this we use the <italic>O</italic>((<italic>n</italic> +<italic>m</italic>)(<italic>p</italic>+1)) “skewed-wave” algorithm by Myers and co-authors from 1990 [<xref ref-type="bibr" rid="R33">33</xref>] where the parameter <italic>p</italic> = <italic>d</italic> − |<italic>m</italic> − <italic>n</italic>| reduces the effect of “skewed” problems where <italic>n</italic> » <italic>m</italic> or vice versa. This is important here because theoretically there is no limit on the skew between a particular <italic>b</italic><sub><italic>i</italic></sub> and <italic>δ</italic>. Suppose <italic>b</italic><sub><italic>i</italic></sub> = <italic>δ</italic> + <italic>x</italic> for <italic>x &gt;</italic> 0. Then the skew wave algorithm takes <italic>O</italic>(<italic>δ</italic> + (<italic>δ</italic> + <italic>x</italic>)(<italic>d</italic><sub><italic>i</italic></sub> − <italic>x</italic>)) where <italic>d</italic><sub><italic>i</italic></sub> is the number of differences for sub-problem <italic>i</italic> and thus Σ<sub><italic>i</italic></sub><italic>d</italic><sub><italic>i</italic></sub> = <italic>d</italic>. At worst <italic>d</italic><sub><italic>i</italic></sub> = <italic>b</italic><sub><italic>i</italic></sub> under the simple unit-cost model, so <italic>d</italic><sub><italic>i</italic></sub> − <italic>x</italic> ≤ <italic>b</italic><sub><italic>i</italic></sub> − <italic>x</italic> = <italic>δ</italic> and thus (<italic>δ</italic> + <italic>x</italic>)(<italic>d</italic><sub><italic>i</italic></sub> − <italic>x</italic>) = <italic>δd</italic><sub><italic>i</italic></sub> + <italic>x</italic>((<italic>d</italic><sub><italic>i</italic></sub> − <italic>x</italic>) − <italic>δ</italic>) ≤ <italic>δd</italic><sub><italic>i</italic></sub>. So the time taken is <italic>O</italic>(<italic>δ</italic>(<italic>d</italic><sub><italic>i</italic></sub> + 1)). If <italic>b</italic><sub><italic>i</italic></sub> = <italic>δ</italic> − <italic>x</italic>, then the algorithm takes <italic>O</italic>(<italic>δ</italic>(<italic>d</italic><sub><italic>i</italic></sub> − (<italic>δ</italic> − <italic>x</italic>))) which is trivially <italic>O</italic>(<italic>δd</italic><sub><italic>i</italic></sub>). So altogether the time taken to compute the <italic>t</italic> + 1 sub-alignments is <italic>O</italic>(Σ<sub><italic>i</italic></sub><italic>δ</italic>(<italic>d</italic><sub><italic>i</italic></sub> + 1)) = <italic>O</italic>(<italic>n</italic> + <italic>δd</italic>).</p><p id="P64">Note that the space-time product is <italic>O</italic>(<italic>n/δ</italic>)<italic>O</italic>(<italic>n</italic> + <italic>δd</italic>) = <italic>O</italic>(<italic>n</italic>(<italic>d</italic> + <italic>n/δ</italic>)) which is a bit more than for the initial two approaches, but nonetheless we have achieved a continuum of space-time tradeoffs parameterized on <italic>δ</italic>. In particular, note that constructing an alignment from the tracepoints is <italic>O</italic>(<italic>n</italic>) for a fixed value of <italic>δ</italic> and the space-time product <italic>is O</italic>(<italic>nd</italic>) when <italic>ϵ</italic> ≥ 1<italic>/δ</italic>. In FastGA and other applications we use <italic>δ</italic> = 100 as it allows the <italic>b</italic><sub><italic>i</italic></sub> to fit in a single byte. The astute reader will note that a trace point length could exceed 255 if there is a large insertion in <italic>B</italic> for a particular panel. One can handle this by using a coding scheme for integers that is adaptive to size so that a byte is used in expectation. But we have rather implemented our unit-cost wave algorithm so that it considers such a large gap a break in genome similarity as discussed earlier. As an example then, for an alignment covering 10,000bp we encode an alignment in 100 bytes regardless of <italic>ϵ</italic>, versus a CIGAR string of thousands of bytes for an 80% identity alignment. Moreover, in empirical trials we can convert our trace-point encoded ALN-files to PAF-format with CIGAR strings at a rate of roughly 100 million aligned bases per second on our laptop<sup>1</sup> including the time taken to refine gaps as described next.</p></sec><sec id="S14"><label>3.2.2</label><title>Gap Refinement</title><p id="P65">While our adaptive wave algorithm is well-suited to discovering similar regions, it is true that the alignments it delivers do not properly align letters within even modest gaps, for example see <xref ref-type="fig" rid="F4">Figure 4(a)</xref>. An interesting empirical observation is that most of these undesirable placements would be rectified if one could deliver the optimal unit cost alignment with the <italic>fewest gaps</italic>, for example, see <xref ref-type="fig" rid="F4">Figure 4(b)</xref>. The connection to the use of an affine gap model for alignment is that solving this problem is equivalent to adding an infinitesimal gap start cost to the unit cost model<sup><xref ref-type="fn" rid="FN4">2</xref></sup>.</p><p id="P66">Therefore, prior to reporting an alignment’s path through the underlying dynamic programming (d.p.) matrix, we seek to modify the path so as to reduce the number of gaps. We encode the path delivered by the trace point algorithm described above as an <italic>O</italic>(<italic>d</italic>) array that indicates where to place dashes between the symbols of <italic>A</italic> and <italic>B</italic> so as to expose the aligned bases as illustrated in <xref ref-type="fig" rid="F4">Figures 4</xref> above. Specifically, we produce an <italic>indel array &lt; o</italic><sub>1</sub>, <italic>o</italic><sub>2</sub>, ..<italic>o</italic><sub><italic>a</italic></sub> <italic>&gt;</italic> of strictly positive and negative integers of non-decreasing magnitude where if <italic>o</italic><sub><italic>i</italic></sub> <italic>&gt;</italic> 0 then one should insert a dash before symbol <inline-formula><mml:math id="M5"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:msub><mml:mi>O</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> of the sequence <italic>A</italic>, and if <italic>o</italic><sub><italic>i</italic></sub> <italic>&lt;</italic> 0 then one should insert a dash before symbol <inline-formula><mml:math id="M6"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>o</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> of the sequence <italic>B</italic>. <xref ref-type="fig" rid="F4">Figure 4(c)</xref> gives an example of the indel array for the alignment of <xref ref-type="fig" rid="F4">Figure 4(a)</xref>. In this representation of the alignment, the regions we seek to improve are captured by maximal segments of the array <italic>&lt; o</italic><sub><italic>x</italic></sub>, <italic>o</italic><sub><italic>x</italic>+1</sub>, …<italic>o</italic><sub><italic>y</italic></sub> <italic>&gt;</italic> such that (a) all the numbers have the same sign (i.e. all deletions or all insertions), (b) <italic>y</italic> − <italic>x</italic> ≥1, and (c) |<italic>o</italic><sub><italic>i</italic>+1</sub> − <italic>o</italic><sub><italic>i</italic></sub> |<italic>&lt; R</italic> for all <italic>i</italic> ∈ [<italic>x, y</italic>), where <italic>R</italic> is a separation parameter that we set to 50. This is easy to do in a linear sweep of the array. Without loss of generality we consider the case where all numbers are positive. The region between the first and last insert consists of <italic>D</italic> = <italic>y</italic> − <italic>x</italic> + 2 diagonals and <italic>L</italic> = <italic>o</italic><sub><italic>y</italic></sub> − <italic>o</italic><sub><italic>x</italic></sub> + 1 columns of the d.p. matrix, which we consider in relative terms by considering the start of the insertion edge for <italic>o</italic><sub><italic>x</italic></sub> as the coordinate (0, 0). <xref ref-type="fig" rid="F5">Figure 5</xref> illustrates this <italic>D</italic> × <italic>L</italic> trapezoidal region for the positive run of the trace for <xref ref-type="fig" rid="F4">Figure 4(a)</xref> and the revised path corresponding to the alignment in 4(b).</p><p id="P67">We seek the best alignment from (0,0) to (D,L+D) that does not involved deletions as we are only assessing whether the number of insertion gaps can be reduced. So our basic recurrence is the classic one of Gotoh but with the deletion or D-terms removed and a gap initiation cost of 1 (so a first insertion costs 2): <disp-formula id="FD1"><mml:math id="M7"><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>=</mml:mo><mml:mfenced close="" open="{"><mml:mrow><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mtext> if </mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext> otherwise </mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mfenced><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>δ</mml:mi><mml:mfenced><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfenced></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext> for </mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mtext>.</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
</p><p id="P68">Rather than compute the recurrences above over the trapezoid, we use path compression [<xref ref-type="bibr" rid="R34">34</xref>] and a greedy wave approach to arrive at a novel and faster solution for this special problem. A simple lower bound on the cost of any path from a vertex (<italic>i, j</italic>) to the goal Φ = (<italic>L, D</italic> + <italic>L</italic>) is the number of insertions needed to get from its diagonal <italic>i</italic> − <italic>j</italic> to the goal diagonal <italic>D</italic>, i.e. <italic>L</italic>(<italic>i, j</italic>) = <italic>D</italic> − (<italic>i</italic> − <italic>j</italic>). Given such a lower bound and the <italic>acyclic</italic> d.p. graph, the cost of every edge <italic>v</italic> → <italic>w</italic> can be reduced by − <italic>L</italic>(<italic>v</italic>) <italic>L</italic>(<italic>w</italic>) without changing the set of optimal paths whose cost under the “compressed” problem is <italic>C</italic>′(Φ) = <italic>C</italic>(Φ) − <italic>L</italic>(Φ) = <italic>C</italic>(Φ) − <italic>G</italic> (see [<xref ref-type="bibr" rid="R34">34</xref>]). In our specific case, the given lower bound reduces the cost of insertion edges by 1, so that the recurrence for <italic>I</italic>-nodes becomes: <disp-formula id="FD2"><mml:math id="M8"><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mrow><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>for </mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
that is, gap starts cost 1 and gap continuations have 0 cost.</p><p id="P69">We find the optimal path under the compressed edge costs using a wave algorithm where the cost <italic>k</italic>-wave consists of the furthest <italic>C</italic>-vertices <italic>F</italic><sub><italic>k</italic></sub>(<italic>d</italic>) reachable along each diagonal <italic>d</italic> ∈ [0, <italic>D</italic>] via a cost <italic>k</italic> path from the origin (0, 0). To determine the recurrence for <italic>F</italic><sub><italic>k</italic>+1</sub>(<italic>d</italic>) we need to consider all the ways one could reach the point on a path of cost 1 from a <italic>k</italic>-wave vertex. To wit, one can
<list list-type="alpha-lower" id="L1"><list-item><p id="P70">start at <italic>F</italic><sub><italic>k</italic></sub>(<italic>e</italic>) for <italic>e &lt; d</italic>, take a cost 1 insertion to the <italic>I</italic>-node in diagonal <italic>e</italic> + 1, then take 0 cost insertion edges to diagonal <italic>d</italic>, transition to the <italic>C</italic>-node, and then follow 0-cost diagonal <italic>C</italic> edges as far as possible, or</p></list-item><list-item><p id="P71">start at <italic>F</italic><sub><italic>k</italic></sub>(<italic>d</italic>), take a substitution edge of cost 1 forward along diagonal <italic>d</italic>, then follow 0-cost diagonal <italic>C</italic> edges as far as possible</p></list-item></list></p><p id="P72">This leads to the following recurrence: <disp-formula id="FD3"><mml:math id="M9"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>S</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo>+</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mtext> where </mml:mtext><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi><mml:mfenced><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>F</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfenced></mml:mrow></mml:math></disp-formula>
which in turn leads to the simple algorithm below where a single array <monospace>F[0..D]</monospace> keeps the furthest reaching points in each diagonal <italic>d</italic> by keep the <italic>A</italic> sequence position <italic>i</italic> where the <italic>B</italic> position is then implicitly <italic>d</italic> − <italic>i</italic>.</p><preformat preformat-type="dialog">
0. int Snake(x,y) { return max s: x[1..s] = y[1..s] }
1. k = F[D] = 0
2. while F[D] &lt; L do
3.  { k += 1
4.    m = 0
5.    for e = 0 .. D do
6.      { i = max(F[e]+1, m)
7.        m = max(m, F[e])
8.        F[e] = i + Snake(A+i,B+(i-e))
       }
    }
</preformat><p id="P73">The algorithm stops with <italic>k</italic> = <italic>C</italic>′(Φ) which is the number of gaps and mismatches in the alignment. If <italic>G</italic> is the number of gaps and <italic>S</italic> the number of mismatches in the best answer of score <italic>k</italic> = <italic>G</italic> + <italic>S</italic>, then the algorithm takes <italic>O</italic>((<italic>G</italic> + <italic>S</italic>)<italic>D</italic> + <italic>L</italic>) expected time. A bi-directed linear space construction of a best alignment achieving this score is <italic>not</italic> possible for the compressed version of the problem, so we simply maintain a vector for each successive wave and then trace back the optimal path involving the smallest number of gaps. Indeed, note that with the chosen scoring scheme, we will permit a single mismatch if it allows us to eliminate a gap. If we had chosen a gap start cost of <italic>g</italic>, then we would be permitting <italic>g</italic> mismatches in order to eliminate a gap. Although in theory gap costs can be associated with expected insertion distributions, in practice our experience is that choosing <italic>g</italic> = 1 behaves robustly to avoid obviously improvable gaps in alignments on visual inspection.</p><p id="P74">To get an idea of how much work is done processing a typical alignment file, we captured statistics for our comparison between two bats that delivers 1.63 billion base pairs of aligned sequence. There were 64.6 million gaps in the initial set of unit-cost alignments. 46.1 million of these occurred in 11.93 million inspected trapezoids for which we ended up removing 13.7 million gaps. The average product of (<italic>G</italic> + <italic>S</italic>)<italic>D</italic> was 88 over all the trapezoids, with the maximum for <italic>D</italic> being 121, the maximum for <italic>G</italic> + <italic>S</italic> being 133, and the largest product being 15, 125. 9.6 million of the problems had product less than 100, and 11.84<italic>M</italic> were less than 1000. When converting a trace-point alignment file of these alignments to CIGAR strings for a PAF file, only 6.7 seconds were spent on gap refinement which constituted roughly 15% of the total compute time for the task.</p></sec></sec></sec><sec id="S15"><label>4</label><title>Software</title><sec id="S16"><label>4.1</label><title>The Framework</title><p id="P75">Using <bold>FastGA</bold> can be as simple as calling it with two (optionally gzip compressed) FASTA files containing genome sequences, where each entry is a scaffold with runs of Ns separating contigs. By default a PAF file encoding all the local alignments found between the two genomes is streamed to the standard output. The code is available at <ext-link ext-link-type="uri" xlink:href="http://www.github.com/thegenemyers/FASTGA">http://www.github.com/thegenemyers/FASTGA</ext-link> along with some example data so the user can try running it themselves.</p><p id="P76">Under the surface, a number of intermediate steps take place. First, the FASTA files are converted to <italic>genome databases</italic> with extension .<monospace>1gdb</monospace> that are a <monospace>ONEcode</monospace> [<xref ref-type="bibr" rid="R3">3</xref>] binary file and associated hidden file containing the ASCII DNA sequences in 2-bit compressed form. This allows FastGA to randomly access contigs without text parsing. Second, a <italic>genome index</italic> with extension .<monospace>gix</monospace> is then built for each genome that contains the truncated suffix array and associated lcp array (see <xref ref-type="sec" rid="S5">Subsection 2.2</xref>). Third, FastGA records all the alignments it finds in a <monospace>ONEcode</monospace> binary file we refer to as an ALN-formatted file with extension .<monospace>1aln</monospace> that uses the space efficient trace point encoding of each alignment described earlier in <xref ref-type="sec" rid="S16">subsection 4.1</xref>. Finally in linear time, this trace point representation is converted into the desired PAF output. Importantly, one has the option to keep the results in the ALN file, and then convert it to any of PAF, PSL, or other desired alignment format on demand. The diagram of <xref ref-type="fig" rid="F6">Figure 6</xref> summarizes and details the data flow just described.</p><p id="P77">While the entire set of transformation processes can be fired off by simply calling FastGA, we provide routines to perform each step under direct control. In addition we provide utilities listed at right in <xref ref-type="fig" rid="F6">Figure 6</xref> that allow one to examine the intermediate GDB, GIX, and ALN files. An invocation of FastGA with the -k option or direct application of the sub-process routines, creates persistent GDB and GIX entities that can be reused, saving time if a given genome is to be compared repeatedly. The GDB and GIX items are actually each an ensemble, consisting of a proxy file and a number of hidden files. So we provide the utilities GIXmv, GIXcp, and GIXrm to manipulate these ensembles. Finally, we provide the utility GDBtoFA that inverts the process of converting a FASTA file into a GDB.</p><p id="P78">FastGA features the use of the <monospace>ONEcode</monospace> data encoding framework for both its’ GDB and ALN files that encode all the alignments found. As such FastGA also supports as input <monospace>ONEcode</monospace> sequence files that encode a genome, in addition to the usual FASTA format. So both FAtoGDB and GDBtoFA (despite their names) also recognize and support <monospace>ONEcode</monospace> SEQ files as well as FASTA. In addition, the GDB and ALN files can be viewed with the ONEview utility of the <monospace>ONEcode</monospace> framework.</p></sec><sec id="S17"><label>4.2</label><title>ONEcode</title><p id="P79">The alignment records produced by FastGA are written into a <monospace>ONEcode</monospace> file [<xref ref-type="bibr" rid="R3">3</xref>]. <monospace>ONEcode</monospace> is a general data framework created by Myers and Durbin that is unpublished and in the open domain being freely available at <ext-link ext-link-type="uri" xlink:href="http://www.github.com/thegenemyers/ONEcode">http://www.github.com/thegenemyers/ONEcode</ext-link>. The three main ideas dominating the design of the framework are that (1) it should be easy to understand and use, (2) the core implementation should be succint without any package dependencies, and (3) despite (1) and (2) it should support space and time efficient binary representations fit for production scale data analysis. A key feature is that, in common with other bioinformatics formats such as SAM/BAM and VCF/BCF there are always interconvertible ASCII and binary versions of each ONEcode file.</p><p id="P80">In the ASCII version, data is stored as a sequence of strongly-typed lines (records) each of which begins with a single character (the 1-code) that determines the nature of the data that follows on the line, where individual items can be an integer, real, char, or list of any of these. Integers and reals can be up to 64-bit precision and only one list is permitted per line type. Every <monospace>ONEcode</monospace> file has a header section that (a) gives the series of commands, or provenance, that created it, (b) the schema of the data to follow, i.e. it is self-describing, and (c) information on the number and maximum sizes of the various types of data that follow, in support of aim (1) above. The ASCII encoding is normally only used for viewing by a human being or rapid prototyping at a small scale. For every ASCII file there is a corresponding binary encoding which (a) permits random access to any item via an indexing scheme, and (b) compresses every item in a manner specific to the datum’s type and on a per item basis.</p><p id="P81">In support of the framework, there is a C-library that reads and writes <monospace>ONEcode</monospace> data, where reading is transparent to whether the input is ASCII or binary and writing can be in either mode. It further supports multi-threaded reading and writing. There are also two utilities: <monospace>ONEview</monospace>, that allows extractions of arbitrary (intervals of) objects and also can convert between binary and ASCII file types, and <monospace>ONEstat</monospace>, that verifies the correctness of a <monospace>ONEcode</monospace> file and can display summary statistics about what is within.</p><p id="P82">In our experience, <monospace>ONEcode</monospace> binary files are as efficient if not more so than say gzip’d FASTA files or BAM files, while allowing direct indexing without the need of precomputing an index of a file (e.g. bgzip). Indeed, in the case of storing alignments we had originally been using a custom binary format for storing trace-point based alignment records, but when we developed an equivalent <monospace>ONEcode</monospace> schema, the resulting files were 25% smaller due to the built-in line compression. Manipulating and viewing these files is then immediately supported by the framework at production scale efficiency. In particular, the schema entails encoding each tracepoint sequence as a list of integers. <monospace>ONEcode</monospace> stores these as the first value and then the sequence of first-forward differences in the minimum number of bits possible, and then compresses these with a Huffman scheme trained on the condensed trace-point lists. New schemas for <monospace>ONEcode</monospace> file types can easily be constructed for new data models, and they can also be extended while maintaining backwards compatibility with existing ones. Indeed we have already used <monospace>ONEcode</monospace> files for diverse purposes including in the ancient DNA phylogeny placement package PathPhynder [<xref ref-type="bibr" rid="R35">35</xref>].</p></sec></sec><sec id="S18"><label>5</label><title>Experimental Results</title><p id="P83">In order to assess the performance of FastGA, we compared it to four other genome aligners: minimap2 ([<xref ref-type="bibr" rid="R19">19</xref>], version 2.28), LastZ ([<xref ref-type="bibr" rid="R16">16</xref>], version 1.04.22), wfmash ([<xref ref-type="bibr" rid="R22">22</xref>], version 0.21.0) and NUCmer ([<xref ref-type="bibr" rid="R18">18</xref>], version 4.0.0rc1). We first evaluated the performance of each method using simulated genomes to establish a controlled bench-mark. We then applied the methods to real genomic data by aligning several mammalian genomes to the CHM13 human reference ([<xref ref-type="bibr" rid="R36">36</xref>]), assessing performance in a more biologically relevant context. Finally, to evaluate the generalisability of the methods across divergent species, we extended our analysis to representatives from six animal lineages across a range of genome sizes: one each from insects, fishes, birds, reptiles, mammals, and amphibia.</p><p id="P84">For real genomes, the soft-masked sequences were supplied to LastZ, allowing the tool to appropriately handle repetitive regions. We enabled alignment CIGAR-string output by adding the ‘-pafx’ option to FastGA, ‘-c’ option to minimap2 and ‘<monospace>--</monospace>format=PAF:wfmash’ option to LastZ. For LastZ and NUCmer, alignments were performed between individual pairs of chromosomes (or other assembly scaffold sequences) to accommodate input sequence size limitations, with each job executed using a single thread; while for FastGA, minimap2 and wfmash, the entire genomes were used as inputs and the alignments were performed using 16 threads. CPU time and memory usage for each job were recorded using the Linux command ‘/usr/bin/time -v’. Experiments were performed on a machine running the Ubuntu 22.04 Linux operating system, equipped with 376 GB of memory and two Intel(R) Xeon(R) Gold 6226R CPUs @ 2.90GHz with a total of 32 cores supporting up to 64 threads.</p><sec id="S19"><label>5.1</label><title>Simulated Genomes</title><p id="P85">We simulated a pair of genomes, designated 𝒜 and ℬ, composed of 10 kb blocks, each starting with a region of similarity of varying length (from 100 bp to 5 kb) and divergence (from 1% to 65%) followed by random sequence, with the order of the blocks randomised in the genomes so that there are no long-range alignments across multiple blocks. With 100 replicates for set of similarity parameters (length and divergence) in total the “genomes” were each 84 Mb long. The sequence divergences were introduced by random single nucleotide substitutions (80%), insertions (10%), and deletions (10%) on the genome ℬ.</p><p id="P86">Computational efficiency was evaluated in terms of runtime and memory usage. LastZ recorded the longest runtime, taking 84.5 CPU minutes to finish, followed by wfmash (19.3 minutes) and NUCmer (2.4 minutes), while both FastGA and minimap2 completed within one minute. LastZ recorded the least peak memory usage (0.72 GB), followed by NUCmer (0.99 GB), FastGA (1.32 GB), minimap2 (1.65 GB) and wfmash (3.41 GB).</p><p id="P87">The number of alignments reported by FastGA, minimap2, LastZ, wfmash and NUCmer were 2,749, 2,724, 4,339, 1,141, and 1,974, respectively, covering 5.70 Mb, 5.36 Mb, 7.56 Mb, 15.66 Mb and 3.59 Mb sequences of the genome 𝒜. Overall, FastGA, minimap2, LastZ and NUCmer showed higher specificity than wfmash, with false aligned bases totalling 3.42 kb (0.06%), 2.53 kb (0.05%), 2.75 kb (0.04%), and 1.82 kb (0.05%), respectively, compared to wfmash’s 11.63 Mb (74.26%). Here we defined false aligned bases as alignment positions mapping outside the simulated target regions of similarity in genome 𝒜. We also counted false positives as alignments that spanned multiple target regions or had more than 95% of their aligned bases falling outside the target region, on either genome 𝒜 or <italic>B</italic>. Under this criterion, FastGA, minimap2, and NUCmer reported no false positives, LastZ reported one false positive, and wfmash reported 630 false positive alignments.</p><p id="P88">The true positive alignments were counted for every combination of region length and sequence divergence to assess the sensitivity of the genome aligners. We only considered complete alignments where their aligned bases covered at least 95% of the designated target region on both genomes. The results are depicted in <xref ref-type="fig" rid="F7">Figure 7</xref>, with details showed in <xref ref-type="supplementary-material" rid="SD1">Supplementary Table S1</xref>. As expected, the number of target regions fully recovered by the various aligners increased with target length and decreased with sequence divergence. This trend held across all aligners except wfmash, which only produced meaningful results when the target length reached 5,000 bp. For shorter regions, most wfmash alignments were false positives spanning multiple target regions, likely due to the initial coarse-grained matching criteria used by wfmash. FastGA and minimap2 displayed very similar behaviour. Their sensitivities began to decline noticeably at sequence divergences exceeding 1%, 10%, 15%, 20%, 25%, and 30% for region lengths of 100 bp, 200 bp, 500 bp, 1000 bp, 2000 bp, and 5000 bp, respectively. FastGA was slightly less sensitive than minimap2 for smaller region lengths but more sensitive for larger regions. NUCmer had similar performance to FastGA and minimap2 at region lengths of 100 bp and 200 bp but became less sensitive than both for regions exceeding 200 bp, with the performance gap widening as region length increased. LastZ consistently demonstrated higher sensitivity than the other genome aligners. It was also the only aligner to produce reasonable alignment results at 40% sequence divergence, albeit only for regions of 2000 bp and 5000 bp.</p></sec><sec id="S20"><label>5.2</label><title>Mammalian Genomes</title><p id="P89">We selected five mammalian genomes representing a gradient of phylogenetic distances to humans and aligned them to the CHM13 “telomere-to-telomere” reference genome (3,117 Mb, <monospace>GCF 009914755.1</monospace>, [<xref ref-type="bibr" rid="R36">36</xref>]). The selected genomes, listed from closest to farthest in relation to CHM13, were: human GRCh38 (3,298 Mb, <monospace>GCF 000001405.40</monospace>, [<xref ref-type="bibr" rid="R37">37</xref>]), chimpanzee (3,178 Mb, <monospace>GCF 028858775.2</monospace>, [<xref ref-type="bibr" rid="R38">38</xref>]), siamang (3,263 Mb, <monospace>GCF 0288780 55.3</monospace>, [<xref ref-type="bibr" rid="R38">38</xref>]), pig (2,612 Mb, <ext-link ext-link-type="uri" xlink:href="http://gigadb.org/dataset/102692/">http://gigadb.org/dataset/102692/</ext-link>, [<xref ref-type="bibr" rid="R39">39</xref>]), and mouse (2,731 Mb, <monospace>GCA 9641885 35.1</monospace>).</p><p id="P90">FastGA completed genome alignments in under 71 CPU minutes for all cases, with runtime decreasing as the evolutionary distance from the human reference increased. Specifically, alignment took 70.5 minutes for human, 28.7 for chimpanzee, 26.8 for siamang, 17.4 for pig, and 16.6 for mouse. It demonstrated superior speed performance compared to all the other genome aligners, achieving speedups ranging from 29.5× to 102.4 × over minimap2, 19.1 × to 590.1 × over wfmash, 93.3 × to 843.0 × over NUCmer, and 604.8 × to 2057.1 × over LastZ (<xref ref-type="fig" rid="F8">Figure 8a</xref>, <xref ref-type="supplementary-material" rid="SD1">Supplementary Table S2</xref>). FastGA also showed excellent memory efficiency, with all alignments using less than 20 GB of memory, making it feasible to run the analysis on a modern laptop. In comparison, minimap2 consumed 81 to 177 GB and wfmash consumed 84 to 105 GB of memory for these jobs. LastZ and NUCmer exhibited lower memory usages than FastGA, with a maximum consumption of only 2 GB and 5 GB, respectively (<xref ref-type="fig" rid="F8">Figure 8b</xref>, <xref ref-type="supplementary-material" rid="SD1">Supplementary Table S2</xref>).</p><p id="P91">The alignment results produced by different aligners vary substantially, making direct comparison of the actual alignments difficult. For instance, on the human GRCh38 genome, the number of alignments reported by FastGA, minimap2, LastZ, wfmash, and NUCmer were 579,084, 3,401, 5,628,168, 61,711 and 70,340,384, respectively. The corresponding total alignment sizes were 12,446 Mb, 3,212 Mb, 10,583 Mb, 3,124 Mb, and 94,640 Mb. We observed similar trends on the chimpanzee and siamang genomes (<xref ref-type="supplementary-material" rid="SD1">Supplementary Table S2</xref>). While the inherent sensitivity and specificity of genome aligners contribute to these differences, postprocessing strategies, such as alignment chaining and the handling of repetitive sequences, also play a critical role. In the GRCh38 example, minimap2 and NUCmer represent two extremes: minimap2 aggressively chains alignments and removes most repetitive matches outside primary chains, whereas NUCmer skips chaining and retains hits to repetitive regions. Despite the noticeable differences in alignment counts and total sizes, the number of GRCh38 bases covered by each aligner was very similar - 3,121 Mb, 3,134 Mb, 3,068 Mb, 3,114 Mb, and 3,135 Mb, respectively, suggesting that postprocessing more likely played the major role in the observed discrepancies. We should note that when calculating the total alignment size and the number of covered bases on the genome, we considered only the start and end positions of each alignment. As a result, gaps within alignments were included in the totals, which may affect the results - particularly for minimap2 and wfmash, which employ more aggressive chaining strategies and tend to include larger gaps.</p><p id="P92">Given the challenges of directly comparing alignment results, we used the number of genome bases covered by alignments as an indirect but meaningful metric for further assessing aligner performance (<xref ref-type="fig" rid="F8">Figure 8c</xref>, <xref ref-type="supplementary-material" rid="SD1">Supplementary Table S2</xref>). The sensitivity of the aligners on these genomes generally aligned with what had been observed in the simulated data: FastGA and minimap2 performed similarly, both being more sensitive than NUCmer but less sensitive than LastZ. For human and chimpanzee, the genome coverages were very similar across all aligners. For siamang, FastGA, LastZ, and NUCmer produced comparable results, while minimap2 and wfmash covered 500 Mb and 300 Mb extra sequences, respectively, perhaps due to their output alignments spanning siamang-specific insertions. For the two more distantly related species, pig and mouse, differences became more pronounced, with LastZ clearly more sensitive than minimap2, FastGA and NUCmer.</p><p id="P93">Wfmash reports higher coverage than LastZ for pig and mouse, but this appear to be because of spurious false-positive matching, rather than real increased sensitivity. We can see this by considering a series of experiments in which we took a 44 Mb stretch of CHM13 chr16 (52.3-96.3 Mb) that has extended weak syntenic similarity to mouse chr8 (88.9-127.3 Mb). When directly comparing these segments, FastGA, minimap2 and NUCmer respectively mapped 3.3 Mb, 2.91 Mb and 1.1 Mb of human, while LastZ mapped 14.30 Mb and wfmash 28.4 Mb. However, when we scrambled the regions in mouse in between the FastGA matches, while LastZ dropped its coverage to only the meaningfully alignable regions with some small extensions (3.69 Mb), wfmash continued to align 22 Mb, bridging between correctly aligned regions with over 18Mb of spurious coverage. When we reverse-complemented the intervening regions LastZ recovered to 11.42 Mb, indicating that it was able to align a substantial fraction of the material in these intervals independent of consistent orientation with the more conserved flanks whereas wfmash still aligned 20.85 Mb. In order to take advantage of the extra sensitivity of LastZ while maintaining the speed of FastGA, we explored a hybrid approach. The core idea is to use FastGA alignments as anchors and apply LastZ to fill the gaps between them. Specifically, for each pair of consistently ordered and oriented, non-overlapping FastGA alignments separated by no more than a predefined threshold (default 1 Mb), we define a bounding box using the end and start positions of the flanking alignments on the two genomes. A small overlap (default 1 kb) is allowed between the bounding box and the original alignments to facilitate seeding for LastZ. After generating these bounding boxes, we retain only the minimal ones such that no smaller ones are contained within them. LastZ is then run to align the sequence pairs corresponding to each bounding box. Finally, the alignments from FastGA and LastZ are combined to produce the final result. We present the results of this hybrid approach as ‘FastGA-gapfill’ in <xref ref-type="fig" rid="F8">Figure 8</xref> and <xref ref-type="supplementary-material" rid="SD1">Supplementary Table S2</xref>. As can be seen, while the sensitivity of FastGA-gapfill was comparable to LastZ, the speed was improved by a factor of 19.3 × to 137.5 ×. Although the speed gains over minimap2 and wfmash were not so strong, it remained the fastest overall, while being more sensitive than these methods.</p></sec><sec id="S21"><label>5.3</label><title>Other Species</title><p id="P94">We selected twelve species sequenced by DToL ([<xref ref-type="bibr" rid="R5">5</xref>]) representing a wide taxonomic range, with varying genome sizes from a few hundred megabases to over 24 Gb. These include two insects from the genus <italic>Acronicta</italic> (<italic>A. psi</italic> and <italic>A. aceris</italic>, moths), two fishes from the genus <italic>Thunnus</italic> (<italic>T. albacares</italic> and <italic>T. maccoyii</italic>, tunas), two birds from the genus <italic>Ammospiza</italic> (<italic>A. caudacuta</italic> and <italic>A. maritima</italic>, sparrows), two reptiles from the genus <italic>vipera</italic> (<italic>V. latastei</italic> and <italic>V. berus</italic>, snakes), two mammals from the genus <italic>molossus</italic> (<italic>M. alvarezi</italic> and <italic>M. nigricans</italic>, bats), and two amphibians from the genus <italic>Lissotriton</italic> (<italic>L. vulgaris</italic> and <italic>L. helveticus</italic>, newts). For species from each genus, we performed two types of analyses: (1) within-species haplotype comparison, where we aligned the primary and alternative assemblies of the first species, and (2) between-species haplotype comparison, where we aligned the primary assemblies of the two different species. Further details of these genomes are provided in <xref ref-type="supplementary-material" rid="SD1">Supplementary Table S3</xref>.</p><p id="P95">The alignment results of FastGA are summarised in <xref ref-type="table" rid="T1">Table 1</xref>, with additional details and results from other genome aligners provided in <xref ref-type="supplementary-material" rid="SD1">Supplementary Table S4</xref>. FastGA completed comparisons for most of these genomes within one to two hours, using less than 12 GB memory, and consistently outperformed all other aligners in speed. For the alignment between <italic>V. latastei</italic> and <italic>V. berus</italic>, minimap2 failed under default settings and was rerun with the ‘-x asm20’ option, which is less sensitive; four LastZ jobs did not complete within the 48-hour wall-time limit, corresponding to pairwise alignments between two largest chromosomes of the genomes. FastGA was the only aligner that successfully produced alignments for the newt genomes. It took 4,611 CPU minutes (5.5 hours wall time) for the comparison between two <italic>L. vulgaris</italic> haplotypes, and 2,539 CPU minutes (3.2 hours wall time) for the comparison between <italic>L. vulgaris</italic> and <italic>L. helveticus</italic>, with both runs using approximately 29 GB of memory. We note that this memory requirement arose during the sorting steps to generate the genome index (GIX) files; the actual alignment process by FastGA required only around 1GB memory. Coverage fractions for all methods were comparable, except for in the comparison between the moth species, which are more distantly related, for which results were comparable to those for human to mouse.</p></sec></sec><sec sec-type="supplementary-material" id="SM"><title>Supplementary Material</title><supplementary-material content-type="local-data" id="SD1"><label>Supplementary Materials</label><media xlink:href="EMS206991-supplement-Supplementary_Materials.pdf" mimetype="application" mime-subtype="pdf" id="d5aAcFbB" position="anchor"/></supplementary-material></sec></body><back><ack id="S22"><title>Acknowledgements</title><p>This work was supported by the Wellcome Trust [207492 and 226458 to R.D.].</p></ack><fn-group><fn id="FN3"><label>1</label><p id="P96">A MacBook Pro running macOS 10.15.7 with a 16-core M4 Max chip and 64GB of memory</p></fn><fn id="FN4"><label>2</label><p id="P97">Let the affine gap cost function be <italic>u</italic>+<italic>g</italic> where <italic>g</italic> is the gap length, <italic>u</italic> ≤ 1<italic>/n</italic> is a very small gap initiation charge, and <italic>n</italic> is the length of the sequences being compared. Then the score of an optimal unit-cost alignment would be <italic>d</italic> + <italic>Gu</italic> ≤ <italic>d</italic> + <italic>G/n &lt; d</italic> + 1 where <italic>G &lt; n</italic> is the number of gaps in the alignment. Therefore the best alignment under this model is an optimal unit cost alignment with the smallest number of gaps. This observation was first made by Bansho Masutani.</p></fn></fn-group><ref-list><ref id="R1"><label>[1]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Myers</surname><given-names>G</given-names></name></person-group><article-title>Efficient Local Alignment Discovery amongst Noisy Long Reads</article-title><source>Proc of Algorithms in Bioinformatics WABI 2014 (Wroclaw, Poland)</source><series>Lecture Notes in Computer Science (Springer)</series><year>2014</year><volume>8701</volume><fpage>52</fpage><lpage>67</lpage></element-citation></ref><ref id="R2"><label>[2]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H</given-names></name><name><surname>Handsaker</surname><given-names>B</given-names></name><name><surname>Wysoker</surname><given-names>A</given-names></name><name><surname>Fennell</surname><given-names>T</given-names></name><name><surname>Ruan</surname><given-names>J</given-names></name><name><surname>Marth</surname><given-names>N</given-names></name><name><surname>Abecasis</surname><given-names>G</given-names></name><name><surname>Durbin</surname><given-names>R</given-names></name><collab>1000 Genome Project Data Processing Subgroup</collab></person-group><article-title>The Sequence Alignment/Map Format and SAMtools</article-title><source>Bioinformatics</source><year>2009</year><volume>25</volume><issue>16</issue><fpage>2078</fpage><lpage>2079</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btp352</pub-id><pub-id pub-id-type="pmcid">PMC2723002</pub-id><pub-id pub-id-type="pmid">19505943</pub-id></element-citation></ref><ref id="R3"><label>[3]</label><element-citation publication-type="web"><person-group person-group-type="author"><name><surname>Myers</surname><given-names>E</given-names></name><name><surname>Durbin</surname><given-names>R</given-names></name></person-group><comment><ext-link ext-link-type="uri" xlink:href="https://www.github.com/thegenemyers/ONEcode">https://www.github.com/thegenemyers/ONEcode</ext-link></comment></element-citation></ref><ref id="R4"><label>[4]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rhie</surname><given-names>A</given-names></name><name><surname>McCarthy</surname><given-names>SA</given-names></name><name><surname>Fedrigo</surname><given-names>O</given-names></name><name><surname>Formenti</surname><given-names>G</given-names></name><name><surname>da Silva</surname><given-names>MU</given-names></name><etal/><name><surname>Lewin</surname><given-names>HA</given-names></name><name><surname>Howe</surname><given-names>K</given-names></name><name><surname>Myers</surname><given-names>EW</given-names></name><name><surname>Durbin</surname><given-names>R</given-names></name><name><surname>Phillippy</surname><given-names>AM</given-names></name><name><surname>Jarvis</surname><given-names>ED</given-names></name><collab>119 more co-authors</collab></person-group><article-title>Towards Complete and Error-Free Genome Assemblies of All Vertebrate Species</article-title><source>Nature</source><year>2021</year><volume>592</volume><fpage>737</fpage><lpage>746</lpage><pub-id pub-id-type="doi">10.1038/s41586-021-03451-0</pub-id><pub-id pub-id-type="pmcid">PMC8081667</pub-id><pub-id pub-id-type="pmid">33911273</pub-id></element-citation></ref><ref id="R5"><label>[5]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Blaxter</surname><given-names>M</given-names></name><name><surname>Mieszkowska</surname><given-names>N</given-names></name><name><surname>De Palma</surname><given-names>F</given-names></name><name><surname>Holland</surname><given-names>D</given-names></name><name><surname>Durbin</surname><given-names>RD</given-names></name><etal/><name><surname>Barnes</surname><given-names>I</given-names></name></person-group><article-title>Sequence Locally, Think Globally: The Darwin Tree of Life Project</article-title><source>PNAS</source><year>2022</year><volume>119</volume><fpage>4</fpage><pub-id pub-id-type="doi">10.1073/pnas.2115642118</pub-id><pub-id pub-id-type="pmcid">PMC8797607</pub-id><pub-id pub-id-type="pmid">35042805</pub-id></element-citation></ref><ref id="R6"><label>[6]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lewin</surname><given-names>HA</given-names></name><name><surname>Richards</surname><given-names>S</given-names></name><name><surname>Aiden</surname><given-names>EL</given-names></name><etal/><name><surname>Zhang</surname><given-names>G</given-names></name></person-group><article-title>The Earth BioGenome Project 2020: Starting the clock</article-title><source>PNAS</source><year>2022</year><volume>119</volume><fpage>4</fpage><pub-id pub-id-type="doi">10.1073/pnas.2115635118</pub-id><pub-id pub-id-type="pmcid">PMC8795548</pub-id><pub-id pub-id-type="pmid">35042800</pub-id></element-citation></ref><ref id="R7"><label>[7]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H</given-names></name><name><surname>Durbin</surname><given-names>R</given-names></name></person-group><article-title>Genome assembly in the telomere-to-telomere era</article-title><source>Nat Rev Genet</source><year>2024</year><volume>25</volume><fpage>658</fpage><lpage>670</lpage><pub-id pub-id-type="pmid">38649458</pub-id></element-citation></ref><ref id="R8"><label>[8]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lawniczak</surname><given-names>MKN</given-names></name><name><surname>Durbin</surname><given-names>R</given-names></name><name><surname>Flicek</surname><given-names>P</given-names></name><etal/><name><surname>Zhang</surname><given-names>G</given-names></name><name><surname>Lewin</surname><given-names>HA</given-names></name><name><surname>Richards</surname><given-names>S</given-names></name></person-group><article-title>Standards Recommendations for the Earth BioGenome Project</article-title><source>PNAS</source><year>2022</year><volume>119</volume><fpage>4</fpage><pub-id pub-id-type="doi">10.1073/pnas.2115639118</pub-id><pub-id pub-id-type="pmcid">PMC8795494</pub-id><pub-id pub-id-type="pmid">35042802</pub-id></element-citation></ref><ref id="R9"><label>[9]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Teeling</surname><given-names>E</given-names></name><name><surname>Vernes</surname><given-names>S</given-names></name><name><surname>Davalos</surname><given-names>LM</given-names></name><name><surname>Ray</surname><given-names>DA</given-names></name><name><surname>Gilbert</surname><given-names>MTP</given-names></name><name><surname>Myers</surname><given-names>E</given-names></name></person-group><article-title>Bat Biology, Genomes, and the Bat1K Project: To Generate Chromosome-Level Genomes for All Living Bat Species</article-title><source>Annual Review of Animal Biosciences</source><year>2017</year><pub-id pub-id-type="pmid">29166127</pub-id></element-citation></ref><ref id="R10"><label>[10]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Altschul</surname><given-names>SF</given-names></name><name><surname>Gish</surname><given-names>W</given-names></name><name><surname>Miller</surname><given-names>W</given-names></name><name><surname>Myers</surname><given-names>EW</given-names></name><name><surname>Lipman</surname><given-names>DJ</given-names></name></person-group><article-title>Basic local alignment search tool</article-title><source>Journal of Molecular Biology J of Molecular Biology</source><year>1990</year><volume>215</volume><fpage>403</fpage><lpage>410</lpage><pub-id pub-id-type="pmid">2231712</pub-id></element-citation></ref><ref id="R11"><label>[11]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Paten</surname><given-names>B</given-names></name><name><surname>Earl</surname><given-names>D</given-names></name><name><surname>Nguyen</surname><given-names>N</given-names></name><name><surname>Diekhans</surname><given-names>M</given-names></name><name><surname>Zerbino</surname><given-names>D</given-names></name><name><surname>Haussler</surname><given-names>D</given-names></name></person-group><article-title>Cactus: Algorithms for genome multiple sequence alignment</article-title><source>Genome Research</source><year>2011</year><volume>21</volume><issue>9</issue><fpage>1512</fpage><lpage>28</lpage><pub-id pub-id-type="doi">10.1101/gr.123356.111</pub-id><pub-id pub-id-type="pmcid">PMC3166836</pub-id><pub-id pub-id-type="pmid">21665927</pub-id></element-citation></ref><ref id="R12"><label>[12]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Armstrong</surname><given-names>J</given-names></name><name><surname>Hickey</surname><given-names>G</given-names></name><name><surname>Diekhans</surname><given-names>M</given-names></name><etal/><name><surname>Zhang</surname><given-names>G</given-names></name><name><surname>Paten</surname><given-names>B</given-names></name></person-group><article-title>Progressive Cactus is a multiple-genome aligner for the thousand-genome era</article-title><source>Nature</source><year>2020</year><volume>587</volume><fpage>246</fpage><lpage>251</lpage><pub-id pub-id-type="doi">10.1038/s41586-020-2871-y</pub-id><pub-id pub-id-type="pmcid">PMC7673649</pub-id><pub-id pub-id-type="pmid">33177663</pub-id></element-citation></ref><ref id="R13"><label>[13]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sierra</surname><given-names>P</given-names></name><name><surname>Durbin</surname><given-names>R</given-names></name></person-group><article-title>Identification of transposable element families from pangenome polymorphisms</article-title><source>Mob DNA</source><year>2024</year><volume>15</volume><fpage>13</fpage><pub-id pub-id-type="doi">10.1186/s13100-024-00323-y</pub-id><pub-id pub-id-type="pmcid">PMC11202377</pub-id><pub-id pub-id-type="pmid">38926873</pub-id></element-citation></ref><ref id="R14"><label>[14]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schwartz</surname><given-names>S</given-names></name><name><surname>Zheng</surname><given-names>Z</given-names></name><name><surname>Frazer</surname><given-names>KA</given-names></name><name><surname>Smit</surname><given-names>A</given-names></name><name><surname>Riemer</surname><given-names>C</given-names></name><name><surname>Bouck</surname><given-names>J</given-names></name><name><surname>Gibbs</surname><given-names>R</given-names></name><name><surname>Hardison</surname><given-names>RC</given-names></name><name><surname>Miller</surname><given-names>W</given-names></name></person-group><article-title>PipMaker - A Web Server for Aligning Two Genomic DNA Sequences</article-title><source>Genome Research</source><year>2000</year><volume>10</volume><fpage>577</fpage><lpage>586</lpage><pub-id pub-id-type="doi">10.1101/gr.10.4.577</pub-id><pub-id pub-id-type="pmcid">PMC310868</pub-id><pub-id pub-id-type="pmid">10779500</pub-id></element-citation></ref><ref id="R15"><label>[15]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schwartz</surname><given-names>S</given-names></name><name><surname>Kent</surname><given-names>JW</given-names></name><name><surname>Smit</surname><given-names>A</given-names></name><name><surname>Zheng</surname><given-names>Z</given-names></name><name><surname>Baertsch</surname><given-names>R</given-names></name><name><surname>Hardison</surname><given-names>RC</given-names></name><name><surname>Haussler</surname><given-names>D</given-names></name><name><surname>Miller</surname><given-names>W</given-names></name></person-group><article-title>Human-Mouse Alignments with BLASTZ</article-title><source>Genome Research</source><year>2003</year><volume>13</volume><fpage>103</fpage><lpage>107</lpage><pub-id pub-id-type="doi">10.1101/gr.809403</pub-id><pub-id pub-id-type="pmcid">PMC430961</pub-id><pub-id pub-id-type="pmid">12529312</pub-id></element-citation></ref><ref id="R16"><label>[16]</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Harris</surname><given-names>RS</given-names></name></person-group><source>Improved pairwise alignment of genomic DNA</source><publisher-name>Ph.D. Thesis The Pennsylvania State University</publisher-name><year>2007</year></element-citation></ref><ref id="R17"><label>[17]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ma</surname><given-names>B</given-names></name><name><surname>Tromp</surname><given-names>J</given-names></name><name><surname>Li</surname><given-names>M</given-names></name></person-group><article-title>PatternHunter: faster and more sensitive homology search</article-title><source>Bioinformatics</source><year>2002</year><volume>18</volume><fpage>440</fpage><lpage>445</lpage><pub-id pub-id-type="pmid">11934743</pub-id></element-citation></ref><ref id="R18"><label>[18]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Marcals</surname><given-names>G</given-names></name><name><surname>Delcher</surname><given-names>AL</given-names></name><name><surname>Phillipy</surname><given-names>AM</given-names></name><name><surname>Coston</surname><given-names>R</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name><name><surname>Aleksey</surname><given-names>Z</given-names></name></person-group><article-title>MUMmer4: A fast and versatile genome alignment system</article-title><source>PLoS Computational Biology</source><year>2018</year><volume>14</volume><issue>1</issue><elocation-id>e1005944</elocation-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1005944</pub-id><pub-id pub-id-type="pmcid">PMC5802927</pub-id><pub-id pub-id-type="pmid">29373581</pub-id></element-citation></ref><ref id="R19"><label>[19]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Heng</surname><given-names>L</given-names></name></person-group><article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title><source>Bioinformatics</source><year>2018</year><volume>34</volume><issue>18</issue><fpage>3094</fpage><lpage>3100</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/bty191</pub-id><pub-id pub-id-type="pmcid">PMC6137996</pub-id><pub-id pub-id-type="pmid">29750242</pub-id></element-citation></ref><ref id="R20"><label>[20]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Heng</surname><given-names>L</given-names></name></person-group><article-title>New strategies to improve minimap2 alignment accuracy</article-title><source>Bioinformatics</source><year>2018</year><volume>37</volume><issue>23</issue><fpage>4572</fpage><lpage>4574</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btab705</pub-id><pub-id pub-id-type="pmcid">PMC8652018</pub-id><pub-id pub-id-type="pmid">34623391</pub-id></element-citation></ref><ref id="R21"><label>[21]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Roberts</surname><given-names>M</given-names></name><name><surname>Hayes</surname><given-names>W</given-names></name><name><surname>Hunt</surname><given-names>BR</given-names></name><name><surname>Mount</surname><given-names>SM</given-names></name><name><surname>Yorke</surname><given-names>JA</given-names></name></person-group><article-title>Reducing storage requirements for biological sequence comparison</article-title><source>Bioinformatics</source><year>2004</year><volume>20</volume><issue>18</issue><fpage>3363</fpage><lpage>3369</lpage><pub-id pub-id-type="pmid">15256412</pub-id></element-citation></ref><ref id="R22"><label>[22]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Garrison</surname><given-names>E</given-names></name><name><surname>Guarracino</surname><given-names>A</given-names></name></person-group><article-title>Unbiased Pangenome Graphs</article-title><source>Bioinformatics</source><year>2022</year><volume>39</volume><issue>1</issue><fpage>1</fpage><lpage>7</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btac743</pub-id><pub-id pub-id-type="pmcid">PMC9805579</pub-id><pub-id pub-id-type="pmid">36448683</pub-id></element-citation></ref><ref id="R23"><label>[23]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jain</surname><given-names>C</given-names></name><name><surname>Koren</surname><given-names>S</given-names></name><name><surname>Dilthey</surname><given-names>A</given-names></name><name><surname>Phillippy</surname><given-names>AM</given-names></name><name><surname>Aluru</surname><given-names>S</given-names></name></person-group><article-title>A Fast Adaptive Algorithm for Computing Whole-Genome Homology Maps</article-title><source>Bioinformatics</source><year>2018</year><volume>34</volume><issue>ECCB 2018</issue><fpage>i748</fpage><lpage>i756</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/bty597</pub-id><pub-id pub-id-type="pmcid">PMC6129286</pub-id><pub-id pub-id-type="pmid">30423094</pub-id></element-citation></ref><ref id="R24"><label>[24]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Marco-Sola</surname><given-names>S</given-names></name><name><surname>Moure</surname><given-names>JC</given-names></name><name><surname>Moreto</surname><given-names>M</given-names></name><name><surname>Espinosa</surname><given-names>A</given-names></name></person-group><article-title>Fast gap-affine pairwise alignment using the wavefront algorithm</article-title><source>Bioinformatics</source><year>2020</year><volume>37</volume><issue>4</issue><fpage>456</fpage><lpage>463</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btaa777</pub-id><pub-id pub-id-type="pmcid">PMC8355039</pub-id><pub-id pub-id-type="pmid">32915952</pub-id></element-citation></ref><ref id="R25"><label>[25]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Edgar</surname><given-names>R</given-names></name></person-group><article-title>Syncmers Are More Sensitive than Minimizers for Selecting Conserved k-mers in Biological Sequences</article-title><source>PeerJ</source><year>2021</year><volume>9</volume><elocation-id>e10805</elocation-id><pub-id pub-id-type="doi">10.7717/peerj.10805</pub-id><pub-id pub-id-type="pmcid">PMC7869670</pub-id><pub-id pub-id-type="pmid">33604186</pub-id></element-citation></ref><ref id="R26"><label>[26]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kielbasa</surname><given-names>SM</given-names></name><name><surname>Wan</surname><given-names>R</given-names></name><name><surname>Sato</surname><given-names>K</given-names></name><name><surname>Horton</surname><given-names>P</given-names></name><name><surname>Frith</surname><given-names>MC</given-names></name></person-group><article-title>Adaptive Seeds Tame Genomic Sequence Comparison</article-title><source>Genome Research</source><year>2011</year><volume>21</volume><fpage>487</fpage><lpage>493</lpage><pub-id pub-id-type="doi">10.1101/gr.113985.110</pub-id><pub-id pub-id-type="pmcid">PMC3044862</pub-id><pub-id pub-id-type="pmid">21209072</pub-id></element-citation></ref><ref id="R27"><label>[27]</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Kokot</surname><given-names>M</given-names></name><name><surname>Deorowicz</surname><given-names>S</given-names></name><name><surname>Debudaj-Grabsyz</surname><given-names>A</given-names></name></person-group><article-title>Sorting Data on Ultra-Large Scale with RADULS</article-title><source>Proc of Beyond Databases, Architecture and Structures</source><conf-name>Springer</conf-name><year>2017</year><volume>716</volume><fpage>235</fpage><lpage>245</lpage></element-citation></ref><ref id="R28"><label>[28]</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Satish</surname><given-names>N</given-names></name><name><surname>Kim</surname><given-names>C</given-names></name><name><surname>Chugani</surname><given-names>J</given-names></name><name><surname>Nguyen</surname><given-names>AD</given-names></name><name><surname>Lee</surname><given-names>VW</given-names></name><name><surname>Kim</surname><given-names>D</given-names></name><name><surname>Dubey</surname><given-names>P</given-names></name></person-group><source>Fast Sort on CPUs and GPUs: A Case for Bandwidth Oblivious SIMD Sort</source><conf-name>Proc of ACM SIGMOD Conf on Management of Data</conf-name><year>2010</year><fpage>351</fpage><lpage>362</lpage></element-citation></ref><ref id="R29"><label>[29]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cho</surname><given-names>M</given-names></name><name><surname>Brand</surname><given-names>D</given-names></name><name><surname>Bordawekar</surname><given-names>R</given-names></name><name><surname>Finkler</surname><given-names>U</given-names></name><name><surname>Kulandaisamy</surname><given-names>V</given-names></name><name><surname>Puri</surname><given-names>R</given-names></name></person-group><article-title>Paradis: an efficient parallel algorithm for in-place radix sort</article-title><source>Proc of the VLDB Endowment</source><year>2015</year><volume>8</volume><issue>12</issue><fpage>1518</fpage><lpage>1529</lpage></element-citation></ref><ref id="R30"><label>[30]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Abouelhoda</surname><given-names>MI</given-names></name><name><surname>Kurtz</surname><given-names>S</given-names></name><name><surname>Ohlebusch</surname><given-names>E</given-names></name></person-group><article-title>Replacing Suffix Trees with Enhanced Suffix Arrays</article-title><source>J of Discrete Algorithms</source><year>2004</year><volume>2</volume><fpage>53</fpage><lpage>86</lpage></element-citation></ref><ref id="R31"><label>[31]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Myers</surname><given-names>EW</given-names></name></person-group><article-title>An O(ND) difference algorithm and its variations</article-title><source>Algorithmica</source><year>1986</year><volume>1</volume><fpage>251</fpage><lpage>266</lpage></element-citation></ref><ref id="R32"><label>[32]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ukkonen</surname><given-names>E</given-names></name></person-group><article-title>Algorithms for Approximate String Matching</article-title><source>Information and Control</source><year>1985</year><volume>64</volume><fpage>100</fpage><lpage>118</lpage></element-citation></ref><ref id="R33"><label>[33]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wu</surname><given-names>S</given-names></name><name><surname>Myers</surname><given-names>E</given-names></name><name><surname>Manber</surname><given-names>U</given-names></name><name><surname>Miller</surname><given-names>W</given-names></name></person-group><article-title>An O(NP) Sequence Comparison Algorithm</article-title><source>Information Processing Letters</source><year>1990</year><volume>35</volume><issue>6</issue><fpage>317</fpage><lpage>323</lpage></element-citation></ref><ref id="R34"><label>[34]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hadlock</surname><given-names>F</given-names></name></person-group><article-title>Minimum Detour Methods for String or Sequence Comparison</article-title><source>Congressus Numerantium</source><year>1988</year><volume>61</volume><fpage>263</fpage><lpage>274</lpage></element-citation></ref><ref id="R35"><label>[35]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Martiniano</surname><given-names>R</given-names></name><name><surname>De Sanctis Hallast</surname><given-names>P</given-names></name><name><surname>Durbin</surname><given-names>R</given-names></name></person-group><article-title>Placing Ancient DNA Sequences into Reference Phylogenies</article-title><source>Mol Biol Evol</source><year>2022</year><volume>39</volume><elocation-id>msac017</elocation-id><pub-id pub-id-type="doi">10.1093/molbev/msac017</pub-id><pub-id pub-id-type="pmcid">PMC8857924</pub-id><pub-id pub-id-type="pmid">35084493</pub-id></element-citation></ref><ref id="R36"><label>[36]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nurk</surname><given-names>S</given-names></name><name><surname>Koren</surname><given-names>S</given-names></name><name><surname>Rhie</surname><given-names>A</given-names></name><name><surname>Rautiainen</surname><given-names>M</given-names></name><name><surname>Bzikadze</surname><given-names>AV</given-names></name><name><surname>Mikheenko</surname><given-names>A</given-names></name><name><surname>Vollger</surname><given-names>MR</given-names></name><name><surname>Altemose</surname><given-names>N</given-names></name><name><surname>Uralsky</surname><given-names>L</given-names></name><name><surname>Gershman</surname><given-names>A</given-names></name><name><surname>Aganezov</surname><given-names>S</given-names></name></person-group><article-title>The complete sequence of a human genome</article-title><source>Science</source><year>2022</year><volume>376</volume><issue>6588</issue><fpage>44</fpage><lpage>53</lpage><pub-id pub-id-type="doi">10.1126/science.abj6987</pub-id><pub-id pub-id-type="pmcid">PMC9186530</pub-id><pub-id pub-id-type="pmid">35357919</pub-id></element-citation></ref><ref id="R37"><label>[37]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schneider</surname><given-names>VA</given-names></name><name><surname>Graves-Lindsay</surname><given-names>T</given-names></name><name><surname>Howe</surname><given-names>K</given-names></name><name><surname>Bouk</surname><given-names>N</given-names></name><name><surname>Chen</surname><given-names>HC</given-names></name><name><surname>Kitts</surname><given-names>PA</given-names></name><name><surname>Murphy</surname><given-names>TD</given-names></name><name><surname>Pruitt</surname><given-names>KD</given-names></name><name><surname>Thibaud-Nissen</surname><given-names>F</given-names></name><name><surname>Albracht</surname><given-names>D</given-names></name><name><surname>Fulton</surname><given-names>RS</given-names></name></person-group><article-title>Evaluation of GRCh38 and de novo haploid genome assemblies demonstrates the enduring quality of the reference assembly</article-title><source>Genome Research</source><year>2017</year><volume>27</volume><issue>5</issue><fpage>849</fpage><lpage>864</lpage><pub-id pub-id-type="doi">10.1101/gr.213611.116</pub-id><pub-id pub-id-type="pmcid">PMC5411779</pub-id><pub-id pub-id-type="pmid">28396521</pub-id></element-citation></ref><ref id="R38"><label>[38]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Yoo</surname><given-names>D</given-names></name><name><surname>Rhie</surname><given-names>A</given-names></name><name><surname>Hebbar</surname><given-names>P</given-names></name><name><surname>Antonacci</surname><given-names>F</given-names></name><name><surname>Logsdon</surname><given-names>GA</given-names></name><name><surname>Solar</surname><given-names>SJ</given-names></name><name><surname>Antipov</surname><given-names>D</given-names></name><name><surname>Pickett</surname><given-names>BD</given-names></name><name><surname>Safonova</surname><given-names>Y</given-names></name><name><surname>Montinaro</surname><given-names>F</given-names></name><name><surname>Luo</surname><given-names>Y</given-names></name></person-group><article-title>Complete sequencing of ape genomes</article-title><source>Nature</source><year>2025</year><fpage>1</fpage><lpage>18</lpage><pub-id pub-id-type="doi">10.1038/s41586-025-08816-3</pub-id><pub-id pub-id-type="pmcid">PMC12058530</pub-id><pub-id pub-id-type="pmid">40205052</pub-id></element-citation></ref><ref id="R39"><label>[39]</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cao</surname><given-names>C</given-names></name><name><surname>Miao</surname><given-names>J</given-names></name><name><surname>Xie</surname><given-names>Q</given-names></name><name><surname>Sun</surname><given-names>J</given-names></name><name><surname>Cheng</surname><given-names>H</given-names></name><name><surname>Zhang</surname><given-names>Z</given-names></name><name><surname>Wu</surname><given-names>F</given-names></name><name><surname>Liu</surname><given-names>S</given-names></name><name><surname>Ye</surname><given-names>X</given-names></name><name><surname>Gong</surname><given-names>H</given-names></name><name><surname>Zhang</surname><given-names>Z</given-names></name></person-group><article-title>A near telomere-to-telomere genome assembly of the Jinhua pig: enabling more accurate genetic research</article-title><source>GigaScience</source><year>2025</year><volume>14</volume><elocation-id>giaf048</elocation-id><pub-id pub-id-type="doi">10.1093/gigascience/giaf048</pub-id><pub-id pub-id-type="pmcid">PMC12080228</pub-id><pub-id pub-id-type="pmid">40372724</pub-id></element-citation></ref></ref-list></back><floats-group><fig id="F1" position="float"><label>Figure 1</label><caption><p>A sketch of the relationship of the variables <italic>fst, cur, lst, L</italic>, and <italic>wall</italic>. Assuming <italic>α</italic> is the current <italic>K</italic>-mer in the first index, then in the second index ℋ[<italic>j</italic>].<italic>kmer</italic>[0, <italic>L</italic>] = <italic>α</italic>[0, <italic>L</italic>] for all <italic>j</italic> ∈ [<italic>fst, lst</italic>). All the shaded areas have identical characters. The <italic>lcp</italic> of ℋ[<italic>lst</italic>].<italic>kmer</italic> with <italic>α</italic> is always strictly less than <italic>L. cur</italic> ∈ [<italic>fst, lst</italic>] points at the first element whose value is not less than <italic>α</italic> and can only equal <italic>α</italic> when <italic>L</italic> = <italic>K, fst</italic> = <italic>cur</italic>, and <italic>lst</italic> = <italic>cur</italic> + 1. If <italic>L &lt; K</italic> then the <italic>L</italic> + 1<sup><italic>st</italic></sup> symbols in the adaptamer interval are strictly increasing, i.e., <italic>u</italic><sub>1</sub> ≤ <italic>u</italic><sub>2</sub> ≤ … ≤ <italic>u</italic><sub><italic>n</italic></sub> and if <italic>cur &lt; lst</italic> then <italic>α</italic>[<italic>L</italic> + 1] <italic>&lt;</italic> ℋ[<italic>cur</italic>].<italic>kmer</italic>[<italic>L</italic> + 1] and if <italic>cur &gt; fst</italic> then ℋ[<italic>cur</italic> − 1].<italic>kmer</italic>[<italic>L</italic> + 1] <italic>&lt; α</italic>[<italic>L</italic> + 1]. The <italic>wall</italic> values for <italic>l &lt; L</italic> give the smallest index for which the <italic>K</italic>-mer has an <italic>lcp</italic> of <italic>l</italic> with <italic>α</italic>. |<italic>wall</italic>[<italic>l</italic>] − <italic>wall</italic>[<italic>l</italic> − 1]| can be zero.</p></caption><graphic xlink:href="EMS206991-f001"/></fig><fig id="F2" position="float"><label>Figure 2</label><caption><p>An algorithm for finding all the non-repetitive adaptamers of genome G in genome H given their indices 𝒢 and ℋ.</p></caption><graphic xlink:href="EMS206991-f002"/></fig><fig id="F3" position="float"><label>Figure 3</label><caption><p>In the figure at left, <italic>A</italic> is divided evenly into panels of size <italic>δ</italic> save the last. For the alignment of <italic>A</italic>[<italic>ab, ae</italic>] with <italic>B</italic>[<italic>bb, be</italic>], the length of the portion of <italic>B</italic> aligned with each segment of <italic>A</italic> as partitioned by the <italic>δ</italic>-panels is the trace point array. Given this array, the 4 end points, and <italic>δ</italic> on can then determine each starred <italic>trace-point</italic> in the edit graph of <italic>A</italic> versus <italic>B</italic> which are vertices that the encoded alignment pass through. Given these points, delivering the path is simply a matter of solving each of <italic>o</italic>(<italic>n/δ</italic>), <italic>δ</italic>×<italic>δ</italic> sub-arrays shown in dark grey between the trace points.</p></caption><graphic xlink:href="EMS206991-f003"/></fig><fig id="F4" position="float"><label>Figure 4</label><caption><p>An example of gap refinement. At left, (a), an alignment produced under the unit-cost model. At right, (b) an alignment with the same unit cost but only one gap. In (c) we give the <italic>trace</italic> for the alignment (a), see the text for the explanation.</p></caption><graphic xlink:href="EMS206991-f004"/></fig><fig id="F5" position="float"><label>Figure 5</label><caption><p>The trapezoidal region to be re-examined for the example of <xref ref-type="fig" rid="F4">Figure 4</xref> with the paths corresponding to alignments (a) and (b) drawn in black.</p></caption><graphic xlink:href="EMS206991-f005"/></fig><fig id="F6" position="float"><label>Figure 6</label><caption><p>The data work flow for FastGA and associated utilities. Each box contains a data object and the arrows are labeled with program names that transform or produce them. Sample data sizes and parameters are placed to the side of each box and runtimes are placed in parenthesis along the program arrows. Utilities for viewing and or manipulating a data object are listed at the right with a pair of eyes next to those that provide views.</p></caption><graphic xlink:href="EMS206991-f006"/></fig><fig id="F7" position="float"><label>Figure 7</label><caption><p>Sensitivity of genome aligners on simulated genomes. Subplots (a)-(f) correspond to target region lengths of 100 bp, 200 bp, 500 bp, 1000 bp, 2000 bp, and 5000 bp, respectively. The <italic>x</italic>-axis indicates the percentage of sequence divergence between the simulated genome pairs 𝒜 and ℬ, while the <italic>y</italic>-axis shows the number of target regions (out of 100) that were fully recovered by each genome aligner.</p></caption><graphic xlink:href="EMS206991-f007"/></fig><fig id="F8" position="float"><label>Figure 8</label><caption><p>Alignment results of mammalian genomes to the CHM13 reference. Subplots (a)–(c) present the runtime, peak memory usage, and genome coverage, respectively.</p></caption><graphic xlink:href="EMS206991-f008"/></fig><table-wrap id="T1" orientation="portrait" position="float"><label>Table 1</label><caption><p>FastGA alignment results for within-species and between-species haplotype comparisons. Numbers in parentheses following the species name indicate the specific haplotypes used. The ‘CPU time’ and ‘Memory’ columns show the computational resources consumed by FastGA, while the ‘Cov A’ and ‘Cov B’ columns report the percentage of genomes A and B covered by the alignments.</p></caption><table frame="box" rules="groups"><thead><tr><th valign="middle" align="left" style="border-top:solid 1px #000000;border-left:solid 1px #000000">Class</th><th valign="middle" align="left" style="border-top:solid 1px #000000;border-left:solid 1px #000000">Genus</th><th valign="middle" align="left" style="border-top:solid 1px #000000;border-left:solid 1px #000000">Genome A</th><th valign="middle" align="left" style="border-top: 1px solid #000000;border-left: 1px solid #000000">Size A<break/>(Mb)</th><th valign="middle" align="left" style="border-top:solid 1px #000000;border-left:solid 1px #000000">Genome B</th><th valign="middle" align="left" style="border-top: 1px solid #000000;border-left: 1px solid #000000">Size B<break/>(Mb)</th><th valign="middle" align="center" style="border-top: 1px solid #000000;border-left: 1px solid #000000">CPU time<break/>(min)</th><th valign="middle" align="center" style="border-top: 1px solid #000000">Memory<break/>(GB)</th><th valign="middle" align="center" style="border-top: 1px solid #000000">Cov A<break/>(%)</th><th valign="middle" align="center" style="border-top: 1px solid #000000;border-right: 1px solid #000000">Cov B<break/>(%)</th></tr></thead><tbody><tr><td valign="top" align="left" style="border-top: 1px solid #000000;border-left: 1px solid"><bold>Insect</bold></td><td valign="top" align="left" style="border-top: 1px solid #000000;border-left: 1px solid">Acronicta</td><td valign="top" align="left" style="border-top: 1px solid #000000;border-left: 1px solid"><italic>A. psi</italic> (1)</td><td valign="top" align="right" style="border-top: 1px solid #000000;border-left: 1px solid">405</td><td valign="top" align="left" style="border-top: 1px solid #000000;border-left: 1px solid"><italic>A. psi</italic> (2)</td><td valign="top" align="right" style="border-top: 1px solid #000000;border-left: 1px solid">402</td><td valign="top" align="center" style="border-top: 1px solid #000000;border-left: 1px solid">10.68</td><td valign="top" align="center" style="border-top: 1px solid">1.54</td><td valign="top" align="center" style="border-top: 1px solid">94.76</td><td valign="top" align="center" style="border-top: 1px solid #000000;border-right: 1px solid">95.07</td></tr><tr><td valign="top" align="left" style="border-left: 1px solid #000000"><bold>Fish</bold></td><td valign="top" align="left" style="border-left: 1px solid #000000">Thunnus</td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>T. albacares</italic> (1)</td><td valign="top" align="right" style="border-left: 1px solid #000000">792</td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>T. albacares</italic> (2)</td><td valign="top" align="right" style="border-left: 1px solid #000000">787</td><td valign="top" align="center" style="border-left: 1px solid #000000">22.91</td><td valign="top" align="center">2.08</td><td valign="top" align="center">98.98</td><td valign="top" align="center" style="border-right: 1px solid #000000">99.29</td></tr><tr><td valign="top" align="left" style="border-left: 1px solid #000000"><bold>Bird</bold></td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>Arnmaspiza</italic></td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>A. caudacuta</italic> (1)</td><td valign="top" align="right" style="border-left: 1px solid #000000">1,241</td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>A. caudacuta</italic> (2)</td><td valign="top" align="right" style="border-left: 1px solid #000000">1,167</td><td valign="top" align="center" style="border-left: 1px solid #000000">45.40</td><td valign="top" align="center">2.55</td><td valign="top" align="center">96.44</td><td valign="top" align="left" style="border-right: 1px solid #000000">99.15</td></tr><tr><td valign="top" align="left" style="border-left: 1px solid #000000"><bold>Reptile</bold></td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>Vipera</italic></td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>V. latastei</italic> (1)</td><td valign="top" align="right" style="border-left: 1px solid #000000">1,632</td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>V. latastei</italic> (2)</td><td valign="top" align="right" style="border-left: 1px solid #000000">1,549</td><td valign="top" align="center" style="border-left: 1px solid #000000">153.84</td><td valign="top" align="center">4.03</td><td valign="top" align="center">93.89</td><td valign="top" align="center" style="border-right: 1px solid #000000">97.96</td></tr><tr><td valign="top" align="left" style="border-left: 1px solid #000000"><bold>Mammal</bold></td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>Molosous</italic></td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>M. alvarezi</italic> (1)</td><td valign="top" align="right" style="border-left: 1px solid #000000">2,505</td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>M. alvarezi</italic> (2)</td><td valign="top" align="right" style="border-left: 1px solid #000000">2,478</td><td valign="top" align="center" style="border-left: 1px solid #000000">43.51</td><td valign="top" align="center">10.27</td><td valign="top" align="center">98.84</td><td valign="top" align="center" style="border-right: 1px solid #000000">99.19</td></tr><tr><td valign="top" align="left" style="border-left: 1px solid"><bold>Amphibian</bold></td><td valign="top" align="left" style="border-left: 1px solid"><italic>Liseotritan</italic></td><td valign="top" align="left" style="border-left: 1px solid"><italic>L. vulgaris</italic> (1)</td><td valign="top" align="right" style="border-left: 1px solid">24,226</td><td valign="top" align="left" style="border-left: 1px solid"><italic>L. vulgaris</italic> (2)</td><td valign="top" align="right" style="border-left: 1px solid">20,826</td><td valign="top" align="center" style="border-left: 1px solid">4,611.62</td><td valign="top" align="center">28.99</td><td valign="top" align="center">85.63</td><td valign="top" align="center" style="border-right: 1px solid">91.78</td></tr><tr><td valign="top" align="left" style="border-top: 1px solid #000000;border-left: 1px solid"><bold>Insect</bold></td><td valign="top" align="left" style="border-top: 1px solid #000000;border-left: 1px solid"><italic>Acronicic,</italic></td><td valign="top" align="left" style="border-top: 1px solid #000000;border-left: 1px solid"><italic>A. psi</italic> (1)</td><td valign="top" align="right" style="border-top: 1px solid #000000;border-left: 1px solid">405</td><td valign="top" align="left" style="border-top: 1px solid #000000;border-left: 1px solid"><italic>A. aceris</italic></td><td valign="top" align="right" style="border-top: 1px solid #000000;border-left: 1px solid">466</td><td valign="top" align="center" style="border-top: 1px solid #000000;border-left: 1px solid">9.23</td><td valign="top" align="center" style="border-top: 1px solid">2.20</td><td valign="top" align="center" style="border-top: 1px solid">27.13</td><td valign="top" align="center" style="border-top: 1px solid #000000;border-right: 1px solid">24.89</td></tr><tr><td valign="top" align="left" style="border-left: 1px solid"><bold>Fish</bold></td><td valign="top" align="left" style="border-left: 1px solid"><italic>Thuwnus</italic></td><td valign="top" align="left" style="border-left: 1px solid"><italic>T. albacares</italic> (1)</td><td valign="top" align="right" style="border-left: 1px solid">792</td><td valign="top" align="left" style="border-left: 1px solid"><italic>T. maccoyii</italic></td><td valign="top" align="right" style="border-left: 1px solid">782</td><td valign="top" align="center" style="border-left: 1px solid">21.20</td><td valign="top" align="center">3.87</td><td valign="top" align="center">98.61</td><td valign="top" align="center" style="border-right: 1px solid">98.84</td></tr><tr><td valign="top" align="left" style="border-left: 1px solid #000000"><bold>Bird</bold></td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>Arnmwspiza</italic></td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>A. caudacuta</italic> (1)</td><td valign="top" align="right" style="border-left: 1px solid #000000">1,241</td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>A. maritima</italic></td><td valign="top" align="right" style="border-left: 1px solid #000000">1,398</td><td valign="top" align="center" style="border-left: 1px solid #000000">33.15</td><td valign="top" align="center">3.21</td><td valign="top" align="center">90.40</td><td valign="top" align="center" style="border-right: 1px solid #000000">89.06</td></tr><tr><td valign="top" align="left" style="border-left: 1px solid #000000"><bold>Reptile</bold></td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>Vipera</italic></td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>V. latastei</italic> (1)</td><td valign="top" align="right" style="border-left: 1px solid #000000">1,632</td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>V. berus</italic></td><td valign="top" align="right" style="border-left: 1px solid #000000">1,695</td><td valign="top" align="center" style="border-left: 1px solid #000000">70.93</td><td valign="top" align="center">4.23</td><td valign="top" align="center">91.67</td><td valign="top" align="center" style="border-right: 1px solid #000000">90.53</td></tr><tr><td valign="top" align="left" style="border-left: 1px solid #000000"><bold>Mammal</bold></td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>Molossus</italic></td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>M. alvarezi</italic> (1)</td><td valign="top" align="right" style="border-left: 1px solid #000000">2,505</td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>M. nigricans</italic></td><td valign="top" align="right" style="border-left: 1px solid #000000">2,567</td><td valign="top" align="center" style="border-left: 1px solid #000000">51.24</td><td valign="top" align="center">11.23</td><td valign="top" align="center">94.77</td><td valign="top" align="center" style="border-right: 1px solid #000000">93.76</td></tr><tr><td valign="top" align="left" style="border-left: 1px solid #000000;border-bottom: 1px solid"><bold>Amphibian</bold></td><td valign="top" align="left" style="border-left: 1px solid #000000;border-bottom: 1px solid"><italic>Liseotoiton</italic></td><td valign="top" align="left" style="border-left: 1px solid #000000;border-bottom: 1px solid"><italic>L. vulgaris</italic> (1)</td><td valign="top" align="right" style="border-left: 1px solid #000000;border-bottom: 1px solid">24,226</td><td valign="top" align="left" style="border-left: 1px solid #000000;border-bottom: 1px solid"><italic>L. helveticus</italic></td><td valign="top" align="right" style="border-left: 1px solid #000000;border-bottom: 1px solid">23,170</td><td valign="top" align="center" style="border-left: 1px solid #000000;border-bottom: 1px solid">2,539.42</td><td valign="top" align="center" style="border-bottom: 1px solid">28.97</td><td valign="top" align="center" style="border-bottom: 1px solid">66.99</td><td valign="top" align="center" style="border-bottom: 1px solid #000000;border-right: 1px solid">75.32</td></tr></tbody></table></table-wrap></floats-group></article>