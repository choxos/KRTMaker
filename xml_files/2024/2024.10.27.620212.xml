<!DOCTYPE article
 PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2 20190208//EN" "JATS-archivearticle1.dtd">
<article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="preprint"><?all-math-mml yes?><?use-mml?><?origin ukpmcpa?><front><journal-meta><journal-id journal-id-type="nlm-ta">bioRxiv</journal-id><journal-title-group><journal-title>bioRxiv : the preprint server for biology</journal-title></journal-title-group><issn pub-type="epub">2692-8205</issn></journal-meta><article-meta><article-id pub-id-type="manuscript">EMS199765</article-id><article-id pub-id-type="doi">10.1101/2024.10.27.620212</article-id><article-id pub-id-type="archive">PPR932215</article-id><article-version-alternatives><article-version article-version-type="status">preprint</article-version><article-version article-version-type="number">1</article-version></article-version-alternatives><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Integer programming framework for pangenome-based genome inference</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Chandra</surname><given-names>Ghanshyam</given-names></name><xref ref-type="aff" rid="A1">1</xref></contrib><contrib contrib-type="author"><name><surname>Hossen</surname><given-names>Md Helal</given-names></name><xref ref-type="aff" rid="A2">2</xref></contrib><contrib contrib-type="author"><name><surname>Scholz</surname><given-names>Stephan</given-names></name><xref ref-type="aff" rid="A3">3</xref><xref ref-type="aff" rid="A4">4</xref></contrib><contrib contrib-type="author"><name><surname>Dilthey</surname><given-names>Alexander T</given-names></name><xref ref-type="aff" rid="A3">3</xref><xref ref-type="aff" rid="A4">4</xref></contrib><contrib contrib-type="author"><name><surname>Gibney</surname><given-names>Daniel</given-names></name><xref ref-type="aff" rid="A2">2</xref></contrib><contrib contrib-type="author"><name><surname>Jain</surname><given-names>Chirag</given-names></name><xref ref-type="aff" rid="A1">1</xref><xref ref-type="corresp" rid="CR1">*</xref></contrib></contrib-group><aff id="A1"><label>1</label>Department of Computational and Data Sciences, <institution-wrap><institution-id institution-id-type="ror">https://ror.org/04dese585</institution-id><institution>Indian Institute of Science</institution></institution-wrap>, <city>Bangalore KA</city><postal-code>560012</postal-code>, <country country="IN">India</country></aff><aff id="A2"><label>2</label>Department of Computer Science, <institution-wrap><institution-id institution-id-type="ror">https://ror.org/049emcs32</institution-id><institution>The University of Texas at Dallas</institution></institution-wrap>, <postal-code>TX 75080</postal-code>, <country country="US">USA</country></aff><aff id="A3"><label>3</label>Institute of Medical Microbiology and Hospital Hygiene, <institution-wrap><institution-id institution-id-type="ror">https://ror.org/024z2rq82</institution-id><institution>Heinrich Heine University Düsseldorf</institution></institution-wrap>, <city>Düsseldorf</city>, <country country="DE">Germany</country></aff><aff id="A4"><label>4</label>Center for Digital Medicine, <institution-wrap><institution-id institution-id-type="ror">https://ror.org/024z2rq82</institution-id><institution>Heinrich Heine University Düsseldorf</institution></institution-wrap>, <city>Düsseldorf</city>, <country country="DE">Germany</country></aff><author-notes><corresp id="CR1">
<label>*</label>corresponding author: <email>chirag@iisc.ac.in</email>
</corresp></author-notes><pub-date pub-type="nihms-submitted"><day>02</day><month>11</month><year>2024</year></pub-date><pub-date pub-type="preprint"><day>29</day><month>10</month><year>2024</year></pub-date><permissions><ali:free_to_read/><license><ali:license_ref>https://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p>This work is licensed under a <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 International license</ext-link>.</license-p></license></permissions><abstract><p id="P1">Affordable genotyping methods are essential in genomics. Commonly used genotyping methods primarily support single nucleotide variants and short indels but neglect structural variants. Additionally, accuracy of read alignments to a reference genome is unreliable in highly polymorphic and repetitive regions, further impacting genotyping performance. Recent works highlight the advantage of haplotype-resolved pangenome graphs in addressing these challenges. Building on these developments, we propose a rigorous alignment-free genotyping framework. Our formulation seeks a path through the pangenome graph that maximizes the matches between the path and substrings of sequencing reads (e.g., <italic>k</italic>-mers) while minimizing recombination events (haplotype switches) along the path. We prove that this problem is NP-Hard and develop efficient integer-programming solutions. We benchmarked the algorithm using downsampled short-read datasets from homozygous human cell lines with coverage ranging from 0.1× to 10×. Our algorithm accurately estimates complete major histocompatibility complex (MHC) haplotype sequences with small edit distances from the ground-truth sequences, providing a significant advantage over existing methods on low-coverage inputs. Although our algorithm is designed for haploid samples, we discuss future extensions to diploid samples.</p><p id="P2"><bold>Implementation:</bold> <ext-link ext-link-type="uri" xlink:href="https://github.com/at-cg/PHI">https://github.com/at-cg/PHI</ext-link></p></abstract></article-meta></front><body><sec id="S1" sec-type="intro"><label>1</label><title>Introduction</title><p id="P3">Many initiatives are in progress for building haplotype-resolved pangenome references of human and non-human species [<xref ref-type="bibr" rid="R22">22</xref>,<xref ref-type="bibr" rid="R11">11</xref>,<xref ref-type="bibr" rid="R36">36</xref>]. Among many applications, pangenome graphs can enable cost-effective genotyping and imputation of a wide spectrum of variant classes beyond single nucleotide polymorphisms (SNPs) and short indels [<xref ref-type="bibr" rid="R13">13</xref>]. Pangenome graphs represent sequence alignment of high-quality fully-phased genome assemblies of individuals from diverse populations [<xref ref-type="bibr" rid="R1">1</xref>]. A pangenome graph can be represented as either cyclic or acyclic directed graph where the vertices are labeled with sequences. Paths in this graph spell the reference haplotype sequences and their recombinations. The graph-based representation is flexible enough to incorporate single-nucleotide polymorphisms (SNPs), indels (short insertions and deletions), large structural variants (SVs), nested variants, gene absence/presence, etc. [<xref ref-type="bibr" rid="R4">4</xref>].</p><p id="P4">Recent works propose the use of pangenome references to improve genotyping accuracy from short-read sequencing data [<xref ref-type="bibr" rid="R9">9</xref>,<xref ref-type="bibr" rid="R14">14</xref>,<xref ref-type="bibr" rid="R12">12</xref>,<xref ref-type="bibr" rid="R18">18</xref>,<xref ref-type="bibr" rid="R2">2</xref>,<xref ref-type="bibr" rid="R10">10</xref>,<xref ref-type="bibr" rid="R33">33</xref>,<xref ref-type="bibr" rid="R25">25</xref>]. Especially for SVs, these methods are an effective alternative to the conventional genotyping methods that are based on aligning reads to a single reference because short-read alignments can be inaccurate for the reads originating from SVs [<xref ref-type="bibr" rid="R23">23</xref>,<xref ref-type="bibr" rid="R8">8</xref>]. Methods such as PRG [<xref ref-type="bibr" rid="R6">6</xref>], Pangenie [<xref ref-type="bibr" rid="R9">9</xref>], and KAGE [<xref ref-type="bibr" rid="R12">12</xref>], utilize <italic>k</italic>-mer statistics to infer paths in the graph that correspond to the target genome. These methods compare the <italic>k</italic>-mers surrounding a variant site in the graph with the <italic>k</italic>-mer counts in the sequencing data to calculate likelihoods of reference and alternative alleles. Pangenie and KAGE also use the long-range haplotype information available in the haplotype-resolved pangenome references. The other approach used in methods such as Giraffe [<xref ref-type="bibr" rid="R34">34</xref>] and Graphtyper [<xref ref-type="bibr" rid="R10">10</xref>] involves aligning reads to a pangenome graph.</p><p id="P5">There have been efforts on improving the accuracy of read alignments to pangenome graphs as well. A large combinatorial search space in terms of the number of candidate paths in a pangenome graph increases ambiguity during read alignment. This issue has motivated methods that either impute a personalized reference genome [<xref ref-type="bibr" rid="R38">38</xref>], sample variants [<xref ref-type="bibr" rid="R29">29</xref>,<xref ref-type="bibr" rid="R17">17</xref>,<xref ref-type="bibr" rid="R37">37</xref>] to obtain a smaller graph, or prioritize the use of reference haplotypes in the graph during alignment [<xref ref-type="bibr" rid="R3">3</xref>,<xref ref-type="bibr" rid="R34">34</xref>,<xref ref-type="bibr" rid="R26">26</xref>]. Our previous work proposed haplotype-aware sequence alignment to graphs by introducing penalties for haplotype switches in an alignment [<xref ref-type="bibr" rid="R3">3</xref>]. A recent feature added to VG allows sampling of reference haplotypes and their recombinations from the graph that are most relevant to the target genome using a <italic>k</italic>-mer-based greedy heuristic [<xref ref-type="bibr" rid="R35">35</xref>].</p><p id="P6">Low-coverage sequencing, combined with genotyping and phasing, is a cost-effective approach to conduct large-scale genetic studies [<xref ref-type="bibr" rid="R31">31</xref>,<xref ref-type="bibr" rid="R5">5</xref>,<xref ref-type="bibr" rid="R20">20</xref>,<xref ref-type="bibr" rid="R24">24</xref>]. In this paper, we develop a rigorous formulation and algorithms for genotyping using pangenome references. Our framework is also applicable to low-coverage short-read sequencing data (coverage 0.1−1×). Following the standard Li and Stephens model [<xref ref-type="bibr" rid="R21">21</xref>], we view the target genome as an imperfect mosaic of the reference haplotypes. Our contributions are as following. <list list-type="simple" id="L1"><list-item><label>–</label><p id="P7">We introduce a novel problem formulation to estimate the complete haplotype sequence of a haploid genome by determining an appropriate path in the pangenome graph. The objective is to maximize the number of shared substrings (e.g., <italic>k</italic>-mers or minimizers) between the sequencing data and the sequence spelled by the path. We permit recombinations in the path, subject to a fixed penalty per recombination. We refer to this problem as <italic>Path Inference Problem</italic> (formally defined in <xref ref-type="sec" rid="S3">Section 2</xref>).</p></list-item><list-item><label>–</label><p id="P8">We prove that the Path Inference Problem is NP-hard, even when restricted to binary alphabets.</p></list-item><list-item><label>–</label><p id="P9">To solve this problem, we develop two integer-programming solutions which involve linear and quadratic constraints, respectively. The two solutions involve a tradeoff between runtime and memory usage.</p></list-item><list-item><label>–</label><p id="P10">We demonstrate the utility of this framework by testing it on downsampled short-read datasets from five human haploid cell lines (coverage 0.1 − 10×). For these five samples, complete major histocompatibility complex (MHC) haplotype sequences have been previously determined using long-read assembly [<xref ref-type="bibr" rid="R16">16</xref>]. As our pangenome reference, we used a haplotype-resolved pangenome directed acyclic graph (DAG) of 49 MHC haplotype sequences [<xref ref-type="bibr" rid="R19">19</xref>]. We chose MHC region for evaluation because this is the most polymorphic and gene-rich region of the human genome [<xref ref-type="bibr" rid="R7">7</xref>]. The length of this region is about 5 Mbp.</p></list-item><list-item><label>–</label><p id="P11">Using datasets with 0.1× coverage, our algorithm outputs MHC sequences that are up to 99.96% identical to the ground-truth sequences. It compares favorably to the existing methods.</p></list-item></list></p><sec id="S2"><label>2</label><title>Notations and Problem Formulation</title><p id="P12">Let <italic>G</italic>(<italic>V, E, σ</italic>, <inline-formula><mml:math id="M1"><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow></mml:math></inline-formula>) denote a directed acyclic graph (DAG) representing a haplotype-resolved pangenome reference. Function <italic>σ</italic> assigns a string label over alphabet <italic>Σ</italic> = {<italic>A, C, G, T</italic>} to each vertex. A path (<italic>u</italic><sub>1</sub>, <italic>u</italic><sub>2</sub>, …, <italic>u</italic><sub><italic>n</italic></sub>) in <italic>G</italic> spells string <italic>σ</italic>(<italic>u</italic><sub>1</sub>) · <italic>σ</italic>(<italic>u</italic><sub>2</sub>) · · · <italic>σ</italic>(<italic>u</italic><sub><italic>n</italic></sub>), where <italic>s</italic><sub>1</sub> · <italic>s</italic><sub>2</sub> denotes the concatenation of strings <italic>s</italic><sub>1</sub> and <italic>s</italic><sub>2</sub>. <inline-formula><mml:math id="M2"><mml:mrow><mml:mi mathvariant="script">H</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>h</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>h</mml:mi><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> denotes a set of paths in <italic>G</italic> such that each of these paths spells a reference haplotype sequence used in the pangenome reference. We refer to these paths as haplotype paths. We assume that each haplotype path is described by an array, i.e., <italic>h</italic><sub><italic>i</italic></sub>[<xref ref-type="bibr" rid="R1">1</xref>] is the first vertex in <italic>h</italic><sub><italic>i</italic></sub>, <italic>h</italic><sub><italic>i</italic></sub>[<xref ref-type="bibr" rid="R2">2</xref>] is the second vertex in <italic>h</italic><sub><italic>i</italic></sub>, etc. The length of a haplotype path <italic>h</italic><sub><italic>i</italic></sub>, that is, the count of vertices in <italic>h</italic><sub><italic>i</italic></sub> is denoted as |<italic>h</italic><sub><italic>i</italic></sub>|. The set of haplotype paths covering vertex <italic>ν</italic> ∈ <italic>V</italic> is denoted as <italic>haps</italic>(<italic>ν</italic>). We assume that, for each edge (<italic>u, ν</italic>) ∈ <italic>E</italic>, there exists a haplotype path <inline-formula><mml:math id="M3"><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">H</mml:mi></mml:mrow></mml:math></inline-formula> such that <italic>u</italic> and <italic>ν</italic> are consecutive vertices in <italic>h</italic><sub><italic>i</italic></sub>. In other words, each edge is supported by at least one haplotype path.</p></sec><sec id="S3"><title>Definition 1 (Inferred Path)</title><p id="P13"><italic>An inferred path of</italic> <inline-formula><mml:math id="M4"><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:math></inline-formula> <italic>length n is represented as an ordered set</italic> (<italic>a</italic><sub>1</sub>, <italic>a</italic><sub>2</sub>, …, <italic>a</italic><sub><italic>n</italic></sub>), <italic>where each a</italic><sub><italic>i</italic></sub> <italic>is a two tuple</italic> (<italic>u, h</italic>) <italic>such that u</italic> ∈ <italic>V, h</italic> ∈ <italic>haps</italic>(<italic>u</italic>), <italic>and</italic> (<italic>a</italic><sub><italic>i</italic></sub>.<italic>u, a</italic><sub><italic>i</italic>+1</sub>.<italic>u</italic>) ∈ <italic>E for all i</italic> [1, <italic>n</italic>). <italic>Furthermore, if a</italic><sub><italic>i</italic></sub>.<italic>h</italic> = <italic>a</italic><sub><italic>i</italic>+1</sub>.<italic>h, then a</italic><sub><italic>i</italic></sub>.<italic>u and a</italic><sub><italic>i</italic>+1</sub>.<italic>u should be consecutive vertices in haplotype path a</italic><sub><italic>i</italic></sub>.<italic>h</italic>.</p><p id="P14">In an inferred path, we keep track of the haplotype path indices alongside vertex indices (<xref ref-type="fig" rid="F1">Figure 1</xref>). We say a <italic>recombination</italic>, or a haplotype switch, occurs between two consecutive vertices <italic>a</italic><sub><italic>i</italic></sub>.<italic>u</italic> and <italic>a</italic><sub><italic>i</italic>+1</sub>.<italic>u</italic> in <inline-formula><mml:math id="M5"><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:math></inline-formula> if <italic>a</italic><sub><italic>i</italic></sub>.<italic>h</italic> ≠ <italic>a</italic><sub><italic>i</italic>+1</sub>.<italic>h</italic>. We use <inline-formula><mml:math id="M6"><mml:mrow><mml:mi>γ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to denote the count of recombinations in <inline-formula><mml:math id="M7"><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:math></inline-formula>. With a mild abuse of notation, we denote the string spelled by <inline-formula><mml:math id="M8"><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:math></inline-formula> as <inline-formula><mml:math id="M9"><mml:mrow><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p><p id="P15">Problem 1 (Path Inference Problem). <list list-type="simple" id="L2"><list-item><label>–</label><p id="P16"><bold>Input:</bold> A haplotype-resolved pangenome DAG <italic>G</italic> = (<italic>V, E, σ</italic>, <inline-formula><mml:math id="M10"><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow></mml:math></inline-formula>), a set of strings <inline-formula><mml:math id="M11"><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> from the target genome, and a non-negative integer <italic>c</italic> indicating recombination penalty.</p></list-item><list-item><label>–</label><p id="P17"><bold>Output:</bold> An inferred path <inline-formula><mml:math id="M12"><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:math></inline-formula> such that <disp-formula id="FD1"><mml:math id="M13"><mml:mrow><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo>⋅</mml:mo><mml:mi>γ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:munder><mml:mstyle><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:munder><mml:mover accent="true"><mml:mi>χ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula> is minimized, where <inline-formula><mml:math id="M14"><mml:mrow><mml:mover accent="true"><mml:mi>χ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> if string <italic>r</italic> occurs as a substring of string <inline-formula><mml:math id="M15"><mml:mrow><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and 1 otherwise.</p></list-item></list>
</p><p id="P18">The intuition behind our formulation is to maximize the number of string matches along the inferred path while minimizing the number of recombinations. This approach yields an inferred path that incorporates the majority of strings from <inline-formula><mml:math id="M16"><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> as a substring with a finite number of recombinations, constrained by a recombination penalty <italic>c</italic>. Set <inline-formula><mml:math id="M17"><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> can be set of either <italic>k</italic>-mers or minimizers observed in the sequencing reads.</p></sec><sec id="S4"><label>3</label><title>Computational Complexity</title><p id="P19"><bold>Theorem 1.</bold> <italic>Problem 1 is NP-hard. This holds for any value of c</italic> = |<italic>V</italic> |<sup><italic>Θ</italic>(1)</sup> <italic>and even when Σ</italic> = {0, 1}.</p><p id="P20">We begin with an instance <italic>G</italic><sub><italic>H</italic></sub> (<italic>V</italic><sub><italic>H</italic></sub>, <italic>E</italic><sub><italic>H</italic></sub>) of the Hamiltonian Path Problem. Let <italic>V</italic><sub><italic>H</italic></sub> = {<italic>u</italic><sub>1</sub>, …, <italic>u</italic><sub><italic>n</italic></sub>}. We first create a graph <italic>G</italic>′ = (<italic>V</italic> ′, <italic>E</italic>′) where <disp-formula id="FD2"><mml:math id="M18"><mml:mrow><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mrow><mml:msup><mml:mi>V</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>s</mml:mi><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:msubsup><mml:mo>∣</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mi>t</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msup><mml:mi>E</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>u</mml:mi><mml:mi>k</mml:mi><mml:mn>1</mml:mn></mml:msubsup></mml:mrow><mml:mo>)</mml:mo><mml:mo>∣</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>u</mml:mi><mml:mi>h</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mo>)</mml:mo><mml:mo>∣</mml:mo><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>h</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mi>H</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>n</mml:mi><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mi>k</mml:mi><mml:mi>n</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>∣</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p id="P21">For 1 ≤ <italic>x</italic> ≤ <italic>n</italic> + 2(<italic>c</italic>(<italic>n</italic> + 1) + 1, let bin(<italic>x</italic>) be standard binary encoding of <italic>x</italic> using <italic>b</italic> = ⌈log<sub>2</sub>(<italic>n</italic> + 2(<italic>c</italic>(<italic>n</italic> + 1) + 1))⌉ + 1 bits. We assign the vertex labels <disp-formula id="FD3"><mml:math id="M19"><mml:mtable columnalign="left" equalrows="true" equalcolumns="true"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mrow><mml:mi>σ</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:msubsup></mml:mrow><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mspace width="0.2em"/><mml:mtext>bin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msup><mml:mn>0</mml:mn><mml:mi>b</mml:mi></mml:msup><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>for</mml:mtext><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mspace width="0.2em"/><mml:mtext>bin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msup><mml:mn>0</mml:mn><mml:mi>b</mml:mi></mml:msup><mml:mn>1</mml:mn><mml:mo>⋅</mml:mo><mml:mspace width="0.2em"/><mml:mtext>bin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msup><mml:mn>0</mml:mn><mml:mi>b</mml:mi></mml:msup><mml:mn>1</mml:mn><mml:mo>⋯</mml:mo><mml:mspace width="0.2em"/><mml:mtext>bin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msup><mml:mn>0</mml:mn><mml:mi>b</mml:mi></mml:msup><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mspace width="0.2em"/><mml:mtext>bin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msup><mml:mn>0</mml:mn><mml:mi>b</mml:mi></mml:msup><mml:mn>1</mml:mn><mml:mo>⋅</mml:mo><mml:mspace width="0.2em"/><mml:mtext>bin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msup><mml:mn>0</mml:mn><mml:mi>b</mml:mi></mml:msup><mml:mn>1</mml:mn><mml:mo>⋯</mml:mo><mml:mspace width="0.2em"/><mml:mtext>bin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msup><mml:mn>0</mml:mn><mml:mi>b</mml:mi></mml:msup><mml:mn>1.</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p id="P22">We create a distinct haplotype path for each edge that supports only that edge. We define the set of strings <inline-formula><mml:math id="M20"><mml:mrow><mml:mi mathvariant="script">S</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:mspace width="0.2em"/><mml:mtext>bin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msup><mml:mn>0</mml:mn><mml:mi>b</mml:mi></mml:msup><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mtext>bin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msup><mml:mn>0</mml:mn><mml:mi>b</mml:mi></mml:msup><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mtext>bin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msup><mml:mn>0</mml:mn><mml:mi>b</mml:mi></mml:msup><mml:mn>1</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. See <xref ref-type="fig" rid="F1">Figure 1</xref> in <xref ref-type="supplementary-material" rid="SD1">Appendix</xref> for a small worked example. The reduction presented above clearly runs in polynomial time for <italic>c</italic> = |<italic>V</italic>| <sup><italic>Θ</italic>(1)</sup>. Combined with Lemmas 1 and 2, Theorem 1 follows.</p><p id="P23"><bold>Lemma 1.</bold> <italic>If G</italic><sub><italic>H</italic></sub> <italic>contains a Hamiltonian path, then G</italic>′ <italic>has an inferred path</italic> <inline-formula><mml:math id="M21"><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:math></inline-formula><italic>with</italic> <inline-formula><mml:math id="M22"><mml:mrow><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo>⋅</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p><p id="P24"><italic>Proof</italic>. Let <inline-formula><mml:math id="M23"><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> be a Hamiltonian path in <italic>G</italic><sub><italic>H</italic></sub>. We take as our inferred path <inline-formula><mml:math id="M24"><mml:mrow><mml:mi mathvariant="script">P</mml:mi><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mn>1</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, <italic>t</italic>. As every edge has its own corresponding haplotype, the number of recombinations is <italic>n</italic> + 1. Furthermore, since <inline-formula><mml:math id="M25"><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is a Hamiltonian path and <italic>s</italic> and <italic>t</italic> are included in the inferred path, all strings in <inline-formula><mml:math id="M26"><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> occur in <inline-formula><mml:math id="M27"><mml:mrow><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Hence, the total cost is <italic>c</italic> · (<italic>n</italic> + 1).</p><p id="P25"><bold>Lemma 2.</bold> <italic>If G</italic>′ <italic>has an inferred path</italic> <inline-formula><mml:math id="M28"><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:math></inline-formula> <italic>with</italic> <inline-formula><mml:math id="M29"><mml:mrow><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo>⋅</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <italic>then G</italic><sub><italic>H</italic></sub> <italic>has a Hamiltonian path</italic>.</p><p id="P26"><italic>Proof</italic>. First, we claim that <italic>s</italic> and <italic>t</italic> must be included in <inline-formula><mml:math id="M30"><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:math></inline-formula>. The 0<sup><italic>b</italic></sup>1 substrings are used as padding to prevent any string in <inline-formula><mml:math id="M31"><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> from being matched using portions of two or more vertex labels. Therefore, if <italic>s</italic> or <italic>t</italic> are not included in the inferred path, at least <italic>c</italic> (<italic>n</italic> + 1) + 1 strings from <inline-formula><mml:math id="M32"><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> do not occur in <inline-formula><mml:math id="M33"><mml:mrow><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, contradicting that <inline-formula><mml:math id="M34"><mml:mrow><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo>⋅</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Hence, the inferred path must contain <italic>s</italic> and <italic>t</italic> and be of the form <inline-formula><mml:math id="M35"><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mn>1</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> <italic>t</italic> for some <italic>i</italic><sub>1</sub>, …, <italic>i</italic><sub><italic>n</italic></sub>. Since each edge traversed corresponds to a recombination, the total number of recombinations is <italic>n</italic> + 1. The only way the <inline-formula><mml:math id="M36"><mml:mrow><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo>⋅</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is if all strings in <inline-formula><mml:math id="M37"><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> occur as substrings in <inline-formula><mml:math id="M38"><mml:mrow><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Again, due to the 0<sup><italic>b</italic></sup>1 padding in the vertex labels, this can only happen if for all <inline-formula><mml:math id="M39"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mi>u</mml:mi><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is a vertex in <inline-formula><mml:math id="M40"><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:math></inline-formula> for some <italic>k</italic>. Furthermore, because there are <italic>n</italic> vertices in <inline-formula><mml:math id="M41"><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:math></inline-formula> that are not <italic>s</italic> or <italic>t</italic>, there must be exactly one such <italic>k</italic> for a given <italic>i</italic>. We conclude that <inline-formula><mml:math id="M42"><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is a Hamiltonian path in <italic>G</italic><sub><italic>H</italic></sub>.</p></sec><sec id="S5"><label>4</label><title>Proposed Algorithms</title><p id="P27">Before developing our integer programming solutions to Problem 1, it is first helpful to define an additional graph representation, which we call as <italic>expanded graph</italic>. In pangenome graphs, multiple haplotype paths share vertices if the sequences are conserved, whereas in the expanded graph, we will split all haplotypes into separate paths (<xref ref-type="fig" rid="F2">Figures 2A, 2B</xref>). The expanded graph enables us to model Problem 1 as a sort of network flow problem. In particular, the inferred path will be reconstructed from a flow of value one in the expanded graph. We will assign weights to edges to account for recombination penalty. Additional constraints will be used to capture how many strings in <inline-formula><mml:math id="M43"><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> occur in the resulting inferred path.</p><p id="P28">Lemma 3 allows us to only consider a subset of all possible recombinations in order to find an optimal solution to Problem 1. We call the type of recombination described in Lemma 3 a <italic>useful recombination</italic>.</p><p id="P29"><bold>Lemma 3.</bold> <italic>There exists an optimal inferred path</italic> <inline-formula><mml:math id="M44"><mml:mrow><mml:mi mathvariant="script">P</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> <italic>for Problem 1 where for all i</italic> ∈ [1, <italic>n</italic>), <italic>a</italic><sub><italic>i</italic></sub>.<italic>h</italic> ≠ <italic>a</italic><sub><italic>i</italic>+1</sub>.<italic>h implies vertices a</italic><sub><italic>i</italic></sub>.<italic>u and a</italic><sub><italic>i</italic>+1</sub>.<italic>u are not consecutive vertices in haplotype path a</italic><sub><italic>i</italic></sub>.<italic>h</italic>.</p><p id="P30"><italic>Proof</italic>. Suppose there is an optimal inferred path <inline-formula><mml:math id="M45"><mml:mrow><mml:mi mathvariant="script">P</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> for Problem 1 where for some <italic>a</italic><sub><italic>i</italic></sub>, <italic>a</italic><sub><italic>i</italic></sub>.<italic>h</italic> ≠ <italic>a</italic><sub><italic>i</italic>+1</sub>.<italic>h</italic> such that <italic>a</italic><sub><italic>i</italic></sub>.<italic>u</italic> and <italic>a</italic><sub><italic>i</italic>+1</sub>.<italic>u</italic> are consecutive vertices in haplotype path <italic>a</italic><sub><italic>i</italic></sub>.<italic>h</italic>. Furthermore, suppose we start with the smallest <italic>i</italic> where this holds. We then change the haplotype path for <italic>a</italic><sub><italic>i</italic>+1</sub> to equal <italic>a</italic><sub><italic>i</italic></sub>.<italic>h</italic>. This does not increase the overall cost, since the number of string <inline-formula><mml:math id="M46"><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> occurring in <inline-formula><mml:math id="M47"><mml:mrow><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has not changed, and the number of recombinations either decreases or stays the same. Continuing this process from the next <italic>j</italic> &gt; <italic>i</italic>, such that <italic>a</italic><sub><italic>j</italic></sub>.<italic>h</italic> ≠ <italic>a</italic><sub><italic>j</italic>+1</sub>.<italic>h</italic> and <italic>a</italic><sub><italic>j</italic></sub>.<italic>u</italic> and <italic>a</italic><sub><italic>j</italic>+1</sub>.<italic>u</italic> are consecutive vertices in <italic>a</italic><sub><italic>j</italic></sub>.<italic>h</italic>, we achieve an inferred path satisfying the conditions stated in the lemma after at most <italic>n</italic> iterations.</p><p id="P31">Next, we present a definition of the expanded graph where we will consider only the useful recombinations. For technical reasons, we preprocess each edge in <italic>E</italic>, splitting it and adding a new vertex labeled with the empty string <italic>ϵ</italic>. Each added vertex inherits the haplotype paths which supported the edge it was formed from. This added step is to prevent recombinations from a haplotype to itself when we build our expanded graph. Now, let <italic>V</italic> = {<italic>u</italic><sub>1</sub>, …, <italic>u</italic><sub><italic>n</italic></sub>}. For haplotype path <inline-formula><mml:math id="M48"><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mspace width="0.2em"/><mml:mo>,</mml:mo><mml:mtext>let</mml:mtext><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, denote the <italic>i</italic><sup><italic>th</italic></sup> vertex in haplotype path <italic>h</italic><sub><italic>j</italic></sub>. We use <italic>G</italic><sub><italic>E</italic></sub> = (<italic>V</italic><sub><italic>E</italic></sub>, <italic>E</italic><sub><italic>E</italic></sub>, <italic>σ</italic><sub><italic>E</italic></sub>) to denote the expanded graph. In <italic>G</italic><sub><italic>E</italic></sub>, vertices are string-labeled and edges are weighted. Vertex set <italic>V</italic><sub><italic>E</italic></sub> is defined as: <disp-formula id="FD4"><label>(1)</label><mml:math id="M49"><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mi>E</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>s</mml:mi><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mi>t</mml:mi><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msubsup><mml:mtext>|</mml:mtext><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo>|</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>|</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p id="P32">The vertex set contains a source and sink vertex, <italic>s</italic> and <italic>t</italic>, respectively. The vertex set also contains a set of disjoint vertices for each haplotype path in H (<xref ref-type="fig" rid="F2">Figure 2B</xref>). A superscript is used to indicate which haplotype path the vertex is designated to. We refer to the ordered vertex set <inline-formula><mml:math id="M50"><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msubsup><mml:mo>⋯</mml:mo><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>[</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> as a haplotype path in <italic>G</italic><sub><italic>E</italic></sub>.</p><p id="P33">We denote weighted edges in <italic>E</italic><sub><italic>E</italic></sub> as tuples of the form (<italic>start, end, weight</italic>). The weighted edge set is <disp-formula id="FD5"><label>(2)</label><mml:math id="M51"><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mi>E</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mo>)</mml:mo><mml:mo>|</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></disp-formula> <disp-formula id="FD6"><label>(3)</label><mml:math id="M52"><mml:mrow><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>[</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mo>)</mml:mo><mml:mo>|</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></disp-formula>
<disp-formula id="FD7"><label>(4)</label><mml:math id="M53"><mml:mrow><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mo>)</mml:mo><mml:mtext>|</mml:mtext><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo>|</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula> <disp-formula id="FD8"><label>(5)</label><mml:math id="M54"><mml:mrow><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>u</mml:mi><mml:mi>k</mml:mi><mml:msup><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:msubsup><mml:mo>,</mml:mo><mml:mi>c</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mtext>|</mml:mtext><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo>|</mml:mo><mml:mo>,</mml:mo><mml:mo>∃</mml:mo><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mspace width="0.2em"/><mml:mtext>s</mml:mtext><mml:mo>.</mml:mo><mml:mtext>t</mml:mtext><mml:mo>.</mml:mo><mml:mspace width="0.2em"/><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>|</mml:mo><mml:mo>.</mml:mo><mml:mtext>or</mml:mtext><mml:mo>.</mml:mo><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P34">Next, we give some intuition for each line (<xref ref-type="disp-formula" rid="FD2">2</xref>)-(<xref ref-type="disp-formula" rid="FD5">5</xref>) in the above construction of <italic>E</italic><sub><italic>E</italic></sub>. <list list-type="simple" id="L3"><list-item><label>(2)</label><p id="P35">Weight 0 edges are created from <italic>s</italic> to the start of each haplotype path in <italic>G</italic><sub><italic>E</italic></sub>.</p></list-item><list-item><label>(3)</label><p id="P36">Weight 0 edges are created from the end of each haplotype path in <italic>G</italic><sub><italic>E</italic></sub> to <italic>t</italic>.</p></list-item><list-item><label>(4)</label><p id="P37">Weight 0 edges are created between adjacent vertices in each haplotype path. That is, in the path for <italic>h</italic><sub><italic>j</italic></sub>, an edge is created from <inline-formula><mml:math id="M55"><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M56"><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p></list-item><list-item><label>(5)</label><p id="P38">Weight <italic>c</italic> edges are used to represent the useful recombinations described in Lemma 3. We call these <italic>recombination edges</italic>.</p><p id="P39">We use <italic>ϵ</italic> to denote the empty string. The vertex labels are defined as follows: <disp-formula id="FD9"><label>(6)</label><mml:math id="M57"><mml:mrow><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>E</mml:mi></mml:msub><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msubsup></mml:mrow><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>σ</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>for</mml:mtext><mml:mspace width="0.2em"/><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo>|</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula> <disp-formula id="FD10"><label>(7)</label><mml:math id="M58"><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>E</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi>E</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>ϵ</mml:mi></mml:mrow></mml:math></disp-formula>
</p></list-item><list-item><label>(6)</label><p id="P40">The vertices in a haplotype path are labeled according to the corresponding vertex label in <italic>G</italic>. These labels will be used to identify matches.</p></list-item><list-item><label>(7)</label><p id="P41">The source, sink, do not require vertex labels and are hence labeled with the empty string <italic>ϵ</italic>.</p></list-item></list></p><sec id="S6"><title>Optimizing the Expanded Graph</title><p id="P42">One issue with the above construction is that the number of recombination edges for a given potential recombination can be <inline-formula><mml:math id="M59"><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> in the worst case. This occurs because we maintain |<italic>haps</italic>(<italic>ν</italic>)| copies of each vertex <italic>ν</italic> ∈ <italic>V</italic>. For every edge (<italic>u, ν</italic>) ∈ <italic>E</italic> allowing a recombination, we add <italic>O</italic>(|<italic>haps</italic>(<italic>u</italic>)|· |<italic>haps</italic>(<italic>ν</italic>)|) edges to the edge set <italic>E</italic><sub><italic>E</italic></sub>. Since both |<italic>haps</italic>(<italic>u</italic>)| and |<italic>haps</italic>(<italic>ν</italic>)| can be at most <inline-formula><mml:math id="M60"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, any potential recombination can result in <inline-formula><mml:math id="M61"><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> recombination edges in the worst case. We observe this issue in practice as well. An improvement is to represent a recombination by having an intermediate vertex <italic>w</italic><sub><italic>e</italic></sub> that represents the edge <italic>e ∈ E</italic> allowing for the recombination. We then create an edge to <italic>w</italic><sub><italic>e</italic></sub> from every vertex in a haplotype path which the recombination would start from, and edges from <italic>w</italic><sub><italic>e</italic></sub> to every vertex in a haplotype path to which the recombination would lead to (<xref ref-type="fig" rid="F2">Figure 2C</xref>). More formally, the modified vertex set becomes <disp-formula id="FD11"><label>(8)</label><mml:math id="M62"><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mi>E</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>s</mml:mi><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mi>t</mml:mi><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msubsup><mml:mtext>|</mml:mtext><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo>|</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>|</mml:mo><mml:mtext>}</mml:mtext><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P43">We also replace Line (<xref ref-type="disp-formula" rid="FD5">5</xref>) in the construction of <italic>E</italic><sub><italic>E</italic></sub> with the Lines (<xref ref-type="disp-formula" rid="FD9">9</xref>) and (<xref ref-type="disp-formula" rid="FD10">10</xref>) as follows: <italic>E</italic><sub><italic>E</italic></sub> = … <disp-formula id="FD12"><label>(9)</label><mml:math id="M63"><mml:mrow><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mo>)</mml:mo><mml:mtext>|</mml:mtext><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo>|</mml:mo><mml:mo>,</mml:mo><mml:mo>∃</mml:mo><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mspace width="0.2em"/><mml:mtext>s</mml:mtext><mml:mo>.</mml:mo><mml:mtext>t</mml:mtext><mml:mo>.</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mspace width="0.2em"/><mml:mtext>or</mml:mtext><mml:mspace width="0.2em"/><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:math></disp-formula> <disp-formula id="FD13"><label>(10)</label><mml:math id="M64"><mml:mrow><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>u</mml:mi><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mo>)</mml:mo><mml:mtext>|</mml:mtext><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo>|</mml:mo><mml:mo>,</mml:mo><mml:mo>∃</mml:mo><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mtext>s</mml:mtext><mml:mo>.</mml:mo><mml:mtext>t</mml:mtext><mml:mo>.</mml:mo><mml:mspace width="0.2em"/><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.2em"/><mml:mtext>or</mml:mtext><mml:mspace width="0.2em"/><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mtext>}</mml:mtext></mml:mrow></mml:math></disp-formula></p><p id="P44">We now call these edges created in Lines (<xref ref-type="disp-formula" rid="FD9">9</xref>) and (<xref ref-type="disp-formula" rid="FD10">10</xref>) the recombination edges. After creating the edges in <italic>E</italic><sub><italic>E</italic></sub>, we delete any <italic>w</italic><sub><italic>e</italic></sub> vertex that is isolated in <italic>G</italic><sub><italic>E</italic></sub>. Finally, for any remaining <italic>w</italic><sub><italic>e</italic></sub> vertices, we define <italic>σ</italic><sub><italic>E</italic></sub>(<italic>w</italic><sub><italic>e</italic></sub>) = <italic>ϵ</italic>. Observe, that the above modification allows for the same set of useful recombinations as our initial expanded graph construction. However, per potential useful recombination, the number of edges remains <inline-formula><mml:math id="M65"><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> rather than <inline-formula><mml:math id="M66"><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:msup><mml:mo>|</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>. Before giving the integer programming solutions, we require one additional definition.</p><p id="P45"><bold>Definition 2 (Hits).</bold> <italic>For a string</italic> <inline-formula><mml:math id="M67"><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula>, <italic>assuming</italic> <inline-formula><mml:math id="M68"><mml:mrow><mml:msub><mml:mrow><mml:mi>max</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>E</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>E</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>|</mml:mo><mml:mo>&lt;</mml:mo><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, <italic>a path in G</italic><sub><italic>E</italic></sub>, <italic>denoted as an ordered edge set</italic> ((<italic>u, ν</italic>), (<italic>ν, w</italic>), (<italic>w, x</italic>) …, (<italic>y, z</italic>)), <italic>matches r if r</italic> = <italic>σ</italic><sub><italic>E</italic></sub>(<italic>u</italic>)′ · <italic>σ</italic><sub><italic>E</italic></sub>(<italic>ν</italic>) · <italic>σ</italic><sub><italic>E</italic></sub>(<italic>w</italic>) <italic>σ</italic><sub><italic>E</italic></sub>(<italic>x</italic>) ⋯ <italic>σ</italic><sub><italic>E</italic></sub>(<italic>y</italic>) · <italic>σ</italic><sub><italic>E</italic></sub>(<italic>z</italic>)′, <italic>where σ</italic><sub><italic>E</italic></sub>(<italic>u</italic>)′ <italic>is a suffix of σ</italic><sub><italic>E</italic></sub>(<italic>u</italic>) <italic>and σ</italic><sub><italic>E</italic></sub>(<italic>z</italic>)′ <italic>a prefix of σ</italic><sub><italic>E</italic></sub>(<italic>z</italic>). <italic>We use hits</italic>(<italic>r</italic>) <italic>to represent the set of paths matching string r in G</italic><sub><italic>E</italic></sub>.</p></sec><sec id="S7"><label>4.1</label><title>Integer Linear Programming (ILP) Formulation</title><p id="P46">We assume that the maximum length of any vertex label is upper bounded by the length of any string in <inline-formula><mml:math id="M69"><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula>, i.e., <inline-formula><mml:math id="M70"><mml:mrow><mml:msub><mml:mrow><mml:mi>max</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>E</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>E</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>|</mml:mo><mml:mo>&lt;</mml:mo><mml:msub><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. This condition can be easily enforced in the input graph by adjusting the lengths of vertex labels, e.g., by splitting a vertex with a long label into two, while ensuring that the graph’s topology is preserved. We assume<inline-formula><mml:math id="M71"><mml:mrow><mml:msub><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>.</p><p id="P47">The basis for our solution is to find an <italic>st</italic>-flow with a flow of 1 through the expanded graph <italic>G</italic><sub><italic>E</italic></sub>. Our integer programs will utilize binary decision variable <italic>x</italic><sub><italic>uv</italic></sub> for each edge. The variable <italic>x</italic><sub><italic>uv</italic></sub> will take the value 1 if edge (<italic>u, ν</italic>) ∈ <italic>E</italic><sub><italic>E</italic></sub> is part of the solution flow and 0 otherwise. Because these are binary variables, the flow will always be a path. From the solution path in <italic>G</italic><sub><italic>E</italic></sub>, it is straight forward to recover the corresponding inferred path <inline-formula><mml:math id="M72"><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:math></inline-formula>. We use binary decision variable <italic>z</italic><sub><italic>r</italic></sub> for each string <inline-formula><mml:math id="M73"><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> such that <italic>z</italic><sub><italic>r</italic></sub> will take the value 1 if the solution flow includes a subpath from <italic>hits</italic>(<italic>r</italic>). We also use variable <italic>z</italic><sub><italic>rω</italic></sub> for each <italic>ω</italic> ∈ <italic>hits</italic>(<italic>r</italic>), <inline-formula><mml:math id="M74"><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula>.</p><p id="P48">Letting <italic>weight</italic>(<italic>u, ν</italic>) denote the weight of an edge (<italic>u, ν</italic>) ∈ <italic>E</italic><sub><italic>E</italic></sub>, our ILP formulation is as follows: <disp-formula id="FD14"><label>(11)</label><mml:math id="M75"><mml:mrow><mml:mi>min</mml:mi><mml:munder><mml:mstyle><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mi>E</mml:mi></mml:msub></mml:mrow></mml:munder><mml:mi>w</mml:mi><mml:mi>e</mml:mi><mml:mi>i</mml:mi><mml:mi>g</mml:mi><mml:mi>h</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:munder><mml:mstyle><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:munder><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula> subject to <disp-formula id="FD15"><label>(12)</label><mml:math id="M76"><mml:mrow><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi mathvariant="script">N</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:munder><mml:mi>∑</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi mathvariant="script">N</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mrow><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if</mml:mtext><mml:mspace width="0.2em"/><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if</mml:mtext><mml:mspace width="0.2em"/><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mtext>otherwise</mml:mtext><mml:mo>,</mml:mo><mml:mspace width="0.2em"/></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mspace width="0.2em"/><mml:mo>∀</mml:mo><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>E</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></disp-formula> <disp-formula id="FD16"><label>(13)</label><mml:math id="M77"><mml:mrow><mml:munder><mml:mstyle><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>ω</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:mo>|</mml:mo><mml:mi>ω</mml:mi><mml:mo>|</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>ω</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>ω</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mo>∀</mml:mo><mml:mi>ω</mml:mi><mml:mo>∈</mml:mo><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>∀</mml:mo><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula> <disp-formula id="FD17"><label>(14)</label><mml:math id="M78"><mml:mrow><mml:munder><mml:mstyle><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>ω</mml:mi><mml:mo>∈</mml:mo><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>ω</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:msub><mml:mi>z</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mo>∀</mml:mo><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula> <disp-formula id="FD18"><label>(15)</label><mml:math id="M79"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mo>∀</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mi>E</mml:mi></mml:msub></mml:mrow></mml:math></disp-formula></p><p id="P49">In the ILP formulation, the Objective (<xref ref-type="disp-formula" rid="FD11">11</xref>) models <inline-formula><mml:math id="M80"><mml:mrow><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The summation over <italic>weight</italic>(<italic>u, ν</italic>)·<italic>x</italic><sub><italic>uv</italic></sub> imposes penalty <italic>c</italic> for each recombination. This is due to the two <italic>c</italic>/2 weighted recombination edges that must traversed when the path switches between haplotype paths in <italic>G</italic><sub><italic>E</italic></sub> (<xref ref-type="fig" rid="F2">Figure 2C</xref>). In the second summation, the term (1 − <italic>z</italic><sub><italic>r</italic></sub>) adds a penalty of 1 to the objective for every <inline-formula><mml:math id="M81"><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> where <inline-formula><mml:math id="M82"><mml:mrow><mml:mover accent="true"><mml:mi>χ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> Constraint (<xref ref-type="disp-formula" rid="FD12">12</xref>) enforces flow conservation, allowing a unit flow from the source vertex <italic>s</italic> to the sink vertex <italic>t</italic>, ensuring that the ILP formulation selects a single path in the expanded graph.</p><p id="P50">To explain the function of Constraint (<xref ref-type="disp-formula" rid="FD13">13</xref>), termed as linear string-hit constraint and (<xref ref-type="disp-formula" rid="FD14">14</xref>), observe that in an optimal solution, whenever possible the variable <italic>z</italic><sub><italic>r</italic></sub> is set to 1. This is because the term (1− <italic>z</italic><sub><italic>r</italic></sub>) in the objective function adds a penalty of 0 whenever <italic>z</italic><sub><italic>r</italic></sub> = 1. However, this is only possible when <italic>z</italic><sub><italic>rω</italic></sub> is equal to 1 for some <italic>ω</italic> ∈ <italic>hits</italic>(<italic>r</italic>). This, in turn, is only possible if Σ <sub>(<italic>u,v</italic>)∈<italic>ω</italic></sub> <italic>x</italic><sub><italic>uv</italic></sub> = |<italic>ω</italic>|, meaning <italic>r</italic> occurs as a substring in the inferred path. Also note that at most one <italic>z</italic><sub><italic>rω</italic></sub> variable can equal 1 in Constraint (<xref ref-type="disp-formula" rid="FD14">14</xref>). Other <italic>z</italic><sub><italic>rω</italic></sub><italic>′</italic> variables, where <italic>ω, ω</italic>′ ∈ <italic>hits</italic>(<italic>r</italic>) and <italic>ω</italic> ≠ <italic>ω</italic>′, can have a value of 0, even if Σ<sub>(<italic>u,v</italic>)∈<italic>ω</italic>′</sub> <italic>x</italic><sub><italic>uv</italic></sub> = |<italic>ω</italic>′|, justifying the use of equality in Constraint (<xref ref-type="disp-formula" rid="FD14">14</xref>).</p><p id="P51">A weakness of the proposed ILP formulation is that the number of string-hit constraints equals the total number of string matches, that is, <inline-formula><mml:math id="M83"><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mi>∑</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:math></inline-formula>. We design another formulation with quadratic constraints in which fewer constraints are needed.</p></sec><sec id="S8"><label>4.2</label><title>Integer Quadratic Programming (IQP) Formulation</title><p id="P52">In our IQP formulation, Objective (<xref ref-type="disp-formula" rid="FD11">11</xref>), and Constraints (<xref ref-type="disp-formula" rid="FD12">12</xref>), and (<xref ref-type="disp-formula" rid="FD14">14</xref>) and (<xref ref-type="disp-formula" rid="FD15">15</xref>) remain unchanged from the ILP formulation. Constraints in (<xref ref-type="disp-formula" rid="FD13">13</xref>) are replaced by quadratic constraints defined as <disp-formula id="FD19"><label>(16)</label><mml:math id="M84"><mml:mrow><mml:munder><mml:mstyle><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mi>w</mml:mi><mml:mo>∈</mml:mo><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mo>|</mml:mo><mml:mi>ω</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:munder><mml:mstyle><mml:mi>∑</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>ω</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>w</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mo>∀</mml:mo><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P53">We call Constraint (<xref ref-type="disp-formula" rid="FD16">16</xref>) the quadratic string-hit constraint. Again, due to Constraint (<xref ref-type="disp-formula" rid="FD14">14</xref>) at most one <italic>z</italic><sub><italic>rω</italic></sub> variable can be 1. The expression 1 − |<italic>ω</italic>| + Σ<sub>(<italic>u,v</italic>) ∈<italic>ω</italic></sub> <italic>x</italic><sub><italic>uv</italic></sub> sums to 1 when the subpath <italic>ω</italic> is contained in the flow. In this case <italic>z</italic><sub><italic>r</italic></sub> will take the value 1 and no penalty is paid in the objective. Conversely, if some of the edges for <italic>ω</italic> are not in the flow, the expression will sum to ≤ 0. If this is the case for each <italic>ω</italic> ∈ <italic>hits</italic>(<italic>r</italic>), then Constraint (<xref ref-type="disp-formula" rid="FD16">16</xref>) can only be satisfied by setting <italic>z</italic><sub><italic>r</italic></sub> = 0 and <italic>z</italic><sub><italic>rω</italic></sub> = 0 for each <italic>ω</italic> ∈ <italic>hits</italic>(<italic>r</italic>). Since <italic>z</italic><sub><italic>r</italic></sub> = 0, a penalty is paid in the objective. The total number of quadratic string-hit constraints is <inline-formula><mml:math id="M85"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. In our experiments, we observe that IQP formulation solves the problem faster, albeit while requiring more memory.</p><p id="P54">As a further improvement, we relax the variables <italic>x</italic><sub><italic>uv</italic></sub> for all (<italic>u, ν</italic>) ∈ <italic>E</italic><sub><italic>E</italic></sub> to continuous values <italic>x</italic><sub><italic>uv</italic></sub> <italic>∈</italic> [0, 1] in Constraint (<xref ref-type="disp-formula" rid="FD15">15</xref>), following Lemma 4.</p><p id="P55"><bold>Lemma 4.</bold> <italic>An optimal solution ϕ</italic><sub><italic>cont</italic></sub> <italic>to the IQP (or ILP) with relaxed Constraint (<xref ref-type="disp-formula" rid="FD15">15</xref>) where variables x</italic><sub><italic>uv</italic></sub> <italic>lie within the continuous interval</italic> [0, 1] <italic>can be transformed in polynomial time to an optimal solution ϕ satisfying x</italic><sub><italic>uv</italic></sub> ∈ {0, 1} <italic>for all</italic> (<italic>u, ν</italic>) ∈ <italic>E</italic><sub><italic>E</italic></sub>.</p><p id="P56"><italic>Proof</italic>. First, observe that <italic>z</italic><sub><italic>r</italic></sub> = 1 if and only if all edges in some <italic>ω ∈ hits</italic>(<italic>r</italic>) have their corresponding variables set to 1. This follows from Constraints (<xref ref-type="disp-formula" rid="FD13">13</xref>) and (<xref ref-type="disp-formula" rid="FD16">16</xref>), and the fact that at most one <italic>z</italic><sub><italic>rω</italic></sub> can be 1 for a given <italic>r</italic>, by Constraint (<xref ref-type="disp-formula" rid="FD14">14</xref>).</p><p id="P57">If <italic>z</italic><sub><italic>r</italic></sub> = 0 for all <inline-formula><mml:math id="M86"><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> in <italic>ϕ</italic><sub><italic>cont</italic></sub>, then <italic>ϕ</italic> can be trivially obtained as a single haplotype path in <italic>G</italic><sub><italic>E</italic></sub> without recombination penalties. In such a case, all edge variables are assigned either 0 or 1.</p><p id="P58">For the remaining cases, we introduce the following terms: <list list-type="simple" id="L4"><list-item><label>–</label><p id="P59"><italic>ω ∈ hits</italic>(<italic>r</italic>) is a <italic>used hit-subpath</italic> if <italic>z</italic><sub><italic>rω</italic></sub> = 1.</p></list-item><list-item><label>–</label><p id="P60">A flow between vertices <italic>u</italic> and <italic>ν</italic> can be decomposed into <italic>uν</italic>-paths each assigned some positive flow and called <italic>flow subpaths</italic>.</p></list-item><list-item><label>–</label><p id="P61"><italic>ω</italic> is the <italic>first used hit-subpath</italic> if there is a flow subpath from vertex <italic>s</italic> to the first vertex of <italic>ω</italic> without passing through another used hit-subpath.</p></list-item><list-item><label>–</label><p id="P62"><italic>ω</italic> is the <italic>last used hit-subpath</italic> if there is a flow subpath from the last vertex of <italic>ω</italic> to vertex <italic>t</italic> without passing through another used hit-subpath.</p></list-item><list-item><label>–</label><p id="P63"><italic>ω</italic> and <italic>ω</italic>′ are <italic>consecutive used hit-subpaths</italic> if there is a flow subpath between them without passing through a third used hit-subpath, where <italic>ω</italic>′ ≠ <italic>ω</italic> and <italic>ω</italic>′ ∈ <italic>hits</italic>(<italic>r</italic>).</p></list-item></list></p><p id="P64">Now, if <italic>z</italic><sub><italic>r</italic></sub> = 1 in <italic>ϕ</italic><sub><italic>cont</italic></sub> for some <inline-formula><mml:math id="M87"><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula>, there exists a used hit-subpath. We obtain <italic>ϕ</italic> as following. The flow used to reach the first hit-subpath avoids recombination penalties by following a single haplotype path. Similarly, the flow from the end vertex on the last used hit-subpath to <italic>t</italic> avoids recombinations penalties by staying on a single haplotype path. Next, consider two consecutive used hit-subpaths <italic>ω</italic> and <italic>ω</italic>′, with <italic>u</italic> and <italic>ν</italic> as their respective end and start vertices. If <italic>u</italic> and <italic>ν</italic> are on different haplotype paths, any flow subpaths between <italic>u</italic> and <italic>ν</italic> must minimize the recombination penalty. The same minimum recombination cost can be achieved by replacing the potentially multiple fractional flow subpaths with a single path that incurs the same recombination penalty. We can select any flow subpath from <italic>u</italic> to <italic>ν</italic> and assign its edge variables to 1. Edge variables on edges used on the flow from <italic>u</italic> to <italic>ν</italic> and not on this selected path are set to 0.</p></sec></sec></sec><sec id="S9" sec-type="results"><label>5</label><title>Results</title><sec id="S10"><title>Implementation Details</title><p id="P65">We implemented our ILP and IQP solutions in C++ using Gurobi (v11.0.2) solver. We refer to our software as PHI (<bold>P</bold>angenome-based <bold>H</bold>aplotype <bold>I</bold>nference). The user can provide a pangenome reference as either a graph (GFA format) or as a list of phased variants (VCF format). Given short-read or long-read sequencing data of either a haploid or a homozygous genome, PHI outputs the haplotype sequence associated with the optimal inferred path from the graph in FASTA format.</p><p id="P66">Given a set of reads, we compute (<italic>w, k</italic>) window minimizers [<xref ref-type="bibr" rid="R30">30</xref>] for identifying our <italic>hits</italic> (Definition 2). By default, <italic>w</italic> = 25 and <italic>k</italic> = 31. These minimizers correspond to the set <inline-formula><mml:math id="M88"><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> in Problem 1. Computing minimizer matches between two strings is faster than computing minimizer matches on a pangenome graph. For this reason, we find minimizer matches between reads and the sequences spelled by all the haplotype paths in the graph. This means <italic>hits</italic>(<italic>r</italic>) includes only those subpaths that are completely contained in some haplotype path in <italic>G</italic><sub><italic>E</italic></sub> (Definition 2). This restriction to <italic>hits</italic>(<italic>r</italic>) also prevents us from needing to perform the additional edge splitting step described in <xref ref-type="sec" rid="S7">Section 4.1</xref>. We used recombination penalty <italic>c</italic> = 100, this value was chosen empirically. We ran all our experiments on AMD EPYC 7763 processors with 512 GB RAM. We used 32 threads in all experiments.</p></sec><sec id="S11"><title>Datasets</title><p id="P67">We evaluated our algorithm by estimating MHC sequences of five haplotypes (APD, DBB, MANN, QBL, SSTO) from homozygous human cell lines. Recently, Houwaart <italic>et al</italic>. [<xref ref-type="bibr" rid="R16">16</xref>,<xref ref-type="bibr" rid="R32">32</xref>] published complete assemblies of these MHC sequences using long and short-read sequencing. The average length of these assemblies is 4.99 Mbp. We downloaded the five short-read sequencing datasets available from this study. To evaluate our algorithm using varying sequencing coverage, we down-sampled each short-read dataset to obtain coverage of 0.1×, 0.5×, 1×, 2×, 5×, and 10. We also used the full datasets for evaluation (coverage 12.9 − 18.2×). We used the complete assemblies of five MHC haplotypes as ground-truth to evaluate the accuracy of our estimated sequences. To quantify the accuracy, we measured edit distance between each estimated sequence and the corresponding ground-truth sequence.</p><p id="P68">We built a haplotype-resolved pangenome graph of 49 complete MHC sequences [<xref ref-type="bibr" rid="R19">19</xref>] using Minigraph-Cactus [<xref ref-type="bibr" rid="R15">15</xref>]. These sequences were extracted from phased assemblies of 24 diploid human samples [<xref ref-type="bibr" rid="R22">22</xref>] and the CHM13 reference [<xref ref-type="bibr" rid="R27">27</xref>]. Using Minigraph-Cactus, we obtained the pangenome reference in a VCF format file. We subjected this file to further simplification steps<sup><xref ref-type="fn" rid="FN1">1</xref></sup> to ensure compatibility with various tools. We show sequence similarity statistics between the complete MHC assemblies of five haplotypes (APD, DBB, MANN, QBL, SSTO) and the 49 pangenome reference haplotypes in <xref ref-type="supplementary-material" rid="SD1">Appendix Table 1</xref>.</p></sec><sec id="S12"><title>Other Methods</title><p id="P69">We compared PHI with two existing pangenome-based genotyping tools - (i) VG (v1.60) [<xref ref-type="bibr" rid="R35">35</xref>] and (ii) PanGenie (v3.1) [<xref ref-type="bibr" rid="R9">9</xref>]. VG supports sampling of relevant haplotypes from a pangenome graph by comparing <italic>k</italic>-mer counts in the reads and <italic>k</italic>-mers of a reference haplotype. The selection of haplotypes is done locally in fixed-length non-overlapping blocks. Recombinations may be introduced to create contiguous haplotypes across the blocks. The number of samples can be specified by the user. Accordingly, VG’s haplotype sampling feature can be adapted for haplotype sequence estimation by simply setting the number of desired samples to one. Next, PanGenie supports short-read genotyping using a haplotype-resolved pangenome graph. PanGenie uses a hidden Markov model, which is similar to the standard Li and Stephens model [<xref ref-type="bibr" rid="R21">21</xref>]. PanGenie compares <italic>k</italic>-mer counts in the reads with the <italic>k</italic>-mers present in the graph to compute genotype likelihoods. PanGenie exhibited better genotyping accuracy and speed than other genotyping tools [<xref ref-type="bibr" rid="R9">9</xref>]. Our sequencing datasets are derived from homozygous cell lines, therefore we ignored the heterozygous genotype calls made by PanGenie (<xref ref-type="supplementary-material" rid="SD1">Appendix Table 3</xref>). We incorporated PanGenie’s predicted genotypes in the reference sequence to obtain the haplotype sequence. We list our commands to run PHI, VG and PanGenie in <xref ref-type="supplementary-material" rid="SD1">Appendix Table 2</xref>.</p></sec><sec id="S13"><title>Genotyping performance</title><p id="P70">We evaluated PHI, VG and PanGenie methods in their ability to infer the MHC sequences from short read datasets of varying coverage (see <xref ref-type="fig" rid="F3">Figure 3</xref>). Using low coverage datasets (0.1 − 2×), PHI exhibits significantly higher accuracy. VG and PanGenie methods may not be suitable for low-coverage sequencing. For example, the distribution of <italic>k</italic>-mer counts at low coverage can be unreliable. Distinguishing <italic>k</italic>-mers originating from unique versus repetitive regions, as required by PanGenie and VG, is also challenging at low-coverage. Using coverage of 5× or more, the results of VG and PHI are comparable. PanGenie also produces comparable results using full datasets. We note that the integer programming (IQP) approach used in PHI requires more time and memory compared to the methods used in VG and PanGenie. PHI used up to 1.5 hours and 137 GB RAM in a single experiment. In contrast, VG and PanGenie required &lt; 5 minutes and &lt; 50 GB memory. It may be possible to optimize PHI by incorporating efficient heuristics. We show detailed performance statistics for PHI, including its runtime and memory usage in <xref ref-type="supplementary-material" rid="SD1">Appendix Table 4</xref>.</p></sec><sec id="S14"><title>Effect of our optimizations</title><p id="P71">In PHI, we implemented both ILP-based and IQP-based solutions to solve the optimization problem. Using either solution, Gurobi solves Problem 1 to optimality. We benchmarked our ILP and IQP solutions to compare their runtime and memory-usage (see <xref ref-type="fig" rid="F4">Figure 4</xref>). On low-coverage datasets (0.1−1×), the runtimes are comparable. At higher coverage, the IQP solution runs faster, which is likely due to fewer string-hit constraints used (<xref ref-type="sec" rid="S8">Section 4.2</xref>). Although, it requires approximately 1.5 times more memory. This may be because Gurobi requires additional storage to handle quadratic constraints. Accordingly, while using PHI, the user can choose between ILP and IQP using a command line argument based on the available memory. If no choice is provided, the IQP solution is used by default. We also evaluated the advantage of relaxing edge variables to continuous values (Lemma 4) by comparing it to another version of our code where we set the edge variables to be discrete. Relaxation of variables deceases runtime of the IQP solution by a factor of 1.6 on average (<xref ref-type="supplementary-material" rid="SD1">Appendix Figure 2</xref>). Not much effect on the runtime is observed in the ILP solution (<xref ref-type="supplementary-material" rid="SD1">Appendix Figure 3</xref>).</p></sec><sec id="S15"><title>Impact of graph expansion with the addition of more genomes</title><p id="P72">We evaluated the impact of pangenome graph expansion on PHI’s genotyping accuracy as well as runtime. To do this, we created five versions of our pangenome graph, each containing an increasing number of reference haplotypes, added progressively. The first graph comprises a single diploid sample (chosen randomly from 24 diploid samples) plus CHM13 reference, therefore, it has three reference haplotypes in total. The second graph includes two more diploid samples (chosen randomly from the remaining 23), therefore, it has seven reference haplotypes in total. Similarly, third, fourth and fifth graphs contain 13, 25 and 49 reference haplotypes, respectively. The fifth graph is equivalent to the graph used in previous experiments as well. This results in five different graphs that have 3, 7, 13, 25, and 49 reference haplotypes respectively.</p><p id="P73">We repeated our experiments with full short-read datasets using these five graphs and present results in <xref ref-type="fig" rid="F5">Figure 5</xref>. We observe that edit distances between the estimated sequences and the ground truth sequences decrease with the increasing number of reference haplotypes. This is expected because more haplotypes are available to choose from when we compute our inferred path in the graph. We also observe an increase in runtime and memory usage. Runtime appears to increase superlinearly and memory appears to increase linearly with the number of reference haplotypes. This is because the size of expanded graph and the number of minimizer matches increase leading to more variables and constraints in our integer program.</p></sec></sec><sec id="S16" sec-type="discussion"><label>6</label><title>Discussion</title><p id="P74">Genotyping using pangenome graphs is equivalent to finding a walk in the graph that contains the sample’s variants [<xref ref-type="bibr" rid="R28">28</xref>]. If the sample is diploid, this becomes equivalent to finding a pair of paths. Drawing inspiration from this idea, we proposed a rigorous framework to infer a path through the graph, such that the sequence spelled by the path is consistent with the sequencing data in terms of the shared <italic>k</italic>-mers between them, while permitting a limited number of recombinations in the path, each incurring a fixed penalty. This optimization problem requires considering all possible paths in the graph. We proved that this problem is NP-Hard and subsequently gave efficient integer programming solutions. As part of our methodology, we introduced the expanded graph data structure on which we could compute an appropriate <italic>st</italic>-flow of 1. Experimental results demonstrate the advantage of the proposed ILP/IQP approaches for accurate genome inference, especially with low-coverage data (coverage 0.1−1×). Thus, our algorithm can facilitate affordable genotyping and association studies of complex and repeat-rich regions of the genome.</p><p id="P75">Although our approach is currently tailored to haploid samples, it could generalize to diploid samples. This may be accomplished by finding an <italic>st</italic>-flow of 2 through the expanded graph and modifying some constraints. How well this approach genotypes and phases the genome would be interesting to explore. Another limitation of this work is that we do not capture uncertainty. For example, there may be multiple inferred paths with minimum cost. Lastly, pangenome graphs are expected to grow in the number of genomes, therefore, scaling the current approach to a large number of haplotype paths may be important. We leave these extensions to future work.</p></sec><sec sec-type="supplementary-material" id="SM"><title>Supplementary Material</title><supplementary-material content-type="local-data" id="SD1"><label>Appendix</label><media xlink:href="EMS199765-supplement-Appendix.pdf" mimetype="application" mime-subtype="pdf" id="d62aAcDbB" position="anchor"/></supplementary-material></sec></body><back><ack id="S17"><title>Acknowledgements</title><p>This research is funded in part by the DBT/Wellcome Trust India Alliance Fellowship (grant number IA/I/23/2/506979), the Intel India Research Fellowship, the National Institutes of Health of the USA (NIH-NIAID U01 AI090905), and the Jürgen Manchot Foundation. We utilized computing resources available at the Indian Institute of Science and the U.S. National Energy Research Scientific Computing Center.</p></ack><fn-group><fn id="FN1"><label>1</label><p id="P76"><ext-link ext-link-type="uri" xlink:href="https://github.com/eblerjana/genotyping-pipelines/tree/main/prepare-vcf-MC">https://github.com/eblerjana/genotyping-pipelines/tree/main/prepare-vcf-MC</ext-link>
</p></fn></fn-group><ref-list><ref id="R1"><label>1</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Baaijens</surname><given-names>JA</given-names></name><name><surname>Bonizzoni</surname><given-names>P</given-names></name><name><surname>Boucher</surname><given-names>C</given-names></name><name><surname>Della Vedova</surname><given-names>G</given-names></name><name><surname>Pirola</surname><given-names>Y</given-names></name><name><surname>Rizzi</surname><given-names>R</given-names></name><name><surname>Sirén</surname><given-names>J</given-names></name></person-group><article-title>Computational graph pangenomics: a tutorial on data structures and their applications</article-title><source>Natural Computing</source><year>2022</year><fpage>1</fpage><lpage>28</lpage><pub-id pub-id-type="pmcid">PMC10038355</pub-id><pub-id pub-id-type="pmid">36969737</pub-id><pub-id pub-id-type="doi">10.1007/s11047-022-09882-6</pub-id></element-citation></ref><ref id="R2"><label>2</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bradbury</surname><given-names>PJ</given-names></name><name><surname>Casstevens</surname><given-names>T</given-names></name><name><surname>Jensen</surname><given-names>SE</given-names></name><name><surname>Johnson</surname><given-names>L</given-names></name><name><surname>Miller</surname><given-names>Z</given-names></name><name><surname>Monier</surname><given-names>B</given-names></name><name><surname>Romay</surname><given-names>M</given-names></name><name><surname>Song</surname><given-names>B</given-names></name><name><surname>Buckler</surname><given-names>ES</given-names></name></person-group><article-title>The practical haplotype graph, a platform for storing and using pangenomes for imputation</article-title><source>Bioinformatics</source><year>2022</year><volume>38</volume><issue>15</issue><fpage>3698</fpage><lpage>3702</lpage><pub-id pub-id-type="pmcid">PMC9344836</pub-id><pub-id pub-id-type="pmid">35748708</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btac410</pub-id></element-citation></ref><ref id="R3"><label>3</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chandra</surname><given-names>G</given-names></name><name><surname>Gibney</surname><given-names>D</given-names></name><name><surname>Jain</surname><given-names>C</given-names></name></person-group><article-title>Haplotype-aware sequence alignment to pangenome graphs</article-title><source>Genome Research</source><year>2024</year><volume>34</volume><issue>9</issue><fpage>1265</fpage><lpage>1275</lpage><pub-id pub-id-type="pmcid">PMC11529843</pub-id><pub-id pub-id-type="pmid">39013594</pub-id><pub-id pub-id-type="doi">10.1101/gr.279143.124</pub-id></element-citation></ref><ref id="R4"><label>4</label><element-citation publication-type="journal"><article-title>Computational Pan-Genomics Consortiumml: Computational pan-genomics: status, promises and challenges</article-title><source>Briefings in bioinformatics</source><year>2018</year><volume>19</volume><issue>1</issue><fpage>118</fpage><lpage>135</lpage><pub-id pub-id-type="pmcid">PMC5862344</pub-id><pub-id pub-id-type="pmid">27769991</pub-id><pub-id pub-id-type="doi">10.1093/bib/bbw089</pub-id></element-citation></ref><ref id="R5"><label>5</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Davies</surname><given-names>RW</given-names></name><name><surname>Kucka</surname><given-names>M</given-names></name><name><surname>Su</surname><given-names>D</given-names></name><etal/></person-group><article-title>Rapid genotype imputation from sequence with reference panels</article-title><source>Nature Genetics</source><year>2021</year><month>Jun</month><volume>53</volume><issue>7</issue><fpage>1104</fpage><lpage>1111</lpage><pub-id pub-id-type="pmcid">PMC7611184</pub-id><pub-id pub-id-type="pmid">34083788</pub-id><pub-id pub-id-type="doi">10.1038/s41588-021-00877-0</pub-id></element-citation></ref><ref id="R6"><label>6</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dilthey</surname><given-names>A</given-names></name><name><surname>Cox</surname><given-names>C</given-names></name><name><surname>Iqbal</surname><given-names>Z</given-names></name><name><surname>Nelson</surname><given-names>MR</given-names></name><name><surname>McVean</surname><given-names>G</given-names></name></person-group><article-title>Improved genome inference in the MHC using a population reference graph</article-title><source>Nature genetics</source><year>2015</year><volume>47</volume><issue>6</issue><fpage>682</fpage><lpage>688</lpage><pub-id pub-id-type="pmcid">PMC4449272</pub-id><pub-id pub-id-type="pmid">25915597</pub-id><pub-id pub-id-type="doi">10.1038/ng.3257</pub-id></element-citation></ref><ref id="R7"><label>7</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dilthey</surname><given-names>AT</given-names></name></person-group><article-title>State-of-the-art genome inference in the human MHC</article-title><source>The International Journal of Biochemistry &amp; Cell Biology</source><year>2021</year><volume>131</volume><elocation-id>105882</elocation-id><pub-id pub-id-type="pmid">33189874</pub-id></element-citation></ref><ref id="R8"><label>8</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ebert</surname><given-names>P</given-names></name><name><surname>Audano</surname><given-names>PA</given-names></name><etal/></person-group><article-title>Haplotype-resolved diverse human genomes and integrated analysis of structural variation</article-title><source>Science</source><year>2021</year><month>Apr</month><volume>372</volume><issue>6537</issue><pub-id pub-id-type="pmcid">PMC8026704</pub-id><pub-id pub-id-type="pmid">33632895</pub-id><pub-id pub-id-type="doi">10.1126/science.abf7117</pub-id></element-citation></ref><ref id="R9"><label>9</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ebler</surname><given-names>J</given-names></name><name><surname>Ebert</surname><given-names>P</given-names></name><name><surname>Clarke</surname><given-names>WE</given-names></name><name><surname>Rausch</surname><given-names>T</given-names></name><name><surname>Audano</surname><given-names>PA</given-names></name><name><surname>Houwaart</surname><given-names>T</given-names></name><name><surname>Mao</surname><given-names>Y</given-names></name><name><surname>Korbel</surname><given-names>JO</given-names></name><name><surname>Eichler</surname><given-names>EE</given-names></name><name><surname>Zody</surname><given-names>MC</given-names></name><etal/></person-group><article-title>Pangenome-based genome inference allows efficient and accurate genotyping across a wide spectrum of variant classes</article-title><source>Nature genetics</source><year>2022</year><volume>54</volume><issue>4</issue><fpage>518</fpage><lpage>525</lpage><pub-id pub-id-type="pmcid">PMC9005351</pub-id><pub-id pub-id-type="pmid">35410384</pub-id><pub-id pub-id-type="doi">10.1038/s41588-022-01043-w</pub-id></element-citation></ref><ref id="R10"><label>10</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Eggertsson</surname><given-names>HP</given-names></name><name><surname>Jonsson</surname><given-names>H</given-names></name><name><surname>Kristmundsdottir</surname><given-names>S</given-names></name><etal/></person-group><article-title>Graphtyper enables population-scale genotyping using pangenome graphs</article-title><source>Nature genetics</source><year>2017</year><volume>49</volume><issue>11</issue><fpage>1654</fpage><lpage>1660</lpage><pub-id pub-id-type="pmid">28945251</pub-id></element-citation></ref><ref id="R11"><label>11</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gao</surname><given-names>Y</given-names></name><name><surname>Yang</surname><given-names>X</given-names></name><name><surname>Chen</surname><given-names>H</given-names></name><name><surname>Tan</surname><given-names>X</given-names></name><name><surname>Yang</surname><given-names>Z</given-names></name><name><surname>Deng</surname><given-names>L</given-names></name><name><surname>Wang</surname><given-names>B</given-names></name><name><surname>Kong</surname><given-names>S</given-names></name><name><surname>Li</surname><given-names>S</given-names></name><name><surname>Cui</surname><given-names>Y</given-names></name><etal/></person-group><article-title>A pangenome reference of 36 chinese populations</article-title><source>Nature</source><year>2023</year><volume>619</volume><issue>7968</issue><fpage>112</fpage><lpage>121</lpage><pub-id pub-id-type="pmcid">PMC10322713</pub-id><pub-id pub-id-type="pmid">37316654</pub-id><pub-id pub-id-type="doi">10.1038/s41586-023-06173-7</pub-id></element-citation></ref><ref id="R12"><label>12</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Grytten</surname><given-names>I</given-names></name><name><surname>Dagestad Rand</surname><given-names>K</given-names></name><name><surname>Sandve</surname><given-names>GK</given-names></name></person-group><article-title>Kage: Fast alignment-free graph-based genotyping of SNPs and short indels</article-title><source>Genome Biology</source><year>2022</year><volume>23</volume><issue>1</issue><fpage>209</fpage><pub-id pub-id-type="pmcid">PMC9531401</pub-id><pub-id pub-id-type="pmid">36195962</pub-id><pub-id pub-id-type="doi">10.1186/s13059-022-02771-2</pub-id></element-citation></ref><ref id="R13"><label>13</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Harris</surname><given-names>L</given-names></name><name><surname>McDonagh</surname><given-names>EM</given-names></name><name><surname>Zhang</surname><given-names>X</given-names></name><name><surname>Fawcett</surname><given-names>K</given-names></name><name><surname>Foreman</surname><given-names>A</given-names></name><name><surname>Daneck</surname><given-names>P</given-names></name><name><surname>Sergouniotis</surname><given-names>PI</given-names></name><name><surname>Parkinson</surname><given-names>H</given-names></name><name><surname>Mazzarotto</surname><given-names>F</given-names></name><name><surname>Inouye</surname><given-names>M</given-names></name><etal/></person-group><article-title>Genome-wide association testing beyond SNPs</article-title><source>Nature Reviews Genetics</source><year>2024</year><fpage>1</fpage><lpage>15</lpage><pub-id pub-id-type="pmid">39375560</pub-id></element-citation></ref><ref id="R14"><label>14</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hickey</surname><given-names>G</given-names></name><name><surname>Heller</surname><given-names>D</given-names></name><name><surname>Monlong</surname><given-names>J</given-names></name><name><surname>Sibbesen</surname><given-names>JA</given-names></name><name><surname>Sirén</surname><given-names>J</given-names></name><name><surname>Eizenga</surname><given-names>J</given-names></name><name><surname>Dawson</surname><given-names>ET</given-names></name><name><surname>Garrison</surname><given-names>E</given-names></name><name><surname>Novak</surname><given-names>AM</given-names></name><name><surname>Paten</surname><given-names>B</given-names></name></person-group><article-title>Genotyping structural variants in pangenome graphs using the vg toolkit</article-title><source>Genome biology</source><year>2020</year><volume>21</volume><fpage>1</fpage><lpage>17</lpage><pub-id pub-id-type="pmcid">PMC7017486</pub-id><pub-id pub-id-type="pmid">32051000</pub-id><pub-id pub-id-type="doi">10.1186/s13059-020-1941-7</pub-id></element-citation></ref><ref id="R15"><label>15</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hickey</surname><given-names>G</given-names></name><name><surname>Monlong</surname><given-names>J</given-names></name><name><surname>Ebler</surname><given-names>J</given-names></name><name><surname>Novak</surname><given-names>AM</given-names></name><name><surname>Eizenga</surname><given-names>JM</given-names></name><name><surname>Gao</surname><given-names>Y</given-names></name><name><surname>Marschall</surname><given-names>T</given-names></name><name><surname>Li</surname><given-names>H</given-names></name><name><surname>Paten</surname><given-names>B</given-names></name></person-group><article-title>Pangenome graph construction from genome alignments with minigraph-cactus</article-title><source>Nature Biotechnology</source><year>2023</year><fpage>1</fpage><lpage>11</lpage><pub-id pub-id-type="pmcid">PMC10638906</pub-id><pub-id pub-id-type="pmid">37165083</pub-id><pub-id pub-id-type="doi">10.1038/s41587-023-01793-w</pub-id></element-citation></ref><ref id="R16"><label>16</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Houwaart</surname><given-names>T</given-names></name><name><surname>Scholz</surname><given-names>S</given-names></name><name><surname>Pollock</surname><given-names>NR</given-names></name><etal/></person-group><article-title>Complete sequences of six major histocompatibility complex haplotypes, including all the major MHC class II structures</article-title><source>HLA</source><year>2023</year><month>Mar</month><volume>102</volume><issue>1</issue><fpage>28</fpage><lpage>43</lpage><pub-id pub-id-type="pmcid">PMC10986641</pub-id><pub-id pub-id-type="pmid">36932816</pub-id><pub-id pub-id-type="doi">10.1111/tan.15020</pub-id></element-citation></ref><ref id="R17"><label>17</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jain</surname><given-names>C</given-names></name><name><surname>Tavakoli</surname><given-names>N</given-names></name><name><surname>Aluru</surname><given-names>S</given-names></name></person-group><article-title>A variant selection framework for genome graphs</article-title><source>Bioinformatics</source><year>2021</year><volume>37</volume><supplement>Supplement_1</supplement><fpage>i460</fpage><lpage>i467</lpage><pub-id pub-id-type="pmcid">PMC8336592</pub-id><pub-id pub-id-type="pmid">34252945</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btab302</pub-id></element-citation></ref><ref id="R18"><label>18</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Letcher</surname><given-names>B</given-names></name><name><surname>Hunt</surname><given-names>M</given-names></name><name><surname>Iqbal</surname><given-names>Z</given-names></name></person-group><article-title>Gramtools enables multiscale variation analysis with genome graphs</article-title><source>Genome biology</source><year>2021</year><volume>22</volume><fpage>1</fpage><lpage>27</lpage><pub-id pub-id-type="pmcid">PMC8420074</pub-id><pub-id pub-id-type="pmid">34488837</pub-id><pub-id pub-id-type="doi">10.1186/s13059-021-02474-0</pub-id></element-citation></ref><ref id="R19"><label>19</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H</given-names></name></person-group><article-title>Sample graphs and sequences for testing sequence-to-graph alignment</article-title><year>2022</year><pub-id pub-id-type="doi">10.5281/zenodo.6617246</pub-id></element-citation></ref><ref id="R20"><label>20</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>JH</given-names></name><name><surname>Mazur</surname><given-names>CA</given-names></name><name><surname>Berisa</surname><given-names>T</given-names></name><name><surname>Pickrell</surname><given-names>JK</given-names></name></person-group><article-title>Low-pass sequencing increases the power of GWAS and decreases measurement error of polygenic risk scores compared to genotyping arrays</article-title><source>Genome research</source><year>2021</year><volume>31</volume><issue>4</issue><fpage>529</fpage><lpage>537</lpage><pub-id pub-id-type="pmcid">PMC8015847</pub-id><pub-id pub-id-type="pmid">33536225</pub-id><pub-id pub-id-type="doi">10.1101/gr.266486.120</pub-id></element-citation></ref><ref id="R21"><label>21</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>N</given-names></name><name><surname>Stephens</surname><given-names>M</given-names></name></person-group><article-title>Modeling linkage disequilibrium and identifying recombination hotspots using single-nucleotide polymorphism data</article-title><source>Genetics</source><year>2003</year><volume>165</volume><issue>4</issue><fpage>2213</fpage><lpage>2233</lpage><pub-id pub-id-type="pmcid">PMC1462870</pub-id><pub-id pub-id-type="pmid">14704198</pub-id><pub-id pub-id-type="doi">10.1093/genetics/165.4.2213</pub-id></element-citation></ref><ref id="R22"><label>22</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Liao</surname><given-names>WW</given-names></name><name><surname>Asri</surname><given-names>M</given-names></name><name><surname>Ebler</surname><given-names>J</given-names></name><name><surname>Doerr</surname><given-names>D</given-names></name><name><surname>Haukness</surname><given-names>M</given-names></name><name><surname>Hickey</surname><given-names>G</given-names></name><name><surname>Lu</surname><given-names>S</given-names></name><name><surname>Lucas</surname><given-names>JK</given-names></name><name><surname>Monlong</surname><given-names>J</given-names></name><name><surname>Abel</surname><given-names>HJ</given-names></name><etal/></person-group><article-title>A draft human pangenome reference</article-title><source>Nature</source><year>2023</year><volume>617</volume><issue>7960</issue><fpage>312</fpage><lpage>324</lpage><pub-id pub-id-type="pmcid">PMC10172123</pub-id><pub-id pub-id-type="pmid">37165242</pub-id><pub-id pub-id-type="doi">10.1038/s41586-023-05896-x</pub-id></element-citation></ref><ref id="R23"><label>23</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mahmoud</surname><given-names>M</given-names></name><name><surname>Gobet</surname><given-names>N</given-names></name><name><surname>Cruz-Dávalos</surname><given-names>DI</given-names></name><name><surname>Mounier</surname><given-names>N</given-names></name><name><surname>Dessimoz</surname><given-names>C</given-names></name><name><surname>Sedlazeck</surname><given-names>FJ</given-names></name></person-group><article-title>Structural variant calling: the long and the short of it</article-title><source>Genome biology</source><year>2019</year><volume>20</volume><fpage>1</fpage><lpage>14</lpage><pub-id pub-id-type="pmcid">PMC6868818</pub-id><pub-id pub-id-type="pmid">31747936</pub-id><pub-id pub-id-type="doi">10.1186/s13059-019-1828-7</pub-id></element-citation></ref><ref id="R24"><label>24</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Martin</surname><given-names>AR</given-names></name><name><surname>Atkinson</surname><given-names>EG</given-names></name><name><surname>Chapman</surname><given-names>SB</given-names></name><name><surname>Stevenson</surname><given-names>A</given-names></name><name><surname>Stroud</surname><given-names>RE</given-names></name><name><surname>Abebe</surname><given-names>T</given-names></name><name><surname>Akena</surname><given-names>D</given-names></name><name><surname>Alemayehu</surname><given-names>M</given-names></name><name><surname>Ashaba</surname><given-names>FK</given-names></name><name><surname>Atwoli</surname><given-names>L</given-names></name><etal/></person-group><article-title>Low-coverage sequencing cost-effectively detects known and novel variation in underrepresented populations</article-title><source>The American Journal of Human Genetics</source><year>2021</year><volume>108</volume><issue>4</issue><fpage>656</fpage><lpage>668</lpage><pub-id pub-id-type="pmcid">PMC8059370</pub-id><pub-id pub-id-type="pmid">33770507</pub-id><pub-id pub-id-type="doi">10.1016/j.ajhg.2021.03.012</pub-id></element-citation></ref><ref id="R25"><label>25</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mun</surname><given-names>T</given-names></name><name><surname>Vaddadi</surname><given-names>NK</given-names></name><name><surname>Langmead</surname><given-names>B</given-names></name></person-group><article-title>Pangenomic genotyping with the marker array</article-title><source>Algorithms for Molecular Biology</source><year>2023</year><volume>18</volume><issue>1</issue><fpage>2</fpage><pub-id pub-id-type="pmcid">PMC10161648</pub-id><pub-id pub-id-type="pmid">37147657</pub-id><pub-id pub-id-type="doi">10.1186/s13015-023-00225-3</pub-id></element-citation></ref><ref id="R26"><label>26</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mustafa</surname><given-names>H</given-names></name><name><surname>Karasikov</surname><given-names>M</given-names></name><name><surname>Mansouri Ghiasi</surname><given-names>N</given-names></name><name><surname>Rätsch</surname><given-names>G</given-names></name><name><surname>Kahles</surname><given-names>A</given-names></name></person-group><article-title>Label-guided seed-chain-extend alignment on annotated de bruijn graphs</article-title><source>Bioinformatics</source><year>2024</year><volume>40</volume><supplement>Supplement_1</supplement><fpage>i337</fpage><lpage>i346</lpage><pub-id pub-id-type="pmcid">PMC11211850</pub-id><pub-id pub-id-type="pmid">38940164</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btae226</pub-id></element-citation></ref><ref id="R27"><label>27</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nurk</surname><given-names>S</given-names></name><name><surname>Koren</surname><given-names>S</given-names></name><name><surname>Rhie</surname><given-names>A</given-names></name><name><surname>Rautiainen</surname><given-names>M</given-names></name><etal/></person-group><article-title>The complete sequence of a human genome</article-title><source>Science</source><year>2022</year><month>apr</month><volume>376</volume><issue>6588</issue><fpage>44</fpage><lpage>53</lpage><pub-id pub-id-type="pmcid">PMC9186530</pub-id><pub-id pub-id-type="pmid">35357919</pub-id><pub-id pub-id-type="doi">10.1126/science.abj6987</pub-id></element-citation></ref><ref id="R28"><label>28</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Paten</surname><given-names>B</given-names></name><name><surname>Novak</surname><given-names>AM</given-names></name><name><surname>Eizenga</surname><given-names>JM</given-names></name><name><surname>Garrison</surname><given-names>E</given-names></name></person-group><article-title>Genome graphs and the evolution of genome inference</article-title><source>Genome research</source><year>2017</year><volume>27</volume><issue>5</issue><fpage>665</fpage><lpage>676</lpage><pub-id pub-id-type="pmcid">PMC5411762</pub-id><pub-id pub-id-type="pmid">28360232</pub-id><pub-id pub-id-type="doi">10.1101/gr.214155.116</pub-id></element-citation></ref><ref id="R29"><label>29</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pritt</surname><given-names>J</given-names></name><name><surname>Chen</surname><given-names>NC</given-names></name><name><surname>Langmead</surname><given-names>B</given-names></name></person-group><article-title>Forge: prioritizing variants for graph genomes</article-title><source>Genome biology</source><year>2018</year><volume>19</volume><issue>1</issue><fpage>1</fpage><lpage>16</lpage><pub-id pub-id-type="pmcid">PMC6296055</pub-id><pub-id pub-id-type="pmid">30558649</pub-id><pub-id pub-id-type="doi">10.1186/s13059-018-1595-x</pub-id></element-citation></ref><ref id="R30"><label>30</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Roberts</surname><given-names>M</given-names></name><name><surname>Hayes</surname><given-names>W</given-names></name><name><surname>Hunt</surname><given-names>BR</given-names></name><name><surname>Mount</surname><given-names>SM</given-names></name><name><surname>Yorke</surname><given-names>JA</given-names></name></person-group><article-title>Reducing storage requirements for biological sequence comparison</article-title><source>Bioinformatics</source><year>2004</year><month>jul</month><volume>20</volume><issue>18</issue><fpage>3363</fpage><lpage>3369</lpage><pub-id pub-id-type="pmid">15256412</pub-id></element-citation></ref><ref id="R31"><label>31</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rubinacci</surname><given-names>S</given-names></name><name><surname>Ribeiro</surname><given-names>DM</given-names></name><etal/></person-group><article-title>Efficient phasing and imputation of low-coverage sequencing data using large reference panels</article-title><source>Nature Genetics</source><year>2021</year><month>Jan</month><volume>53</volume><issue>1</issue><fpage>120</fpage><lpage>126</lpage><pub-id pub-id-type="pmid">33414550</pub-id></element-citation></ref><ref id="R32"><label>32</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Scholz</surname><given-names>S</given-names></name></person-group><article-title>Complete sequences of six major histocompatibility complex haplotypes rev2</article-title><year>2024</year><pub-id pub-id-type="doi">10.5281/ZENODO.13889311</pub-id></element-citation></ref><ref id="R33"><label>33</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sibbesen</surname><given-names>JA</given-names></name><name><surname>Maretty</surname><given-names>L</given-names></name><name><surname>Consortium</surname><given-names>DG</given-names></name><name><surname>Krogh</surname><given-names>A</given-names></name></person-group><article-title>Accurate genotyping across variant classes and lengths using variant graphs</article-title><source>Nature genetics</source><year>2018</year><volume>50</volume><issue>7</issue><fpage>1054</fpage><lpage>1059</lpage><pub-id pub-id-type="pmid">29915429</pub-id></element-citation></ref><ref id="R34"><label>34</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sirén</surname><given-names>J</given-names></name><name><surname>Monlong</surname><given-names>J</given-names></name><name><surname>Chang</surname><given-names>X</given-names></name><name><surname>Novak</surname><given-names>AM</given-names></name><name><surname>Eizenga</surname><given-names>JM</given-names></name><name><surname>Markello</surname><given-names>C</given-names></name><name><surname>Sibbesen</surname><given-names>JA</given-names></name><name><surname>Hickey</surname><given-names>G</given-names></name><name><surname>Chang</surname><given-names>PC</given-names></name><name><surname>Carroll</surname><given-names>A</given-names></name><etal/></person-group><article-title>Pangenomics enables genotyping of known structural variants in 5202 diverse genomes</article-title><source>Science</source><year>2021</year><volume>374</volume><issue>6574</issue><elocation-id>abg8871</elocation-id><pub-id pub-id-type="pmcid">PMC9365333</pub-id><pub-id pub-id-type="pmid">34914532</pub-id><pub-id pub-id-type="doi">10.1126/science.abg8871</pub-id></element-citation></ref><ref id="R35"><label>35</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sirén</surname><given-names>J</given-names></name><name><surname>Eskandar</surname><given-names>P</given-names></name><name><surname>Ungaro</surname><given-names>MT</given-names></name><etal/></person-group><article-title>Personalized pangenome references</article-title><source>Nature Methods</source><year>2024</year><month>Sep</month><pub-id pub-id-type="pmid">39261641</pub-id></element-citation></ref><ref id="R36"><label>36</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Smith</surname><given-names>TP</given-names></name><name><surname>Bickhart</surname><given-names>DM</given-names></name><name><surname>Boichard</surname><given-names>D</given-names></name><name><surname>Chamberlain</surname><given-names>AJ</given-names></name><name><surname>Djikeng</surname><given-names>A</given-names></name><name><surname>Jiang</surname><given-names>Y</given-names></name><name><surname>Low</surname><given-names>WY</given-names></name><name><surname>Pausch</surname><given-names>H</given-names></name><name><surname>Demyda-Peyrás</surname><given-names>S</given-names></name><name><surname>Prendergast</surname><given-names>J</given-names></name><etal/></person-group><article-title>The bovine pangenome consortiumml: democratizing production and accessibility of genome assemblies for global cattle breeds and other bovine species</article-title><source>Genome biology</source><year>2023</year><volume>24</volume><issue>1</issue><fpage>139</fpage><pub-id pub-id-type="pmcid">PMC10278262</pub-id><pub-id pub-id-type="pmid">37337218</pub-id><pub-id pub-id-type="doi">10.1186/s13059-023-02975-0</pub-id></element-citation></ref><ref id="R37"><label>37</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Tavakoli</surname><given-names>N</given-names></name><name><surname>Gibney</surname><given-names>D</given-names></name><name><surname>Aluru</surname><given-names>S</given-names></name></person-group><source>Haplotype-aware variant selection for genome graphs</source><conf-name>Proceedings of the 13th ACM International Conference on Bioinformatics, Computational Biology and Health Informatics</conf-name><year>2022</year><fpage>1</fpage><lpage>9</lpage></element-citation></ref><ref id="R38"><label>38</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Vaddadi</surname><given-names>K</given-names></name><name><surname>Mun</surname><given-names>T</given-names></name><name><surname>Langmead</surname><given-names>B</given-names></name></person-group><article-title>Minimizing reference bias with an impute-first approach</article-title><year>2023</year><month>Dec</month><pub-id pub-id-type="doi">10.1101/2023.11.30.568362</pub-id></element-citation></ref></ref-list></back><floats-group><fig id="F1" position="float"><label>Fig. 1</label><caption><title>A simple illustration of an haplotype-resolved pangenome graph with two haplotype paths highlighted in pink and blue colors. An inferred path with a single recombination is shown as a dashed line.</title></caption><graphic xlink:href="EMS199765-f001"/></fig><fig id="F2" position="float"><label>Fig. 2</label><caption><p>(A) A pangenome graph with four haplotype paths <italic>h</italic><sub>1</sub>, <italic>h</italic><sub>2</sub>, <italic>h</italic><sub>3</sub> and <italic>h</italic><sub>4</sub>. Set of haplotype paths passing through a vertex is listed below each vertex. (B) The corresponding expanded graph which includes four disjoint paths, one for each haplotype path. The recombination edges are shown in purple, these edges have a weight of <italic>c</italic>. We consider only the useful recombinations (Lemma 3). The edges which are not recombination edges in the expanded graph have a weight of 0. (C) The corresponding optimized expanded graph.</p></caption><graphic xlink:href="EMS199765-f002"/></fig><fig id="F3" position="float"><label>Fig. 3</label><caption><p>Accuracy of haplotype sequences estimated by PHI, VG and PanGenie using short reads from MHC sequences of five haplotypes (APD, DBB, MANN, QBL, SSTO). The x-axes indicate the coverage of short-read data. The y-axes indicate the edit distance between the estimate haplotype sequence and the ground-truth sequence on a logarithmic scale.</p></caption><graphic xlink:href="EMS199765-f003"/></fig><fig id="F4" position="float"><label>Fig. 4</label><caption><title>Performance comparison between the ILP and IQP solutions implemented in PHI. We compared their runtime and memory-usage using short-read sequencing datasets sampled from five haplotypes.</title></caption><graphic xlink:href="EMS199765-f004"/></fig><fig id="F5" position="float"><label>Fig. 5</label><caption><p>Assessement of PHI’s performance with the increasing number of genomes in pangenome graph. The left figure shows the accuracy in terms of edit distance between the output sequences and ground-truth sequences. The middle and right figure show the runtime and memory-usage respectively.</p></caption><graphic xlink:href="EMS199765-f005"/></fig></floats-group></article>