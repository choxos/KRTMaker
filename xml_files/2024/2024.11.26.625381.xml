<!DOCTYPE article
 PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2 20190208//EN" "JATS-archivearticle1.dtd">
<article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="preprint"><?all-math-mml yes?><?use-mml?><?origin ukpmcpa?><front><journal-meta><journal-id journal-id-type="nlm-ta">bioRxiv</journal-id><journal-title-group><journal-title>bioRxiv : the preprint server for biology</journal-title></journal-title-group><issn pub-type="epub">2692-8205</issn></journal-meta><article-meta><article-id pub-id-type="manuscript">EMS201624</article-id><article-id pub-id-type="doi">10.1101/2024.11.26.625381</article-id><article-id pub-id-type="archive">PPR948250</article-id><article-version-alternatives><article-version article-version-type="status">preprint</article-version><article-version article-version-type="number">2</article-version></article-version-alternatives><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Bayesian phylodynamic inference of multi-type population trajectories using genomic data</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Vaughan</surname><given-names>Timothy G.</given-names></name><xref ref-type="aff" rid="A1">1</xref><xref ref-type="aff" rid="A2">2</xref><xref ref-type="corresp" rid="CR1">*</xref></contrib><contrib contrib-type="author"><name><surname>Stadler</surname><given-names>Tanja</given-names></name><xref ref-type="aff" rid="A1">1</xref><xref ref-type="aff" rid="A2">2</xref></contrib></contrib-group><aff id="A1"><label>1</label>Department of Biosystems Science and Engineering, <institution-wrap><institution-id institution-id-type="ror">https://ror.org/05a28rw58</institution-id><institution>ETH Zurich</institution></institution-wrap>, <addr-line>Klingelbergstrasse 48</addr-line>, <postal-code>4056</postal-code>, <city>Basel</city>, <country country="CH">Switzerland</country></aff><aff id="A2"><label>2</label><institution-wrap><institution-id institution-id-type="ror">https://ror.org/002n09z45</institution-id><institution>Swiss Institute of Bioinformatics</institution></institution-wrap>, <addr-line>Quartier Sorge - Bâtiment Amphipôle</addr-line>, <postal-code>1015</postal-code>, <city>Lausanne</city>, <country country="CH">Switzerland</country></aff><author-notes><corresp id="CR1">
<label>*</label>Corresponding author. <email>timothy.vaughan@bsse.ethz.ch</email>
</corresp></author-notes><pub-date pub-type="nihms-submitted"><day>03</day><month>12</month><year>2024</year></pub-date><pub-date pub-type="preprint"><day>01</day><month>12</month><year>2024</year></pub-date><permissions><ali:free_to_read/><license><ali:license_ref>https://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p>This work is licensed under a <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 International license</ext-link>.</license-p></license></permissions><abstract><p id="P1">Phylodynamic methods provide a coherent framework for the inference of population parameters directly from genetic data. They are an important tool for understanding both the spread of epidemics as well as long-term macroevolutionary trends in speciation and extinction. In particular, phylodynamic methods based on multi-type birth-death models have been used to infer the evolution of discrete traits, the movement of individuals or pathogens between geographic locations or host types, and the transition of infected individuals between disease stages. In these models, population heterogeneity is treated by assigning individuals to different discrete types. Typically, methods which allow inference of parameters under multi-type birth-death models integrate over the possible birth-death trajectories (i.e. the type-specific population size functions) to reduce the computational demands of the inference. As a result, it has not been possible to use these methods to directly infer the dynamics of trait-specific population sizes, infected host counts or other such demographic quantities. In this paper we present a method which infers these multi-type trajectories with minimal additional computational cost beyond that of existing methods. We demonstrate the practicality of our approach by applying it to a previously-published set of MERS-CoV genomes, inferring the numbers of human and camel cases through time, together with the number and timing of spillovers from the camel reservoir. This application highlights the multi-type population trajectory’s ability to elucidate properties of the population which are not directly ancestral to its sampled members.</p></abstract><kwd-group><kwd>phylodynamics</kwd><kwd>particle filter</kwd><kwd>epidemiology</kwd><kwd>Bayesian phylogenetics</kwd></kwd-group></article-meta></front><body><sec id="S1" sec-type="intro"><title>Introduction</title><p id="P2">The strong connections between genetic diversity and population dynamics play an integral role in our ability to use modern sequencing technology to draw conclusions about populations at every scale. The field of phylodynamics offers a growing number of model-based approaches to inferring population dynamics from sequence data by way of phylogenies. While the term “phylodynamics” was originally conceived in the context of molecular epidemiology (<xref ref-type="bibr" rid="R18">Grenfell et al. 2004</xref>), the techniques which are now described as phylodynamic methods are applied in a diverse range of contexts from macroevolution (<xref ref-type="bibr" rid="R15">Gavryushkina et al. 2017</xref>) to developmental biology (<xref ref-type="bibr" rid="R39">Stadler et al. 2021</xref>).</p><p id="P3">One widely-used family of phylodynamic models are the so-called birth-death models (<xref ref-type="bibr" rid="R23">Kendall 1948</xref>) under which the population dynamics are the result of a stochastic process parameterized by individual birth and death rates. Combined with an explicit sampling process (<xref ref-type="bibr" rid="R37">Stadler 2010</xref>) and time-dependent rate shifts (<xref ref-type="bibr" rid="R38">Stadler et al. 2012</xref>), these models enable genomic inference of the past dynamics of critical epidemiological and macroevolutionary parameters, such as transmission rates, speciation rates, and migration rates.</p><p id="P4">Beyond these parameters, the dynamics of the populations themselves are potentially of interest. In epidemics these correspond to incidence and prevalence dynamics, while for macroevolutionary applications of birth-death models they correspond to species richness trajectories. Such trajectories, which summarize the dynamics of all members of a population—including those which do not belong to the phylogenetic tree relating sampled individuals—are an implicit component of all birth-death models which, at their most basic level, provide a generative description for the dynamics of a whole population as a function of rate parameters. While earlier birth-death phylodynamic inference approaches (<xref ref-type="bibr" rid="R38">Stadler et al. 2012</xref>; <xref ref-type="bibr" rid="R21">Heath et al. 2014</xref>; <xref ref-type="bibr" rid="R14">Gavryushkina et al. 2014</xref>) implicitly averaged over these trajectories for reasons of computational efficiency or because these trajectories were not of explicit interest, recent methods allow population trajectories to be jointly inferred with the birth-death parameters. For instance, the approach of <xref ref-type="bibr" rid="R41">Vaughan et al. (2019)</xref> employs a particle marginal Metropolis-Hastings algorithm to jointly infer parameters and population trajectories. This approach can be applied to nonlinear birth-death models (e.g. epidemiological models where pathogen transmission rates depend on the availability of susceptible individuals), but can be extremely demanding computationally due to its reliance on simulation-based particle filtering for likelihood evaluation at every step of the Markov chain Monte Carlo (MCMC) inference algorithm. In contrast, the more recent approach of <xref ref-type="bibr" rid="R31">Manceau et al. (2021)</xref> is specific to linear birth-death models where individual birth and death rates lack density dependence, but allows for more tractable inference of population history via numerical integration of sets of differential equations.</p><p id="P5">The above models and methods focus on neutrally-evolving, unstructured populations, where birth, death and sampling rates are the same for all co-existing individuals; assumptions which are inappropriate for many applications. This has spurred the development of a sub-family of birth-death phylodynamic models which allow population members to be associated with a discrete type whose two (<xref ref-type="bibr" rid="R30">Maddison et al. 2007</xref>) or more (<xref ref-type="bibr" rid="R12">FitzJohn 2012</xref>; <xref ref-type="bibr" rid="R26">Kühnert et al. 2016</xref>) values may influence the birth, death and sampling rates to which they are subject. These models have been applied extensively to the study of trait-dependent speciation and extinction (eg. <xref ref-type="bibr" rid="R30">Maddison et al. 2007</xref>; <xref ref-type="bibr" rid="R12">FitzJohn 2012</xref>; <xref ref-type="bibr" rid="R34">Rabosky 2014</xref>; <xref ref-type="bibr" rid="R2">Barido-Sottani et al. 2020</xref>) and to epidemiological questions, where the discrete types have been used to model the transmission dynamics of pathogens across locations (eg. <xref ref-type="bibr" rid="R33">Nadeau et al. 2021</xref>), host types (eg. <xref ref-type="bibr" rid="R17">Grear et al. 2017</xref>; <xref ref-type="bibr" rid="R19">Guinat et al. 2022</xref>), and pathogen strains (eg. <xref ref-type="bibr" rid="R35">Rasmussen and Stadler 2019</xref>; <xref ref-type="bibr" rid="R27">Loiseau et al. 2023</xref>).</p><p id="P6">While the applications are diverse, for existing multi-type inference methods (eg. <xref ref-type="bibr" rid="R12">FitzJohn 2012</xref>; <xref ref-type="bibr" rid="R26">Kühnert et al. 2016</xref>) only the parameters defining the type-dependent rates of birth, death and sampling of individuals, together with the phylogenetic tree relating samples can be readily inferred. This is despite the fact that—like their single-type counterparts—the multi-type birth-death models which underpin such methods describe the generation of full multi-type population dynamics, not only the phylogenetic tree relating the sampled sequences. As in the single-type case, multi-type birth-death phylodynamics inference methods implicitly average over this richer picture of the population dynamics.</p><p id="P7">Here we present an approach to performing joint Bayesian inference of the phylogenetic tree, multi-type birth-death model parameters, and ancestral lineage types, together with type-specific population trajectories. Importantly, our approach allows this inference to be done with only a relatively small increase in the computational run time of the inference relative to that of the existing multi-type phylodynamic approaches of <xref ref-type="bibr" rid="R26">Kühnert et al. (2016)</xref> and <xref ref-type="bibr" rid="R36">Scire et al. (2022)</xref>. This is accomplished by “mapping” trajectories onto combinations of trees and parameters already sampled using existing MCMC techniques. The approach and its implementation are directly applicable to all models considered by <xref ref-type="bibr" rid="R26">Kühnert et al. (2016)</xref> and <xref ref-type="bibr" rid="R36">Scire et al. (2022)</xref>, namely linear multi-type birth-death models with a defined but otherwise arbitrary number of types, where type-specific birth, death, migration and sampling parameters can change through time in a piecewise-constant fashion. After introducing the approach and demonstrating the correctness of its implementation, we apply the method to a published set of MERS-CoV genomes curated by <xref ref-type="bibr" rid="R10">Dudas et al. (2018)</xref> belonging to the 2012–2015 MERS outbreak in the Arabian Peninsula. These authors used the results of a coalescent-based ancestral-state inference method (<xref ref-type="bibr" rid="R40">Vaughan et al. 2014</xref>) to deduce the presence of camel to human spillover events in those lineages ancestral to the observed pathogen genomes. Our results demonstrate how the new approach enables Bayesian phylodynamic inference of host-specific prevalence dynamics, which yields information about the number and timing of camel to human spillover events in the broader population from which the samples were collected.</p></sec><sec id="S2"><title>New Approaches</title><p id="P8">Our approach to inferring multi-type trajectories from sequence data is based on the combination of a multi-type extension to our particle filtering approach (<xref ref-type="bibr" rid="R41">Vaughan et al. 2019</xref>) with a stochastic mapping approach to the placement of ancestral type changes on a tree. In this section, we describe the model assumptions, outline the new inference approach, and derive the necessary extensions to the particle filter. (While mathematical notation in this section is explained as it is introduced, <xref ref-type="table" rid="T1">table 1</xref> provides a quick reference for the most important notation employed.)</p><sec id="S3"><title>Linear birth-death phylodynamic models</title><p id="P9">We focus here on a population composed of a discrete set of individuals, each belonging to one of a fixed number <italic>d</italic> of distinct types. This multi-type system is assumed to evolve according to a stochastic linear birth-death branching process parameterized by rates which in general vary through time in a piecewise-constant way. The process begins at time 0 with a single individual, whose type <italic>i</italic><sub>0</sub> ∈ [1, <italic>d</italic>] is chosen randomly with probability <inline-formula><mml:math id="M1"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. The process continues for a duration 𝒯. While variations of this process have been described by numerous authors over the years, we here consider the specific form described by <xref ref-type="bibr" rid="R26">Kühnert et al. (2016)</xref> and by <xref ref-type="bibr" rid="R36">Scire et al. (2022)</xref>.</p><p id="P10">We introduce the notation <italic>X</italic><sub><italic>i</italic></sub> to represent an individual of type <italic>i</italic>. Additionally, we use <italic>Y</italic><sub><italic>i</italic></sub> to represent a sample of type <italic>i</italic>. The individuals comprising the population are subject to the following named reactions: <list list-type="bullet" id="L1"><list-item><p id="P11">Birth<sub><italic>ij</italic></sub>: An individual of type <italic>i</italic> gives birth to a new individual of type <italic>j</italic> with rate <italic>λ</italic><sub><italic>ij</italic></sub>:</p></list-item></list>
</p><p id="P12"><disp-formula id="FD1"><mml:math id="M2"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.2em"/></mml:mrow></mml:mover><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></disp-formula></p><list list-type="bullet" id="L2"><list-item><p id="P13">Death<sub><italic>i</italic></sub>: An individual of type <italic>i</italic> dies at rate <italic>µ</italic><sub><italic>i</italic></sub>:</p></list-item></list><p id="P14"><disp-formula id="FD2"><mml:math id="M3"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mspace width="0.2em"/></mml:mrow></mml:mover><mml:mn>0</mml:mn></mml:mrow></mml:math></disp-formula></p><list list-type="bullet" id="L3"><list-item><p id="P15">Migration<sub><italic>ij</italic></sub> : An individual of type <italic>i</italic> changes type to <italic>j</italic> at rate <italic>m</italic><sub><italic>ij</italic></sub>:</p></list-item></list><p id="P16"><disp-formula id="FD3"><mml:math id="M4"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.2em"/></mml:mrow></mml:mover><mml:msub><mml:mi>X</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></disp-formula></p><list list-type="bullet" id="L4"><list-item><p id="P17">SampR<sub><italic>ij</italic></sub> : An individual of type <italic>i</italic> is sampled and removed at rate <italic>ψ</italic><sub><italic>i</italic></sub><italic>r</italic><sub><italic>i</italic></sub>, where <italic>ψ</italic><sub><italic>i</italic></sub> represents the overall sampling rate and <italic>r</italic><sub><italic>i</italic></sub> is the probability of removal on sampling:</p></list-item></list><p id="P18"><disp-formula id="FD4"><mml:math id="M5"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mspace width="0.2em"/></mml:mrow></mml:mover><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></disp-formula></p><list list-type="bullet" id="L5"><list-item><p id="P19">SampNR<sub><italic>ij</italic></sub> : An individual of type <italic>i</italic> is sampled without removal at rate <italic>ψ</italic><sub><italic>i</italic></sub>(1 − <italic>r</italic><sub><italic>i</italic></sub>):</p></list-item></list><p id="P20"><disp-formula id="FD5"><mml:math id="M6"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mspace width="0.2em"/></mml:mrow></mml:mover><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></disp-formula></p><p id="P21">The linearity of the process is reflected in the dependence of each of these reactions on only a single reagent. The rates associated with these reactions indicate the probability per unit time of individual <italic>X</italic><sub><italic>i</italic></sub> undergoing the corresponding reaction at time <italic>t</italic>. Each of the rate parameters <italic>λ</italic><sub><italic>ij</italic></sub>, <italic>µ</italic><sub><italic>i</italic></sub>, … are assumed to be piecewise-constant functions of time, meaning that the process is in general time-inhomogeneous. (For clarity of exposition we do not explicitly indicate this time dependence in what follows; rather the derivatives and integrals where these functions appear should all be understood to be defined in a piecewise fashion.)</p><p id="P22">In addition to these continuous reactions, the population is subject to synchronous sampling at the times <inline-formula><mml:math id="M7"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:mrow><mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. At a given synchronous sampling time <inline-formula><mml:math id="M8"><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mi>v</mml:mi><mml:mi>c</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, every extant lineage of type <italic>i</italic> is sampled with probability <inline-formula><mml:math id="M9"><mml:mrow><mml:msubsup><mml:mi>ρ</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, and each sampled lineage is removed from the population with probability <inline-formula><mml:math id="M10"><mml:mrow><mml:msubsup><mml:mi>r</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>. The resulting reactions are given the parameterized name SyncSample <inline-formula><mml:math id="M11"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mover accent="true"><mml:mi>n</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mtext>R</mml:mtext></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>n</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mi>N</mml:mi><mml:mi>R</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="M12"><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mtext>R</mml:mtext></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M13"><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mtext>NR</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> are respectively the number of removed and non-removed samples of type <italic>i</italic> produced by the reaction.</p><p id="P23">A complete realization of the multi-type birth-death process would be a full, binary tree recording the ancestral relationships between all events and individuals that appeared in the system. However, we are only interested those properties of a given realization about which we can reasonably learn using genetic data associated with a subsample of the population. We thus consider only these elements: the population trajectory ℰ, the times and types of all samples 𝒮, the phylogenetic tree 𝒯 relating these typed and timed samples, and the phylogenetic tree whose edges are annotated with ancestral types, 𝒯<sub><italic>C</italic></sub>. (In the parlance of <xref ref-type="bibr" rid="R26">Kühnert et al. (2016)</xref>, we refer to 𝒯 as a <italic>tip-typed tree</italic> and 𝒯<sub><italic>C</italic></sub> as an <italic>edge-typed tree</italic>.) In other words, we ignore the topology of those parts of the full tree not directly ancestral to the samples 𝒮.</p><p id="P24">The population trajectory ℰ is composed of the starting population type <italic>i</italic><sub>0</sub> together with a sequence of events <italic>ϵ</italic><sub>1</sub>, <italic>ϵ</italic><sub>2</sub>, …. An event <italic>ϵ</italic> consists of a time, <italic>t</italic><sub><italic>ϵ</italic></sub>, and the corresponding reaction, <italic>r</italic><sub><italic>ϵ</italic></sub>. (Synchronous sampling reactions always produce an event in the event sequence, even when no samples are generated.)</p><p id="P25">For what follows it will be helpful to define several vector-valued piecewise-constant auxiliary functions of time which can be uniquely derived from ℰ and 𝒯<sub><italic>C</italic></sub>. First among these is <inline-formula><mml:math id="M14"><mml:mrow><mml:mover accent="true"><mml:mi>N</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, whose elements <italic>N</italic><sub><italic>i</italic></sub>(<italic>t</italic>) represent the size of the population associated with type <italic>i</italic> at time <italic>t</italic>. Secondly we define <inline-formula><mml:math id="M15"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, whose <italic>i</italic><sup>th</sup> element represents the cumulative number of samples collected from sub-population <italic>i</italic> up until time <italic>t</italic>. Finally, we define the function <inline-formula><mml:math id="M16"><mml:mrow><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, whose elements represent the number of extant lineages of 𝒯<sub><italic>C</italic></sub> associated with each type at time <italic>t</italic>. These auxiliary functions, together with corresponding tip-typed 𝒯 and edge-typed 𝒯<sub><italic>C</italic></sub> trees, are illustrated in <xref ref-type="fig" rid="F1">Figure 1</xref>.</p></sec><sec id="S4"><title>Bayesian inference strategy</title><p id="P26">Our focus here is on jointly inferring population dynamics ℰ and the edge-typed tree 𝒯<sub><italic>C</italic></sub> from the number, timing and types of samples 𝒮 produced by the population together with a genetic sequence alignment 𝒜. The sequences are assumed to have evolved down the reconstructed tree 𝒯 according to a standard Markovian nucleotide substitution model. That is, we seek to characterize the distribution <italic>P</italic> (ℰ, 𝒯<sub><italic>C</italic></sub>, <italic>σ, η</italic>|𝒜, 𝒮), where <italic>σ</italic> and <italic>η</italic> are the parameters of the nucleotide substitution and birth-death models, respectively.</p><p id="P27">One approach to this problem would be to use Markov chain Monte Carlo (MCMC) directly to jointly sample the edge-typed tree 𝒯<sub><italic>C</italic></sub>, the multi-type population trajectory ℰ, and all model parameters. However, this approach would likely prove impractical due to the extremely large dimensionality of the state space. (While MCMC algorithms for directly sampling edge-typed trees under a variety of models are in use (eg. <xref ref-type="bibr" rid="R4">Beerli and Felsenstein 2001</xref>; <xref ref-type="bibr" rid="R11">Ewing et al. 2004</xref>; <xref ref-type="bibr" rid="R40">Vaughan et al. 2014</xref>; <xref ref-type="bibr" rid="R26">Kühnert et al. 2016</xref>), they are known to suffer from convergence issues which motivate the use of alternative schemes (<xref ref-type="bibr" rid="R22">Hey and Nielsen 2007</xref>; <xref ref-type="bibr" rid="R7">De Maio et al. 2015</xref>; <xref ref-type="bibr" rid="R32">Müller et al. 2018</xref>). The addition of the highly-dimensional trajectory variable ℰ to this space would likely make this problem worse.)</p><p id="P28">Instead, the approach that we advocate here is analogous to the general approach championed by <xref ref-type="bibr" rid="R22">Hey and Nielsen (2007)</xref> to improve the efficiency of inference of migration rates under the isolation-migration coalescent model, and applied more recently to the inference of ancestral types under the multi-type birth-death model by <xref ref-type="bibr" rid="R13">Freyman and Höhna (2018)</xref>. This approach still involves MCMC, but to sample a marginalized posterior of lower dimensionality that includes neither ancestral types nor population trajectories. Instead, these latent variables are independently drawn from their conditional probability distributions given the MCMC-sampled tip-typed trees and birth-death parameters.</p><p id="P29">The following factorization of the joint posterior is central to our approach: <disp-formula id="FD6"><label>(1)</label><mml:math id="M17"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>ℰ</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mo>𝒯</mml:mo><mml:mi>C</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>η</mml:mo><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo>∣</mml:mo><mml:mo>𝒜</mml:mo><mml:mo>,</mml:mo><mml:mo>𝒮</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mtext>P</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>ℰ</mml:mo><mml:mo>∣</mml:mo><mml:msub><mml:mo>𝒯</mml:mo><mml:mtext>C</mml:mtext></mml:msub><mml:mo>,</mml:mo><mml:mo>η</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mtext>P</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>𝒯</mml:mo><mml:mtext>C</mml:mtext></mml:msub><mml:mo>∣</mml:mo><mml:mo>𝒯</mml:mo><mml:mo>,</mml:mo><mml:mo>η</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mtext>P</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>𝒯</mml:mo><mml:mo>,</mml:mo><mml:mo>η</mml:mo><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo>∣</mml:mo><mml:mo>𝒜</mml:mo><mml:mo>,</mml:mo><mml:mo>𝒮</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P30">The approach involves three steps, each corresponding to a term in the factorization:</p><list list-type="bullet" id="L6"><list-item><p id="P31">sampling 𝒯, <italic>η, σ</italic> ~ <italic>P</italic> (𝒯, <italic>η, σ</italic>|𝒜, 𝒮) using the MCMC algorithm described and used by <xref ref-type="bibr" rid="R26">Kühnert et al. (2016)</xref> and <xref ref-type="bibr" rid="R36">Scire et al. (2022)</xref>,</p></list-item><list-item><p id="P32">sampling 𝒯<sub><italic>C</italic></sub> ~ <italic>P</italic> (𝒯<sub><italic>C</italic></sub> |𝒯, <italic>η</italic>) using a stochastic mapping algorithm for ancestral state reconstruction similar to the approach developed by <xref ref-type="bibr" rid="R13">Freyman and Höhna (2018)</xref>, and</p></list-item><list-item><p id="P33">sampling ℰ ~ <italic>P</italic> (ℰ|𝒯<sub><italic>C</italic></sub>, <italic>η</italic>) using a particle filtering algorithm.</p></list-item></list><p id="P34">These three steps allow us to produce trajectories, phylogenies and parameters sampled from the joint distribution given by <xref ref-type="disp-formula" rid="FD1">Eq. 1</xref>. On their own, the trajectories are distributed according to their marginal posterior <italic>P</italic> (ℰ|𝒜, 𝒮).</p><p id="P35">A key advantage of this approach is that the second and third steps need only be applied to a small subset of the samples of 𝒯, <italic>η, σ</italic> produced by the MCMC chain. This is because the sequence of states produced by MCMC algorithms are usually highly autocorrelated, meaning that a small subset of the states visited can characterize the target distribution as well as the full chain. While there is no well-defined consensus on the number of “effectively independent” samples required to produce useful characterizations of phylodynamic posteriors (although for parameter estimates it is common to treat values above 200 as acceptable), it is clear that this number is usually many orders of magnitude smaller than the number of iterations needed by the MCMC algorithm to achieve it. Thus, the ability to apply steps 2 and 3 to this subset means that these components of the approach are almost cost-free relative to the far larger computational cost of the MCMC portion of the algorithm.</p><p id="P36">As stated above, the MCMC algorithm we use for step 1 above is precisely that presented by <xref ref-type="bibr" rid="R26">Kühnert et al. (2016)</xref>, thus we do not describe it further here. The following sections describe the algorithms used to sample from the conditional distributions required for steps 2 and 3.</p></sec><sec id="S5"><title>Stochastic mapping of ancestral types</title><p id="P37">Here we describe the approach we take to generating samples from <italic>P</italic> (𝒯<sub><italic>C</italic></sub> |𝒯, <italic>η</italic>) which is based on the same principle as the approach described by <xref ref-type="bibr" rid="R13">Freyman and Höhna (2018)</xref>, namely a post-order (leaves to root) numerical integration followed by a pre-order (root to leaves) lineage type simulation. We present here a succinct derivation of this algorithm in terms of an appropriately conditioned master equation for the type change process along tree edges. This algorithm is applicable to all trees which can be produced by the multi-type birth-death-sampling model of <xref ref-type="bibr" rid="R26">Kühnert et al. (2016)</xref> and <xref ref-type="bibr" rid="R36">Scire et al. (2022</xref>)—including non-ultrametric trees and trees with sampled ancestor nodes (<xref ref-type="bibr" rid="R14">Gavryushkina et al. 2014</xref>).</p><p id="P38">Consider a particular time <italic>t</italic> on a particular edge <italic>e</italic> of the tree 𝒯. We use this point (<italic>e, t</italic>) to divide the tree into two components: 𝒯<sub>↓</sub>(<italic>e, t</italic>) being the clade descending from this point, and 𝒯<sub>↑</sub>(<italic>e, t</italic>) being the portion of the tree remaining when this clade is removed. By definition, these components are perfectly complementary in the sense that 𝒯 = 𝒯<sub>↓</sub>(<italic>t, e</italic>) ∪ 𝒯<sub>↑</sub>(<italic>e, t</italic>).</p><p id="P39">Defining <italic>V</italic> (<italic>e, t</italic>) to be the (unknown) ancestral type value at (<italic>e, t</italic>), we can express the marginal probability that this trait takes a particular value <italic>i</italic> as <disp-formula id="FD7"><label>(2)</label><mml:math id="M18"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>∣</mml:mo><mml:mo>𝒯</mml:mo><mml:mo>,</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>𝒯</mml:mo><mml:mo>↑</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>∣</mml:mo><mml:mi>η</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>𝒯</mml:mo><mml:mo>↓</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∣</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>η</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>𝒯</mml:mo><mml:mo>∣</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula></p><p id="P40">Noting that <inline-formula><mml:math id="M19"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>𝒯</mml:mo><mml:mo>↓</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∣</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>η</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where <inline-formula><mml:math id="M20"><mml:mrow><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the partial tree probability function considered by <xref ref-type="bibr" rid="R26">Kühnert et al. (2016)</xref>, and using the notation <inline-formula><mml:math id="M21"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>𝒯</mml:mo><mml:mo>↑</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>∣</mml:mo><mml:mi>η</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M22"><mml:mrow><mml:msubsup><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>∣</mml:mo><mml:mo>𝒯</mml:mo><mml:mo>,</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we can write this as <disp-formula id="FD8"><label>(3)</label><mml:math id="M23"><mml:mrow><mml:msubsup><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>Z</mml:mi></mml:mfrac><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P41">where <italic>Z</italic> = <italic>P</italic> (𝒯 |<italic>η</italic>) is the normalization constant.</p><p id="P42">Our goal is to determine a stochastic process which produces realizations of <italic>V</italic> (<italic>e, t</italic>) for every point in the tree. To do this, we use the above expansion to derive the master equation for the marginal ancestral type distribution by directly differentiating this equation: <disp-formula id="FD9"><label>(4)</label><mml:math id="M24"><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>π</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>Z</mml:mi></mml:mfrac><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>h</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p id="P43">As described by <xref ref-type="bibr" rid="R26">Kühnert et al. (2016)</xref> and <xref ref-type="bibr" rid="R36">Scire et al. (2022)</xref>, the time derivative for the partial tree probability <inline-formula><mml:math id="M25"><mml:mrow><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> along an edge is given by the following system of ordinary differential equations (ODEs): <disp-formula id="FD10"><label>(5)</label><mml:math id="M26"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mi>j</mml:mi></mml:munder><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>−</mml:mo><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mi>j</mml:mi></mml:munder><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mi>g</mml:mi><mml:mi>j</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mi>j</mml:mi></mml:munder><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula> where <italic>p</italic><sub><italic>i</italic></sub>(<italic>t</italic>) is the probability that an individual of type <italic>i</italic> alive at time <italic>t</italic> yields no sampled descendants, which follows its own ODE also described by <xref ref-type="bibr" rid="R26">Kühnert et al. (2016)</xref> and <xref ref-type="bibr" rid="R36">Scire et al. (2022)</xref>. (The synchronous sampling probabilities appear only in the boundary conditions of these ODEs, as they do not affect the continuous-time evolution of the tree probabilities.)</p><p id="P44">We now make use of the normalization constraint that <inline-formula><mml:math id="M27"><mml:mrow><mml:mfrac><mml:mi>d</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:msub><mml:mstyle displaystyle="true"><mml:mtext>Σ</mml:mtext></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:msubsup><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mstyle displaystyle="true"><mml:mtext>Σ</mml:mtext></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:msubsup><mml:mover accent="true"><mml:mi>π</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> to give <disp-formula id="FD11"><label>(6)</label><mml:math id="M28"><mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mi>i</mml:mi></mml:munder><mml:msubsup><mml:mover accent="true"><mml:mi>h</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mi>i</mml:mi></mml:munder><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P45">Substituting <xref ref-type="disp-formula" rid="FD5">equation 5</xref> into the right-hand side and performing a change of variables on the summation index, this becomes <disp-formula id="FD12"><label>(7)</label><mml:math id="M29"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mi>i</mml:mi></mml:munder><mml:msubsup><mml:mover accent="true"><mml:mi>h</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mi>i</mml:mi></mml:munder><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mi>j</mml:mi></mml:munder><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>+</mml:mo><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mi>j</mml:mi></mml:munder><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p id="P46">For this equation to hold for arbitrary <inline-formula><mml:math id="M30"><mml:mrow><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the summation kernels must be equal. Thus <disp-formula id="FD13"><label>(8)</label><mml:math id="M31"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msubsup><mml:mover accent="true"><mml:mi>h</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mi>j</mml:mi></mml:munder><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow><mml:mspace width="1.5em"/><mml:mo>+</mml:mo><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mi>j</mml:mi></mml:munder><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p id="P47">Substituting this, together with <xref ref-type="disp-formula" rid="FD5">equation 5</xref> back into <xref ref-type="disp-formula" rid="FD4">equation 4</xref> yields <disp-formula id="FD14"><label>(9)</label><mml:math id="M32"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>π</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>Z</mml:mi></mml:mfrac><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mi>j</mml:mi></mml:munder><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>g</mml:mi><mml:mi>j</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow><mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>g</mml:mi><mml:mi>j</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mi>j</mml:mi></mml:munder><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msubsup><mml:mi>Q</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>π</mml:mi><mml:mi>j</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msubsup><mml:mi>Q</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula> where we have defined <disp-formula id="FD15"><label>(10)</label><mml:math id="M33"><mml:mrow><mml:msubsup><mml:mi>Q</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>g</mml:mi><mml:mi>j</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P48">We thus find that, conditional on the tree and parameter values, the ancestral type evolves down the tree according to a continuous-time Markov process with time-dependent transition rates <inline-formula><mml:math id="M34"><mml:mrow><mml:msubsup><mml:mi>Q</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. (The presence of piecewise-constant variation in the multi-type birth-death rate functions simply induces corresponding piecewise-constant variation in these transition rates.)</p><p id="P49">In addition to changes along edges, state changes can occur at internal nodes when the off-diagonal elements of the rate matrix <italic>λ</italic><sub><italic>ijk</italic></sub> are non-zero. Using simple arguments (see Supplemental Text) we can identify the transition probabilities for state changes at an internal node below edge <italic>e</italic> given a parental type <inline-formula><mml:math id="M35"><mml:mrow><mml:msubsup><mml:mi>W</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mover accent="true"><mml:mi>W</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msubsup><mml:mo>/</mml:mo><mml:msub><mml:mstyle displaystyle="true"><mml:mtext>Σ</mml:mtext></mml:mstyle><mml:mrow><mml:msup><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:msup><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:msubsup><mml:mover accent="true"><mml:mi>W</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:msup><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mi>k</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, where <disp-formula id="FD16"><label>(11)</label><mml:math id="M36"><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>W</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mi>g</mml:mi><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mi>g</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.5em"/><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>≠</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.5em"/><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mspace width="1em"/><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mn>0</mml:mn><mml:mspace width="2.3em"/><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p><p id="P50">Here <italic>t</italic><sub><italic>e</italic></sub> represents the time of the node below edge <italic>e</italic>, while <italic>e</italic><sub><italic>l</italic></sub> and <italic>e</italic><sub><italic>r</italic></sub> represent the left and right child edges of the node.</p><p id="P51">Since we can pre-compute the components of these rates and transition probabilities by numerically solving the differential equations given by <xref ref-type="bibr" rid="R26">Kühnert et al. (2016)</xref>, we can directly sample the state changes by (a) sampling the starting state from its marginal posterior, then (b) simulating this Markov process forwards in time down the tree.</p><p id="P52">Sampling the appropriately conditioned starting state can be done directly by noting that at the start of the root edge <inline-formula><mml:math id="M37"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>𝒯</mml:mo><mml:mo>↑</mml:mo></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>V</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>∣</mml:mo><mml:mi>η</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> reduces to <italic>P</italic> (<italic>V</italic> (<italic>e</italic><sub>0</sub>, 0) = <italic>i</italic>|<italic>η</italic>) = <italic>f</italic><sub><italic>i</italic></sub>, and thus that we can compute the marginal probabilities for each possible starting state <inline-formula><mml:math id="M38"><mml:mrow><mml:msubsup><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:msub><mml:mstyle displaystyle="true"><mml:mtext>Σ</mml:mtext></mml:mstyle><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:msubsup><mml:mi>g</mml:mi><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> directly.</p><p id="P53">Simulating the process and hence drawing a sample from <italic>P</italic> (𝒯<sub><italic>C</italic></sub> |𝒯, <italic>η</italic>) can be done using any algorithm capable of simulating trajectories from a continuous-time Markov chain with time-dependent rates. The approach we use, given as algorithm 1, is a simple extension of the original Stochastic Simulation Algorithm (<xref ref-type="bibr" rid="R16">Gillespie 1976</xref>). <boxed-text id="BX1" position="anchor" content-type="below"><label>Algorithm 1</label><caption><title>Stochastic mapping algorithm. The notation <italic>t</italic><sub><italic>e</italic></sub> represents the time of the youngest node attached to edge <italic>e</italic>, ChildCount(<italic>e</italic>) represents the number of its child edges, Child(<italic>e</italic>) is the single child edge when ChildCount(<italic>e</italic>)=1, and LeftChild(<italic>e</italic>) and RightChild(<italic>e</italic>) are the left and right child edges when ChildCount(<italic>e</italic>)=2.</title></caption><p id="P54">Input</p><p id="P55">     <italic>g</italic><sup><italic>e</italic></sup>(<italic>t</italic>) the partial tree probabilities computed as in <xref ref-type="bibr" rid="R36">Scire et al. (2022)</xref></p><p id="P56">     <italic>p</italic><sub><italic>i</italic></sub>(<italic>t</italic>) the clade non-sampling probabilities computed as in</p><p id="P57">     <xref ref-type="bibr" rid="R36">Scire et al. (2022)</xref></p><p id="P58">     <italic>T</italic> the total process time</p><p id="P59">     <italic>η</italic> the piecewise-constant birth-death model parameters</p><p id="P60">Initialisation</p><p id="P61">     Sample <italic>s</italic><sub>0</sub> from <inline-formula><mml:math id="M39"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>o</mml:mi></mml:msub></mml:mrow></mml:msub><mml:msubsup><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:msub><mml:mstyle displaystyle="true"><mml:mtext>Σ</mml:mtext></mml:mstyle><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mi>f</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:msubsup><mml:mi>g</mml:mi><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for root edge <italic>e</italic><sub>0</sub>.</p><p id="P62">     Call Map(<italic>e</italic><sub>0</sub>,0,<italic>s</italic><sub>0</sub>)</p><p id="P63"><bold>function</bold> Map(e,t,s)</p><p id="P64">     <bold>while</bold> <italic>t &lt; t</italic><sub><italic>e</italic></sub> <bold>do</bold></p><p id="P65">           Sample <italic>u</italic> ~ Unif(0, 1).</p><p id="P66">           Numerically solve <inline-formula><mml:math id="M40"><mml:mrow><mml:mtext>exp</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:msubsup><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∫</mml:mo></mml:mstyle></mml:mrow><mml:mi>t</mml:mi><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msubsup><mml:msub><mml:mstyle displaystyle="true"><mml:mtext>Σ</mml:mtext></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:msubsup><mml:mi>Q</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo>′</mml:mo><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo>′</mml:mo><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>u</mml:mi></mml:mrow></mml:math></inline-formula> for <italic>t</italic><sup>′</sup>.</p><p id="P67">           <bold>if</bold> <italic>t</italic><sup>′</sup> <italic>&gt; t</italic><sub><italic>e</italic></sub> <bold>then</bold> Set <italic>t</italic> ← <italic>t</italic><sub><italic>e</italic></sub>.</p><p id="P68">               <bold>switch</bold> ChildCount(<italic>e</italic>)</p><p id="P69">                    <bold>case</bold> 0</p><p id="P70">                         return</p><p id="P71">                    <bold>case</bold> 1</p><p id="P72">                         Call Map(Child(<italic>e</italic>),<italic>t</italic><sub><italic>e</italic></sub>,s)</p><p id="P73">                    <bold>case</bold> 2</p><p id="P74">                         Sample (<italic>s</italic><sub><italic>l</italic></sub>, <italic>s</italic><sub><italic>r</italic></sub>) according to <inline-formula><mml:math id="M41"><mml:mrow><mml:msubsup><mml:mi>W</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:msub><mml:mi>s</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:msub><mml:mi>s</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow><mml:mi>e</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>.</p><p id="P75">                         Call Map(LeftChild(<italic>e</italic>),<italic>t</italic><sub><italic>e</italic></sub>,<italic>s</italic><sub><italic>l</italic></sub>)</p><p id="P76">                         Call Map(RightChild(<italic>e</italic>),<italic>t</italic><sub><italic>e</italic></sub>,<italic>s</italic><sub><italic>r</italic></sub>)</p><p id="P77">           <bold>else</bold></p><p id="P78">                 Sample <italic>s</italic><sup>′</sup> from <inline-formula><mml:math id="M42"><mml:mrow><mml:msubsup><mml:mi>Q</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:msup><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mi>e</mml:mi></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:msub><mml:mstyle displaystyle="true"><mml:mtext>Σ</mml:mtext></mml:mstyle><mml:mrow><mml:msup><mml:mi>s</mml:mi><mml:mrow><mml:mo>′</mml:mo><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:msubsup><mml:mi>Q</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:msup><mml:mi>s</mml:mi><mml:mrow><mml:mo>′</mml:mo><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:mi>e</mml:mi></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p id="P79">                 Set <italic>t</italic> ← <italic>t</italic><sup>′</sup> and <italic>s</italic> ← <italic>s</italic><sup>′</sup>.</p></boxed-text>
</p></sec><sec id="S6"><title>Importance sampling trajectories</title><p id="P80">While it is straightforward to produce samples of the multi-type trajectories from the unconditioned distribution <italic>P</italic> (ℰ|<italic>η</italic>) through direct stochastic simulation (<xref ref-type="bibr" rid="R16">Gillespie 1976</xref>), our goal is to sample ℰ from the conditional distribution <italic>P</italic> (ℰ|𝒯<sub><italic>C</italic></sub>, <italic>η</italic>). We will bridge this gap using a particle filtering approach that we will present in the next section. Before describing that approach however, we will firstly consider the more fundamental problem of developing an importance sampler for the conditional distribution, with the goal of providing an intuitive basis for understanding the particle filtering algorithm presented in the next section.</p><p id="P81">A naïve importance sampler might use direct simulation to sample an ensemble of <italic>M</italic> ≫ 1 trajectories directly from <italic>P</italic> (ℰ|<italic>η</italic>) and weight each trajectory using the edge-typed tree probability <italic>P</italic> (𝒯<sub><italic>C</italic></sub> |ℰ). However, literal application of this method is not practical, since <italic>P</italic> (𝒯<sub><italic>C</italic></sub> |ℰ <sup>(<italic>m</italic>)</sup>) will be zero for any ℰ <sup>(<italic>m</italic>)</sup> ~ <italic>P</italic> (ℰ|<italic>η</italic>). This is because the tree density is only non-zero when the real-valued times of all events represented on the tree coincide precisely with the times of events in ℰ <sup>(<italic>m</italic>)</sup>.</p><p id="P82">For this reason, we instead simulate trajectories from the modified distribution <italic>P</italic> <sup>∗</sup>(ℰ|<italic>η</italic>). This distribution corresponds to a process similar to <italic>P</italic> (ℰ|<italic>η</italic>) but with the important distinction that all events contained in the edge-typed tree 𝒯<sub><italic>C</italic></sub> occur withm probability 1, and any events that are incompatible with 𝒯<sub><italic>C</italic></sub> are forbidden. Weighting these trajectories with the unnormalized weight function <disp-formula id="FD17"><label>(12)</label><mml:math id="M43"><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℰ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>𝒯</mml:mo><mml:mi>C</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:mi>ℰ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℰ</mml:mi><mml:mo>∣</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mi>P</mml:mi><mml:mo>∗</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>ℰ</mml:mi><mml:mo>∣</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula> produces our desired target distribution, which can be seen by noting that: <disp-formula id="FD18"><mml:math id="M44"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℰ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mi>P</mml:mi><mml:mo>∗</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>ℰ</mml:mi><mml:mo>∣</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∫</mml:mo></mml:mstyle><mml:mi>w</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mi>ℰ</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:msup><mml:mi>P</mml:mi><mml:mo>∗</mml:mo></mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mi>ℰ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>∣</mml:mo><mml:mi>η</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:msup><mml:mi>ℰ</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mo>𝒯</mml:mo><mml:mi>C</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:mi>ℰ</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℰ</mml:mi><mml:mo>∣</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∫</mml:mo></mml:mstyle><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mo>𝒯</mml:mo><mml:mi>C</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:msup><mml:mi>ℰ</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mi>ℰ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>∣</mml:mo><mml:mi>η</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:msup><mml:mi>ℰ</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>ℰ</mml:mi><mml:mo>∣</mml:mo><mml:msub><mml:mo>𝒯</mml:mo><mml:mi>C</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>η</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P83">To compute these weights, we need to specify three distributions: the trajectory probability <italic>P</italic> (ℰ|<italic>η</italic>), the importance trajectory distribution <italic>P</italic> <sup>∗</sup>(ℰ|<italic>η</italic>) and the tree probability <italic>P</italic> (𝒯<sub><italic>C</italic></sub> |ℰ).</p><p id="P84">The trajectory distribution follows directly from the definition of the birth-death process, and can be written <disp-formula id="FD19"><label>(13)</label><mml:math id="M45"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℰ</mml:mi><mml:mo>∣</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mtext>exp</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:msubsup><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∫</mml:mo></mml:mstyle></mml:mrow><mml:mn>0</mml:mn><mml:mi>T</mml:mi></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>A</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∏</mml:mo></mml:mstyle></mml:mrow><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>∈</mml:mo><mml:mi>ℰ</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula> where <italic>R</italic> represents the set of all possible continuous reactions in the model (i.e. excluding synchronous sampling reactions). For such reactions, 𝒜<sub><italic>r</italic></sub>(<italic>t</italic>) is the piecewise-constant propensity of reaction <italic>r</italic> at time <italic>t</italic> (e.g. for <inline-formula><mml:math id="M46"><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mtext>Birth</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, with the temporal dependence stemming from both population size variation and any piecewise-constant variation in rate functions. For synchronous sampling reactions on the other hand, <inline-formula><mml:math id="M47"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mi>v</mml:mi><mml:mi>c</mml:mi></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is the multinomial probability of the particular removed/non-removed synchronous sampling outcome at the sampling time <inline-formula><mml:math id="M48"><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mi>v</mml:mi><mml:mi>c</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, that is: <disp-formula id="FD20"><label>(14)</label><mml:math id="M49"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mtext>SyncSamp</mml:mtext><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mi>n</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>n</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mi>N</mml:mi><mml:mi>R</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mi>v</mml:mi><mml:mi>c</mml:mi></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∏</mml:mo></mml:mstyle></mml:mrow><mml:mi>i</mml:mi></mml:munder><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mi>v</mml:mi><mml:mi>c</mml:mi></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mtext>R</mml:mtext><mml:mo>!</mml:mo><mml:msubsup><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:mi>R</mml:mi></mml:mrow></mml:msubsup><mml:mo>!</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mi>v</mml:mi><mml:mi>c</mml:mi></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo>−</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:mi>R</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>!</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="2.0em"/><mml:mrow><mml:mrow><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mi>v</mml:mi><mml:mi>c</mml:mi></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mi>n</mml:mi><mml:mrow><mml:msub><mml:mtext>R</mml:mtext><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mi>r</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi></mml:msubsup><mml:msubsup><mml:mi>ρ</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mtext>R</mml:mtext></mml:msubsup></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msubsup><mml:mi>r</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:msubsup><mml:mi>ρ</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mtext>NR</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:msup></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p id="P85">In both cases, <italic>r</italic><sub><italic>ϵ</italic></sub> is the reaction involved in event <italic>ϵ</italic>, and <italic>t</italic><sub><italic>ϵ</italic></sub> is the time of that event.</p><p id="P86">The probability of the edge-typed tree can be similarly decomposed: <disp-formula id="FD21"><label>(15)</label><mml:math id="M50"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>𝒯</mml:mo><mml:mi>C</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:mi>ℰ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∏</mml:mo></mml:mstyle></mml:mrow><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>∈</mml:mo><mml:mi>ℰ</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula> where <italic>C</italic> is a normalizing constant and <disp-formula id="FD22"><label>(16)</label><mml:math id="M51"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>∣</mml:mo><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>N</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula> the probability for a reaction <italic>r</italic> to effect a specific instantaneous change in the lineages-through-time function and cumulative sample count function at time <italic>t</italic>. The times <italic>t</italic><sup>−</sup> and <italic>t</italic><sup>+</sup> refer to the times immediately before and after <italic>t</italic>. The functions <inline-formula><mml:math id="M52"><mml:mrow><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M53"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are the lineages-through-time and cumulative sample count functions for 𝒯<sub><italic>C</italic></sub>, and <inline-formula><mml:math id="M54"><mml:mrow><mml:mover accent="true"><mml:mi>N</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the population size function for ℰ—as illustrated in <xref ref-type="fig" rid="F1">Figure 1</xref>.</p><p id="P87">The normalizing constant <italic>C</italic> accounts for the fact that, in general, many unique tree topologies correspond to a given pair of lineages-through-time and cumulative sample count functions. Since the number of compatible topologies affects only the overall normalization of the weight function, it can be safely ignored.</p><p id="P88">The probabilities <italic>f</italic><sub><italic>r</italic></sub>(<italic>t</italic>) are derived by considering the number of ways that lineages belonging to the tree can be involved in a given reaction, and are given below for each of the reactions in our model. (In the following, <inline-formula><mml:math id="M55"><mml:mover accent="true"><mml:mi>i</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> and <inline-formula><mml:math id="M56"><mml:mover accent="true"><mml:mi>j</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> represent unit vectors of dimension <italic>d</italic> where the <italic>i</italic><sup>th</sup> or, respectively, <italic>j</italic><sup>th</sup> element is 1 and all other elements are 0.)</p><list list-type="bullet" id="L7"><list-item><p id="P89">Single-type birth reactions: <disp-formula id="FD23"><label>(17)</label><mml:math id="M57"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mtext>Birth</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:munder></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:munder></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>i</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:munder></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:munder></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mtext>0</mml:mtext></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p></list-item><list-item><p id="P90">Between-type birth reactions: <disp-formula id="FD24"><label>(18)</label><mml:math id="M58"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mtext>Birth</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>j</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>j</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>+</mml:mo><mml:mover accent="true"><mml:mi>i</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mtext>1-</mml:mtext><mml:mfrac><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mtext>0</mml:mtext></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p></list-item><list-item><p id="P91">Migration reactions:<disp-formula id="FD25"><label>(19)</label><mml:math id="M59"><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mtext>Migration</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>j</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>+</mml:mo><mml:mover accent="true"><mml:mi>i</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mtext>0</mml:mtext></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:math></disp-formula></p></list-item><list-item><p id="P92">Death reactions: <disp-formula id="FD26"><label>(20)</label><mml:math id="M60"><mml:mrow><mml:msub><mml:mstyle displaystyle="true"><mml:mi>f</mml:mi></mml:mstyle><mml:mrow><mml:mtext>Death</mml:mtext><mml:mi>i</mml:mi><mml:mtext> </mml:mtext></mml:mrow></mml:msub><mml:mi>i</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mn>1</mml:mn><mml:mspace width="1.5em"/><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mn>0</mml:mn><mml:mspace width="1.5em"/><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p></list-item><list-item><p id="P93">Sampling reactions with removal: <disp-formula id="FD27"><label>(21)</label><mml:math id="M61"><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>a</mml:mi><mml:mi>m</mml:mi><mml:mi>p</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mn>1</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mover accent="true"><mml:mi>i</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>i</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mtext>0</mml:mtext></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:math></disp-formula></p></list-item><list-item><p id="P94">Sampling reactions without removal: <disp-formula id="FD28"><label>(22)</label><mml:math id="M62"><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>a</mml:mi><mml:mi>m</mml:mi><mml:mi>p</mml:mi><mml:mi>N</mml:mi><mml:msub><mml:mi>R</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>i</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mover accent="true"><mml:mi>i</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>i</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:math></disp-formula></p></list-item><list-item><p id="P95">The probability due to synchronous sampling events is a product of hypergeometric distributions for the number of sampled ancestors of each type produced by a synchronous sampling reaction at a given time: <disp-formula id="FD29"><label>(23)</label><mml:math id="M63"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mtext>SyncSamp</mml:mtext><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mover accent="true"><mml:mi>n</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mtext>R</mml:mtext></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>n</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mtext>NR</mml:mtext></mml:mrow></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mtext>Π</mml:mtext><mml:mi>i</mml:mi></mml:msub><mml:mfrac><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:mi>R</mml:mi></mml:mrow></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>A</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:mi>R</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mfrac><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>n</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mi>N</mml:mi><mml:mi>R</mml:mi></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>n</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mtext>R</mml:mtext></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>n</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mi>N</mml:mi><mml:mi>R</mml:mi></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>n</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mtext>R</mml:mtext></mml:msup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mn>0</mml:mn><mml:mspace width="10.8em"/><mml:mtext>otherwise</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p></list-item></list><p id="P96">(Here <inline-formula><mml:math id="M64"><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>A</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>), i.e. the difference between the number of type-<italic>i</italic> samples generated at time <italic>t</italic> and the number of new type-<italic>i</italic> lineages appearing at the same time, represents the number of “sampled ancestors” of type <italic>i</italic> generated by the <inline-formula><mml:math id="M65"><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mtext>NR</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> unremoved samples.)</p><p id="P97">Note that these tree event probabilities are a superset of those used by the particle filtering algorithm presented by <xref ref-type="bibr" rid="R41">Vaughan et al. (2019)</xref>.</p><p id="P98">In order to express the importance distribution, we partition the trajectory ℰ = 𝒰 ∪ 𝒪, where 𝒪 includes only the events occurring at exactly the same time as events on the tree (“observed” events), and 𝒰 contains the remaining (“unobserved”) events. The importance distribution corresponds to a modified birth-death process in which unobserved events occur at rate <italic>A</italic><sub><italic>r</italic></sub>(<italic>t</italic>)<italic>f</italic><sub><italic>r</italic></sub>(<italic>t</italic>), while observed events occur with probability 1 and with a reaction <italic>r</italic><sub><italic>ϵ</italic></sub> chosen with probability <inline-formula><mml:math id="M66"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:msub><mml:mstyle displaystyle="true"><mml:mtext>Σ</mml:mtext></mml:mstyle><mml:mrow><mml:msup><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>∈</mml:mo><mml:mi>R</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:msup><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> from the set <italic>R</italic>(<italic>t</italic><sub><italic>ϵ</italic></sub>) of reactions (including synchronous sampling reactions) compatible with the tree at the observed event time <italic>t</italic><sub><italic>ϵ</italic></sub>. This modified process ensures that (a) only those unobserved events compatible with the tree are included, and that (b) observed events occur with probability 1 and are associated with reactions also compatible with the tree. The probability for a trajectory generated by this process is written: <disp-formula id="FD30"><label>(24)</label><mml:math id="M67"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msup><mml:mi>P</mml:mi><mml:mo>∗</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>ℰ</mml:mi><mml:mo>∣</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mtext>exp</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:msubsup><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∫</mml:mo></mml:mstyle></mml:mrow><mml:mn>0</mml:mn><mml:mi>T</mml:mi></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>A</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>×</mml:mo><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∏</mml:mo></mml:mstyle></mml:mrow><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>∈</mml:mo><mml:mo>𝒰</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∏</mml:mo></mml:mstyle></mml:mrow><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>∈</mml:mo><mml:mo>𝒪</mml:mo></mml:mrow></mml:munder><mml:mfrac><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mstyle displaystyle="true"><mml:mtext>Σ</mml:mtext></mml:mstyle><mml:mrow><mml:msup><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>∈</mml:mo><mml:mi>R</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:msup><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p id="P99">Substituting this, together with the expressions for the tree and trajectory probabilities, into equation (12) yields the importance weight function: <disp-formula id="FD31"><label>(25)</label><mml:math id="M68"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℰ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mtext>exp</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:msubsup><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∫</mml:mo></mml:mstyle></mml:mrow><mml:mn>0</mml:mn><mml:mi>T</mml:mi></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>A</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>×</mml:mo><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∏</mml:mo></mml:mstyle></mml:mrow><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>∈</mml:mo><mml:mo>𝒪</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:munder><mml:msub><mml:mi>A</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p id="P100">One could thus sample trajectories from <italic>P</italic> (ℰ|𝒯<sub><italic>C</italic></sub>, <italic>η</italic>) by drawing a large number of trajectories directly from <italic>P</italic> <sup>∗</sup>(ℰ|<italic>η</italic>), computing their associated weights using <italic>w</italic>(ℰ), then drawing from this weighted distribution. However, since the weights are assigned only once the trajectories have been completely simulated, the weighted distribution will likely include many trajectories with relatively low weights. This will yield weighted ensembles a low effective sample size However, while this importance sampling strategy will produce the correct distribution in the limit of an infinitely large trajectory ensemble, it will likely perform poorly in practice where we are restricted to finite ensembles of trajectories. The reason for this is that trajectories produced by this importance sampler above are only assigned weights once they have been completely simulated, potentially leading to very low effective sample sizes for the weighted ensemble.</p></sec><sec id="S7"><title>Particle filtering algorithm for multi-type trajectories</title><p id="P101">Given these considerations, we therefore employ a widely-used strategy for improving the effective sample size of the weighted ensemble known as particle filtering. (Refer to <xref ref-type="bibr" rid="R6">Cappe et al. (2007)</xref> for a good overview of this approach.) This involves subdividing the single importance sampler above into a number of intermediate importance samplers, with resampling steps in between. This periodic resampling helps keep disparities between trajectory weights in the ensemble manageable.</p><p id="P102">We apply this here by subdividing the trajectory ℰ into portions ℰ<sub>1</sub>, …, ℰ<sub><italic>L</italic></sub>, where each ℰ<sub><italic>l</italic></sub> includes only those trajectory events with times satisfying <italic>t</italic><sub><italic>ϵ</italic></sub> ∈ (<italic>t</italic><sub><italic>l</italic>−1</sub>, <italic>t</italic><sub><italic>l</italic></sub>] and where <italic>t</italic><sub><italic>l</italic></sub> correspond to the times of the <italic>L</italic> = |𝒪| events observed on the tree. We similarly partition the set of unobserved events 𝒰 into 𝒰<sub>1</sub>, …, 𝒰<sub><italic>L</italic></sub>. Since (a) the stochastic process described by the importance distribution <italic>P</italic> <sup>∗</sup>(ℰ|<italic>η</italic>) is Markovian, and (b) the weight function <italic>w</italic>(ℰ) has a simple product form, we can write <disp-formula id="FD32"><label>(26)</label><mml:math id="M69"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msup><mml:mi>P</mml:mi><mml:mo>∗</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>ℰ</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:msub><mml:mi>ℰ</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>η</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mtext>exp</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:msubsup><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∫</mml:mo></mml:mstyle></mml:mrow><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>A</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="2.5em"/><mml:mo>×</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∏</mml:mo></mml:mstyle></mml:mrow><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mo>𝒰</mml:mo><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:munder><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>ϵ</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:msup><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>∈</mml:mo><mml:mi>R</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:munder><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:msup><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula> and <disp-formula id="FD33"><label>(27)</label><mml:math id="M70"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>ℰ</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mtext>exp</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:msubsup><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∫</mml:mo></mml:mstyle></mml:mrow><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>A</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>×</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:munder><mml:msub><mml:mi>A</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula> where we have used <italic>r</italic><sub><italic>l</italic></sub> to refer to the reaction corresponding to the observed event ending interval <italic>l</italic>.</p><p id="P103">Our particle filter involves initializing an ensemble of trajectories (particles) based on the initial type defined by the multi-type tree 𝒯<sub><italic>c</italic></sub> and then alternating between (1) propagating the ensemble to the next interval using stochastic simulation to sample from <italic>P</italic> <sup>∗</sup>(ℰ<sub><italic>l</italic></sub>|ℰ<sub><italic>l</italic>−1</sub>, <italic>η</italic>) defined in Eq. (26), and (2) resampling the ensemble according to the weights <italic>w</italic><sub><italic>l</italic></sub>(ℰ<sub><italic>l</italic></sub>) defined in Eq. (27). Loosely speaking, each propagation step uses importance sampling to characterize the portion of the conditioned distribution associated with the corresponding interval. By applying these smaller importance sampling steps sequentially and interspersing them with resampling steps, the particle filter keeps the variance of the particle weights from becoming unmanageable.</p><p id="P104">The full procedure is described in Alg. (2), and—in the large particle number limit—produces a single multi-type trajectory drawn from the true conditional distribution of trajectories given an edge-typed tree and corresponding multi-type birth-death parameters. This algorithm can be regarded as special case of Algorithm 3 (particle filtering) in <xref ref-type="bibr" rid="R6">Cappe et al. (2007)</xref>. However, as noted in our previous paper (<xref ref-type="bibr" rid="R41">Vaughan et al. 2019</xref>) and discussed recently in more detail by <xref ref-type="bibr" rid="R24">King et al. (2022)</xref>, when applied to such a genealogical process the weighted distribution of trajectories is only interpretable as a true conditional distribution given the tree once the entire tree has been considered.</p></sec></sec><sec id="S8" sec-type="results"><title>Results</title><sec id="S9"><title>Implementation</title><p id="P105">The algorithms described were implemented as an extension to the Bayesian phylogenetic inference platform BEAST 2 (<xref ref-type="bibr" rid="R5">Bouckaert et al. 2019</xref>). Specifically, these algorithms were implemented in the package BDMM-Prime, which is a recent revision of the original BDMM package published by <xref ref-type="bibr" rid="R26">Kühnert et al. (2016)</xref>. Beyond stochastic mapping and multi-type trajectory inference, this package also makes use of efficiency and numerical stability improvements introduced by <xref ref-type="bibr" rid="R36">Scire et al. (2022)</xref> and the analytical single-type functionality of the earlier BDSKY (<xref ref-type="bibr" rid="R38">Stadler et al. 2012</xref>) package, meaning that all analyses possible in these earlier packages are accessible within BDMM-Prime. It also includes an extensive and redesigned graphical interface, making it possible for users to configure more complex analyses compared with the earlier implementations. The new package is free software and is distributed under the GNU General Public License version 3. The source code is available from its GitHub repository (<ext-link ext-link-type="uri" xlink:href="https://github.com/tgvaughan/BDMM-Prime">https://github.com/tgvaughan/BDMM-Prime</ext-link>), and a comprehensive online manual including a tutorial demonstrating its use can be found at the project website (<ext-link ext-link-type="uri" xlink:href="https://tgvaughan.github.io/BDMM-Prime">https://tgvaughan.github.io/BDMM-Prime</ext-link>).</p><boxed-text id="BX2" position="anchor" content-type="below"><label>Algorithm 2</label><caption><title>Particle filtering algorithm used to sample a trajectory from <italic>P</italic> (ℰ|𝒯<sub><italic>C</italic></sub>, <italic>η</italic>).</title></caption><p id="P106">Input</p><p id="P107">   𝒯<sub><italic>C</italic></sub> the edge-typed tree (output of the stochastic mapping algorithm)</p><p id="P108">   <italic>η</italic> the piecewise-constant birth-death model parameters</p><p id="P109">   <italic>M</italic> the number of particles used in the importance sampler</p><p id="P110">Initialisation</p><p id="P111">     Define <inline-formula><mml:math id="M71"><mml:mrow><mml:msubsup><mml:mi>ℰ</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> for all <italic>p</italic> ∈ [1, <italic>M</italic>] to be the initial type of 𝒯<sub><italic>C</italic></sub>.</p><p id="P112"><bold>for</bold> <italic>l</italic> ∈ [1, <italic>L</italic>] <bold>do</bold></p><p id="P113">     <bold>for</bold> <italic>p</italic> ∈ [1, <italic>M</italic>] <bold>do</bold></p><p id="P114">          Sample <inline-formula><mml:math id="M72"><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>ℰ</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mi>l</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>~</mml:mo><mml:msup><mml:mi>P</mml:mi><mml:mo>∗</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>ℰ</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:msubsup><mml:mi>ℰ</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mi>η</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> using either the Gillespie algorithm or <italic>τ</italic>-leaping.</p><p id="P115">          Compute <inline-formula><mml:math id="M73"><mml:mrow><mml:msubsup><mml:mi>w</mml:mi><mml:mi>l</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>ℰ</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mi>l</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p id="P116">     <bold>for</bold> <italic>p</italic> ∈ [1, <italic>M</italic>] <bold>do</bold></p><p id="P117">          Compute <inline-formula><mml:math id="M74"><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>w</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mi>l</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mi>w</mml:mi><mml:mi>l</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>/</mml:mo><mml:msub><mml:mstyle displaystyle="true"><mml:mtext>Σ</mml:mtext></mml:mstyle><mml:mrow><mml:msup><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub><mml:msubsup><mml:mi>w</mml:mi><mml:mi>l</mml:mi><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula></p><p id="P118">     <bold>for</bold> <italic>p</italic> ∈ [1, <italic>M</italic>] <bold>do</bold></p><p id="P119">          Sample <italic>p</italic><sup>′</sup> ~ Categorical <inline-formula><mml:math id="M75"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>M</mml:mi><mml:mo>;</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>w</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>w</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p id="P120">          Define <inline-formula><mml:math id="M76"><mml:mrow><mml:msubsup><mml:mi>ℰ</mml:mi><mml:mi>l</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mover accent="true"><mml:mi>ℰ</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mi>l</mml:mi><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and record the mapping <italic>α</italic><sub><italic>l</italic></sub>(<italic>p</italic>) = <italic>p</italic><sup>′</sup>.</p><p id="P121">Return</p><p id="P122">     <inline-formula><mml:math id="M77"><mml:mrow><mml:mi>ℰ</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mi>ℰ</mml:mi><mml:mi>L</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mstyle displaystyle="true"><mml:mo>∪</mml:mo></mml:mstyle><mml:msubsup><mml:mi>ℰ</mml:mi><mml:mrow><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mi>L</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msubsup><mml:mstyle displaystyle="true"><mml:mo>∪</mml:mo></mml:mstyle><mml:msubsup><mml:mi>ℰ</mml:mi><mml:mrow><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mrow><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mi>L</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msubsup><mml:mstyle displaystyle="true"><mml:mo>∪</mml:mo></mml:mstyle><mml:mo>…</mml:mo></mml:mrow></mml:math></inline-formula></p></boxed-text></sec><sec id="S10"><title>Trait mapping validation tests</title><p id="P123">To empirically validate the implementation of the stochastic mapping approach presented as algorithm 1, we considered a family of three-type models defined by a fixed process length of 5 time units and a set of piecewise-constant rate functions defined on this domain, all with a rate shift at time 2.5 following the start of the process. From this family of models, we drew an ensemble of 10<sup>4</sup> specific sets of model parameters <italic>η</italic> from a joint distribution</p><p id="P124"><italic>P</italic> (<italic>η</italic>) composed of the following parameter-specific distributions: <disp-formula id="FD34"><mml:math id="M78"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:msubsup><mml:mtext>λ</mml:mtext><mml:mrow><mml:mi>i</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mtext>pre</mml:mtext></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mtext>λ</mml:mtext><mml:mrow><mml:mi>i</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mtext>post</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo><mml:mtext>Unif</mml:mtext><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:msubsup><mml:mtext>λ</mml:mtext><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mtext>pre</mml:mtext></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mtext>λ</mml:mtext><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mtext>post</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo><mml:mtext>Unif</mml:mtext><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0.2</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mtext>pre</mml:mtext></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mtext>post</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo><mml:mtext>Unif</mml:mtext><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0.2</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:msubsup><mml:mi>δ</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mtext>pre</mml:mtext></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mtext>λ</mml:mtext><mml:mi>i</mml:mi><mml:mrow><mml:mtext>post</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo><mml:mtext>Unif</mml:mtext><mml:mo>(</mml:mo><mml:mn>0.5</mml:mn><mml:mo>,</mml:mo><mml:mn>1.5</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:msubsup><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mtext>pre</mml:mtext></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mtext>post</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo><mml:mtext>Unif</mml:mtext><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:msubsup><mml:mi>r</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mtext>pre</mml:mtext></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>r</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mtext>post</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo><mml:mtext>Unif</mml:mtext><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p id="P125">Here “pre” and “post” indicate parameter values before and after the rate shift time. We consider all combinations of <italic>i, j</italic> ∈ 1, 2, 3 with the constraint that <italic>j ≠ i</italic>.</p><p id="P126">For each <italic>η</italic> thus sampled, we produced a corresponding edge-typed tree 𝒯<sub><italic>C</italic></sub> from the prior distribution <italic>P</italic> (𝒯<sub><italic>C</italic></sub> |<italic>η</italic>) using direct simulation. From this we produced a corresponding tip-typed tree 𝒯 by removing the ancestral type information. We then used the stochastic mapping algorithm to sample a new edge-typed tree <inline-formula><mml:math id="M79"><mml:mrow><mml:msubsup><mml:mo>𝒯</mml:mo><mml:mi>C</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. In the case that the stochastic mapping algorithm implementation correctly samples from <italic>P</italic> (𝒯<sub><italic>C</italic></sub> |𝒯, <italic>η</italic>), the resulting sample distributions of 𝒯<sub><italic>C</italic></sub> and <inline-formula><mml:math id="M80"><mml:mrow><mml:msubsup><mml:mo>𝒯</mml:mo><mml:mi>C</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> should be indistinguishable, due to the following identity: <disp-formula id="FD35"><label>(28)</label><mml:math id="M81"><mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mo>𝒯</mml:mo><mml:mo>,</mml:mo><mml:mi>η</mml:mi></mml:mrow></mml:munder><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>𝒯</mml:mo><mml:mi>C</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:mo>𝒯</mml:mo><mml:mo>,</mml:mo><mml:mi>η</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>𝒯</mml:mo><mml:mo>∣</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mi>η</mml:mi></mml:munder><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>𝒯</mml:mo><mml:mi>C</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:mi>η</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p id="P127"><xref ref-type="fig" rid="F2">Figure 2</xref> illustrates a comparison between two sets of summary statistics computed from these sample distributions: the total number of each of the six possible type transitions along each tree, and the total edge lengths associated with each type. Comparisons are made by considering empirical quantiles (10% through 90%) derived from each summary statistic distribution. The close agreement between the quantiles for the statistics derived from the <inline-formula><mml:math id="M82"><mml:mrow><mml:msub><mml:mo>𝒯</mml:mo><mml:mi>C</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> ensemble and those derived from the <inline-formula><mml:math id="M83"><mml:mrow><mml:msubsup><mml:mo>𝒯</mml:mo><mml:mi>C</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> ensemble provides strong evidence for the correctness of our algorithm and its implementation.</p></sec><sec id="S11"><title>Trajectory sampling validation tests</title><p id="P128">We took a similar approach to validating the implementation of the trajectory particle filtering algorithm. We simulated an ensemble of 10<sup>4</sup> sets of parameters from the same three-type family of multi-type models defined by the same <italic>P</italic> (<italic>η</italic>) used in the stochastic mapping validation of the previous section. For each set of parameters <italic>η</italic>, we used direct simulation to sample a corresponding edge-typed tree 𝒯<sub><italic>C</italic></sub> and trajectory ℰ. For each tree in the resulting ensemble we additionally used the particle filter with 10<sup>3</sup> particles to sample ℰ<sup>′</sup> from <italic>P</italic> (ℰ|𝒯<sub><italic>C</italic></sub>, <italic>η</italic>). Since <disp-formula id="FD36"><label>(29)</label><mml:math id="M84"><mml:mrow><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:msub><mml:mo>𝒯</mml:mo><mml:mi>C</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>η</mml:mi></mml:mrow></mml:munder><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>ℰ</mml:mi><mml:mo>∣</mml:mo><mml:msub><mml:mo>𝒯</mml:mo><mml:mi>C</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>η</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mo>𝒯</mml:mo><mml:mi>C</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:mi>η</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mi>∑</mml:mi></mml:mstyle></mml:mrow><mml:mi>η</mml:mi></mml:munder><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℰ</mml:mi><mml:mo>∣</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula> the two sample distributions for ℰ<sup>′</sup> and ℰ should be identical, provided the particle filter used for the conditional sampling from <italic>P</italic> (ℰ|𝒯<sub><italic>C</italic></sub>, <italic>η</italic>) is correct.</p><p id="P129"><xref ref-type="fig" rid="F3">Figure 3</xref> shows a comparison between these two empirical trajectory distributions. Specifically, it illustrates comparisons between the empirical quantiles (10% through 90%) of the type-specific population sizes derived from each of the two ensembles at each of 51 evenly-spaced times between 0 and 5 (i.e. the start and end of the simulation period). That none of these quantile-quantile comparisons show any meaningful difference indicates that the sample distribution derived using the particle filter indeed matches the corresponding distribution generated via direct simulation.</p><p id="P130">We also simulated a second ensemble of 10<sup>4</sup> edge-typed trees and multi-type trajectories under a similar but distinct family of models in which the continuous sampling was replaced with a pair of contemporaneous sampling events at times 4 and 5 following the start of the process. Details of this model and the comparison between the corresponding trajectory ensembles are shown in <xref ref-type="supplementary-material" rid="SD1">supplemental figure S1</xref>. This also shows agreement between the distributions, further supporting our claim that the algorithm and its implementation function correctly.</p></sec><sec id="S12"><title>Approximating the computational burden</title><p id="P131">Rigorously assessing the time complexity of stochastic algorithms is non-trivial. However, we can readily develop an approximate understanding of the main influences on computation time of the algorithms we have presented. Firstly, the stochastic mapping algorithm relies on numerical integration of equation (5) along the tree edges, followed by stochastic simulation of the type changes using a stochastic simulation algorithm, both of which scale with the sum of all edge lengths of the tree (the total edge length). Thus we expect the calculation time for the stochastic mapping algorithm as a whole to also scale linearly with this total edge length.</p><p id="P132">The trajectory sampling algorithm, on the other hand, involves stochastic simulation of <italic>M</italic> candidate birth-death trajectories (i.e. particles) within each of the distinct intervals defined by the timing of features (including type changes and divergence times) on the input edge-typed tree 𝒯<sub><italic>C</italic></sub>. Assuming roughly constant rates, the expected number of these features scales roughly with the total edge length of the tree. We thus expect the run time of the trajectory sampling algorithm to increase linearly with both the total edge length and the number of particles used by the importance sampler.</p><p id="P133"><xref ref-type="supplementary-material" rid="SD1">Supplemental figures S2</xref> and S3 respectively illustrate the calculation duration distributions of the stochastic mapping and trajectory simulation components of the validation studies reported in the previous subsections. These figures clearly show the approximately linear dependence of the time complexity of both of these calculations on the total edge length of the input trees. These figures also give an indication of the absolute time needed by these calculations in practice: for trees under 1000 leaves the stochastic mapping algorithm tends to take less than 100 ms, while the trajectory sampling algorithm requires on the order of a second when 10<sup>3</sup> particles are used. Keeping in mind that the stochastic mapping and trajectory simulation algorithms are intended to be applied only to hundreds or at most thousands of tree and parameter combinations produced by multi-type birth-death MCMC analyses—which often require days to complete—such run times are practically negligible.</p></sec><sec id="S13"><title>Application: MERS in Camels and Humans</title><p id="P134">Following validation, we applied our approach to study the zoonotic transmission dynamics of the Middle East respiratory syndrome coronavirus (MERS-CoV). This virus was first isolated in 2012 (<xref ref-type="bibr" rid="R44">Zaki et al. 2012</xref>) and has been responsible for localized outbreaks of a respiratory disease, primarily in or associated with the Arabian Peninsula, with a high rate of mortality (World Health Organization 2022). While bats were initially believed to be the primary non-human reservoir, the pathogen was subsequently found to be endemic in camels in the region (see <xref ref-type="bibr" rid="R8">de Wit et al. (2016)</xref> for a comprehensive review).</p><p id="P135">We focused on the publicly-available MERS-CoV genomic dataset curated and used by <xref ref-type="bibr" rid="R10">Dudas et al. (2018)</xref> in their investigation of camel to human spillover dynamics. In that paper, the authors used a structured coalescent model (<xref ref-type="bibr" rid="R40">Vaughan et al. 2014</xref>) to infer the timing and number of spillover events of the pathogen from camels to humans. Our goal here was to analyze the same data using a multi-type birth-death model to jointly infer the two-host infection dynamics in the larger population, enabling direct quantification of the spillover dynamics.</p><p id="P136">The dataset is comprised of an alignment of 274 MERS-CoV genomes, including 100 genomes from camel hosts and 174 from humans. To avoid problems due to the recombination, we followed the approach taken by <xref ref-type="bibr" rid="R10">Dudas et al. (2018)</xref> in one of their analyses of considering only sites 21001–29364. We employed the nucleotide substitution model of <xref ref-type="bibr" rid="R20">Hasegawa et al. (1985)</xref> allowing for gamma-distributed site to site rate heterogeneity (<xref ref-type="bibr" rid="R43">Yang 1994</xref>). We assumed a relaxed clock model (<xref ref-type="bibr" rid="R9">Douglas et al. 2021</xref>) with an informative prior on the mean rate based on the study of MERS-CoV evolution by <xref ref-type="bibr" rid="R45">Zhang et al. (2016)</xref>.</p><p id="P137">We performed inference under a two-type birth-death model in which the two types correspond to the two host species, and for simplicity assumed that the initial infected host was a camel. Following <xref ref-type="bibr" rid="R26">Kühnert et al. (2016)</xref> we used the following epidemiological parameterization of the multi-type birth-death model. Assuming lineage removal on sampling (i.e. <italic>r</italic><sub><italic>i</italic></sub> = 1), this parameterization can be expressed in the following way: <disp-formula id="FD37"><mml:math id="M85"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mo>λ</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>δ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p id="P138">Here diagonal elements of <italic>R</italic><sub><italic>ij</italic></sub> represent the host-specific effective reproductive number, while off-diagonal elements generalize this quantity to describe cross-type (here zoonotic) transmission events. The parameter <italic>δ</italic><sub><italic>i</italic></sub> is the so-called “become uninfectious” rate, which is the net rate at which infected hosts are removed from their respective infectious compartments.</p><p id="P139">All parameters were assumed constant through time, with the single exception of the host-specific sampling proportions <italic>s</italic><sub><italic>i</italic></sub>, which were assumed to be zero for all times outside of the interval between the first and last included sample from each host type. Prior distributions are shown in <xref ref-type="table" rid="T2">Table 2</xref>. These include informative priors which penalize extreme reproductive numbers. Additionally, they place an upper bound on the sampling proportion parameters to reflect the impossibility that our small sample of sequences represented a large proportion of the infected human or camel populations.</p><p id="P140">For the MCMC portion of the analysis, 5 independent chains of approximately 9 <italic>×</italic> 10<sup>7</sup> iterations each were run, requiring approximately 90 hours of computation per chain. This was sufficiently long that all parameters of interest had an effective sample size (ESS) greater than 200. These chains were then compared to assess statistical convergence. (<xref ref-type="supplementary-material" rid="SD1">Supplemental Figure S4</xref> shows close agreement between sampled distributions from independent chains, indicating convergence.) The first 10% of iterations from each chain were discarded to account for burn-in, and these truncated chains were then combined for further analysis. Subsequently, stochastic mapping of ancestral types and particle filtering of epidemic trajectories were conducted on one in every 10<sup>6</sup> MCMC iterations, yielding 410 sampled edge-typed trees and multi-type trajectories in total. (Altogether, sampling these trajectories required approximately 30 minutes of additional computation, amounting to roughly 0.1% of the total analysis time.) Due to the large interval between MCMC iterations, we can regard these as effectively independent draws from the respective marginal tree and trajectory posteriors and thus sufficient to characterise these posteriors.</p><p id="P141"><xref ref-type="fig" rid="F4">Figure 4</xref> summarizes the results of this analysis. In <xref ref-type="fig" rid="F4">Figure 4A</xref>, a maximum clade credibility (MCC) summary tree is shown with annotations indicating the ancestral host types best supported by the posterior edge-typed tree posterior. While minor differences exist, the same patterns observed by <xref ref-type="bibr" rid="R10">Dudas et al. (2018)</xref> using the structured coalescent model are also visible on this tree, with clear indication of a persistent camel-associated reservoir producing periodic spillovers into the human population.</p><p id="P142">By counting events on the edge-typed trees, we found that the distribution of camel to human transmissions directly ancestral to the dataset has a 95% HPD of [45, 57] and median of 51 transmissions. These numbers are comparable to those determined by <xref ref-type="bibr" rid="R10">Dudas et al. (2018)</xref> applying the same approach to their structured coalescent results, who reported a 95% HPD of [48, 63] and a median of 56 for the number of transmissions.</p><p id="P143">The population-level spillover dynamics are shown in <xref ref-type="fig" rid="F4">figure 4B</xref>, which displays a summary of the host-specific infected population size trajectory posteriors, including median values and 95% central posterior density intervals. The nearly constant case load in the camel population is clearly visible. (Interestingly, this displays strong similarities to the Bayesian Skyline Plot estimate of the camel-associated effective population size shown figure 5 of <xref ref-type="bibr" rid="R10">Dudas et al. (2018)</xref>.) Additionally, the spillover outbreaks in the human population are reflected in the well-resolved spikes in the human-associated population trajectory.</p><p id="P144">For comparison, <xref ref-type="fig" rid="F4">figure 4C</xref> summarizes a distribution of trajectories produced by directly simulating the birth-death process using model parameters sampled from the posterior. Unlike the trajectory distribution shown in <xref ref-type="fig" rid="F4">figure 4B</xref>, this alternative distribution does not represent the true posterior distribution of population size trajectories, as it neglects the specific temporal information carried by the divergence time distribution of the phylogenetic tree, which in <xref ref-type="fig" rid="F4">figure 4B</xref> is directly incorporated by our particle filtering approach. This panel makes clear the importance of taking this information into account, with this distribution displaying little ability to resolve any of the spillover features present in the true posterior distribution.</p><p id="P145">Importantly, the sampled trajectories can be regarded as sequences of model events. We used these to characterise the marginal probability distributions for the number of camel to human transmission events in the whole population from which our sample was drawn. The marginal posterior for the number of these events has a 95% highest posterior distribution (HPD) interval of [143, 421] and a median of 236. This is significantly higher than the number of spillover events occurring on the edge-typed trees and thus ancestral to the sampled sequences. A comparison of the marginal posterior distribution for the camel to human transmission events in the edge-typed tree with the corresponding distribution for events in the wider population is shown in <xref ref-type="fig" rid="F4">figure 4D</xref>.</p></sec></sec><sec id="S14" sec-type="discussion"><title>Discussion</title><p id="P146">Multi-type birth-death phylodynamics inference methods have traditionally focused on the inference of the number, type and timing of events, such as lineage divergences and type-change events, directly affecting lineages ancestral to sampled sequences or individuals. By enabling estimation of type-specific population size dynamics, the method presented in this paper extends this capability to allow direct inference of the number, type and timing of events in the larger population which are not necessarily directly ancestral to the sampled genetic data. The approach is applicable to structured (multi-type) birth-death models for which thus far inference of population size dynamics was not generally possible. This follows on from our previous work (<xref ref-type="bibr" rid="R41">Vaughan et al. 2019</xref>) which used a particle marginal Metropolis-Hastings (PMMH) approach of <xref ref-type="bibr" rid="R1">Andrieu et al. (2010)</xref> to jointly sample both trees and population trajectory posteriors under a variety of linear and nonlinear single-type birth-death models.</p><p id="P147">As demonstrated in the MERS-CoV case study, the ability to impute these latent multi-type population trajectory variables has clear applications to the study of large epidemics, where the specific details of the subset of the population ancestral to the sample set is often not of direct interest. Instead it is usually the larger encompassing population of infected hosts that we wish to probe. Beyond epidemiology, there are also natural applications in other fields which make use of birth-death phylodynamic models. In macroevolution, models such as fossilized birth-death (FBD) together with linear multi-type models—BiSSE (<xref ref-type="bibr" rid="R30">Maddison et al. 2007</xref>), MuSSE (<xref ref-type="bibr" rid="R12">FitzJohn 2012</xref>), HiSSE (<xref ref-type="bibr" rid="R3">Beaulieu and O’Meara 2016</xref>), etc.—are commonly used to infer trait-dependent speciation and extinction rates from trees inferred using genetic and morphological data. Our approach provides an efficient and self-consistent route to estimating and testing hypotheses relating to the corresponding trait-dependent species richness dynamics under these same models.</p><p id="P148">Even when the phylogenetic tree and parameters such as birth, death and migration rates are the sole focus, inferred trajectories may still be useful in gauging the appropriateness of phylodynamic models. After all, as discussed in the introduction to this manuscript, birth-death-sampling processes imply the existence of such trajectories even when traditional methods report only the marginal distributions of the phylogenetic trees and parameters. Nonsensical properties of inferred trajectories may reveal existing but previously-obscured deficiencies in the ability of the model to adequately describe the intended population dynamics and sampling processes. Such deficiencies could also be assessed quantitatively as part of a formal model adequacy test in which summary statistics of inferred trajectories were compared with statistics computed via posterior predictive simulation. (Possible summary statistics for such a test might include type-specific population size bounds or counts of specific birth-death trajectory events.)</p><p id="P149">We have shown that estimation of multi-type population trajectories can be performed with relatively minor increase in computational effort relative to that of the MCMC inference which must still be performed in the manner described previously (<xref ref-type="bibr" rid="R26">Kühnert et al. 2016</xref>; <xref ref-type="bibr" rid="R36">Scire et al. 2022</xref>). However it is important to emphasize that the computational demand of the MCMC inference portion is significant, and is the rate-limiting step of the inference. In our experience, multi-type birth-death MCMC inference tends to be practical only for trees of hundreds of tips and for models with relatively few types <xref ref-type="bibr" rid="R36">Scire et al. (2022)</xref>, although techniques have been developed which will help raise these practical limits in future (<xref ref-type="bibr" rid="R28">Louca and Pennell 2019</xref>; <xref ref-type="bibr" rid="R46">Zhukova et al. 2023</xref>).</p><p id="P150">We note that the effect of the restriction of the model space to linear models—which cannot, for instance, directly account for density-dependent shifts in transmission rate—can be somewhat ameliorated through the application of time inhomogeneous rate variation, which our approach supports via arbitrary piecewise-constant variation in rate functions, as shown by <xref ref-type="bibr" rid="R25">Kühnert et al. (2014)</xref>. However, MacPherson and Pennell (2024) recently demonstrated that such approximations cannot fully account for the effects of density dependence on population size dynamics.</p><p id="P151">To conclude, we have presented a Bayesian approach for the inference of complete multi-type birth-death population size trajectories from genetic sequences. Our application of the method to MERS-CoV demonstrates that this can be used to directly infer interesting properties of populations from which genetic samples are taken, such as the host-specific infected population dynamics and the times and numbers of zoonotic events (rather than merely the number of zoonotic events ancestral to the genetic sample). Importantly, we have shown that extending existing MCMC-based phylodynamic analyses to incorporate trajectory inference can be accomplished with relatively little additional computational overhead. For these reasons, we believe that this new approach will prove to be a useful and practical addition to the phylodynamics tool set.</p></sec><sec sec-type="supplementary-material" id="SM"><title>Supplementary Material</title><supplementary-material content-type="local-data" id="SD1"><label>Supplemental text and figures</label><media xlink:href="EMS201624-supplement-Supplemental_text_and_figures_.pdf" mimetype="application" mime-subtype="pdf" id="d95aAcEbB" position="anchor"/></supplementary-material></sec></body><back><ack id="S15"><title>Acknowledgements</title><p>The authors gratefully acknowledge Nicola Mulberry who provided valuable feedback on an early version of the manuscript, together with three anonymous reviewers who provided many helpful suggestions. This project has received funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme grant agreement no. 101001077.</p></ack><sec id="S16" sec-type="data-availability"><title>Data availability</title><p id="P152">All of the BEAST 2 input files and associated scripts required to reproduce the analyses and results presented in this paper, together with corresponding usage instructions, are available for download from GitHub (<ext-link ext-link-type="uri" xlink:href="https://github.com/tgvaughan/MultiTypeTrajectoryAnalyses">https://github.com/tgvaughan/MultiTypeTrajectoryAnalyses</ext-link>). The method itself is implemented as a new package, BDMM-Prime, which is distributed as free software under the terms of the GNU General Public License version 3. The source code for the software is available from its GitHub repository (<ext-link ext-link-type="uri" xlink:href="https://github.com/tgvaughan/BDMM-Prime">https://github.com/tgvaughan/BDMM-Prime</ext-link>), and a complete online manual including a detailed tutorial can be found at the package website (<ext-link ext-link-type="uri" xlink:href="https://tgvaughan.github.io/BDMM-Prime">https://tgvaughan.github.io/BDMM-Prime</ext-link>).</p></sec><ref-list><title>References</title><ref id="R1"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Andrieu</surname><given-names>C</given-names></name><name><surname>Doucet</surname><given-names>A</given-names></name><name><surname>Holenstein</surname><given-names>R</given-names></name></person-group><article-title>Particle Markov chain Monte Carlo methods</article-title><source>J R Stat Soc B</source><year>2010</year><volume>72</volume><issue>3</issue><fpage>269</fpage><lpage>342</lpage></element-citation></ref><ref id="R2"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Barido-Sottani</surname><given-names>J</given-names></name><name><surname>Vaughan</surname><given-names>TG</given-names></name><name><surname>Stadler</surname><given-names>T</given-names></name></person-group><article-title>A multitype birth–death model for Bayesian inference of lineage-specific birth and death rates</article-title><source>Systematic Biol</source><year>2020</year><volume>69</volume><issue>5</issue><fpage>973</fpage><lpage>986</lpage><pub-id pub-id-type="pmcid">PMC7440751</pub-id><pub-id pub-id-type="pmid">32105322</pub-id><pub-id pub-id-type="doi">10.1093/sysbio/syaa016</pub-id></element-citation></ref><ref id="R3"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Beaulieu</surname><given-names>JM</given-names></name><name><surname>O’Meara</surname><given-names>BC</given-names></name></person-group><article-title>Detecting hidden diversification shifts in models of trait-dependent speciation and extinction</article-title><source>Systematic Biol</source><year>2016</year><volume>65</volume><issue>4</issue><fpage>583</fpage><lpage>601</lpage><pub-id pub-id-type="pmid">27016728</pub-id></element-citation></ref><ref id="R4"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Beerli</surname><given-names>P</given-names></name><name><surname>Felsenstein</surname><given-names>J</given-names></name></person-group><article-title>Maximum likelihood estimation of a migration matrix and effective population sizes in n subpopulations by using a coalescent approach</article-title><source>Proc Natl Acad Sci U S A</source><year>2001</year><volume>98</volume><issue>8</issue><fpage>4563</fpage><lpage>4568</lpage><pub-id pub-id-type="pmcid">PMC31874</pub-id><pub-id pub-id-type="pmid">11287657</pub-id><pub-id pub-id-type="doi">10.1073/pnas.081068098</pub-id></element-citation></ref><ref id="R5"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bouckaert</surname><given-names>R</given-names></name><name><surname>Vaughan</surname><given-names>TG</given-names></name><name><surname>Barido-Sottani</surname><given-names>J</given-names></name><name><surname>Duchêne</surname><given-names>S</given-names></name><name><surname>Fourment</surname><given-names>M</given-names></name><name><surname>Gavryushkina</surname><given-names>A</given-names></name><name><surname>Heled</surname><given-names>J</given-names></name><name><surname>Jones</surname><given-names>G</given-names></name><name><surname>Kühnert</surname><given-names>D</given-names></name><name><surname>Maio</surname><given-names>ND</given-names></name><etal/></person-group><article-title>BEAST 2.5: An advanced software platform for Bayesian evolutionary analysis</article-title><source>PLoS Comput Biol</source><year>2019</year><volume>15</volume><issue>4</issue><elocation-id>e1006650</elocation-id><pub-id pub-id-type="pmcid">PMC6472827</pub-id><pub-id pub-id-type="pmid">30958812</pub-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1006650</pub-id></element-citation></ref><ref id="R6"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cappe</surname><given-names>O</given-names></name><name><surname>Godsill</surname><given-names>SJ</given-names></name><name><surname>Moulines</surname><given-names>E</given-names></name></person-group><article-title>An overview of existing methods and recent advances in sequential Monte Carlo</article-title><source>Proc IEEE</source><year>2007</year><volume>95</volume><issue>5</issue><fpage>899</fpage><lpage>924</lpage></element-citation></ref><ref id="R7"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>De Maio</surname><given-names>N</given-names></name><name><surname>Wu</surname><given-names>CH</given-names></name><name><surname>O’Reilly</surname><given-names>KM</given-names></name><name><surname>Wilson</surname><given-names>D</given-names></name></person-group><article-title>New routes to phylogeography: A bayesian structured coalescent approximation</article-title><source>PLoS Genet</source><year>2015</year><volume>11</volume><issue>8</issue><elocation-id>e1005421</elocation-id><pub-id pub-id-type="pmcid">PMC4534465</pub-id><pub-id pub-id-type="pmid">26267488</pub-id><pub-id pub-id-type="doi">10.1371/journal.pgen.1005421</pub-id></element-citation></ref><ref id="R8"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>de Wit</surname><given-names>E</given-names></name><name><surname>van Doremalen</surname><given-names>N</given-names></name><name><surname>Falzarano</surname><given-names>D</given-names></name><name><surname>Munster</surname><given-names>VJ</given-names></name></person-group><article-title>SARS and MERS: recent insights into emerging coronaviruses</article-title><source>Nat Rev Microbiol</source><year>2016</year><volume>14</volume><issue>8</issue><fpage>523</fpage><lpage>534</lpage><pub-id pub-id-type="pmcid">PMC7097822</pub-id><pub-id pub-id-type="pmid">27344959</pub-id><pub-id pub-id-type="doi">10.1038/nrmicro.2016.81</pub-id></element-citation></ref><ref id="R9"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Douglas</surname><given-names>J</given-names></name><name><surname>Zhang</surname><given-names>R</given-names></name><name><surname>Bouckaert</surname><given-names>R</given-names></name></person-group><article-title>Adaptive dating and fast proposals: Revisiting the phylogenetic relaxed clock model</article-title><source>PLoS Comput Biol</source><year>2021</year><volume>17</volume><issue>2</issue><elocation-id>e1008322</elocation-id><pub-id pub-id-type="pmcid">PMC7880504</pub-id><pub-id pub-id-type="pmid">33529184</pub-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1008322</pub-id></element-citation></ref><ref id="R10"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dudas</surname><given-names>G</given-names></name><name><surname>Carvalho</surname><given-names>LM</given-names></name><name><surname>Rambaut</surname><given-names>A</given-names></name><name><surname>Bedford</surname><given-names>T</given-names></name></person-group><article-title>MERS-CoV spillover at the camel-human interface</article-title><source>eLife</source><year>2018</year><volume>7</volume><pub-id pub-id-type="pmcid">PMC5777824</pub-id><pub-id pub-id-type="pmid">29336306</pub-id><pub-id pub-id-type="doi">10.7554/eLife.31257</pub-id></element-citation></ref><ref id="R11"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ewing</surname><given-names>G</given-names></name><name><surname>Nicholls</surname><given-names>G</given-names></name><name><surname>Rodrigo</surname><given-names>A</given-names></name></person-group><article-title>Using temporally spaced sequences to simultaneously estimate migration rates, mutation rate and population sizes in measurably evolving populations</article-title><source>Genetics</source><year>2004</year><volume>168</volume><issue>4</issue><fpage>2407</fpage><lpage>2420</lpage><pub-id pub-id-type="pmcid">PMC1448755</pub-id><pub-id pub-id-type="pmid">15611198</pub-id><pub-id pub-id-type="doi">10.1534/genetics.104.030411</pub-id></element-citation></ref><ref id="R12"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>FitzJohn</surname><given-names>RG</given-names></name></person-group><article-title>Diversitree: comparative phylogenetic analyses of diversification in R</article-title><source>Methods Ecol Evol</source><year>2012</year><volume>3</volume><issue>6</issue><fpage>1084</fpage><lpage>1092</lpage></element-citation></ref><ref id="R13"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Freyman</surname><given-names>WA</given-names></name><name><surname>Höhna</surname><given-names>S</given-names></name></person-group><article-title>Stochastic character mapping of state-dependent diversification reveals the tempo of evolutionary decline in self-compatible Onagraceae lineages</article-title><source>Systematic Biol</source><year>2018</year><volume>68</volume><issue>3</issue><fpage>505</fpage><lpage>519</lpage><pub-id pub-id-type="pmid">30476308</pub-id></element-citation></ref><ref id="R14"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gavryushkina</surname><given-names>A</given-names></name><name><surname>Welch</surname><given-names>D</given-names></name><name><surname>Stadler</surname><given-names>T</given-names></name><name><surname>Drummond</surname><given-names>AJ</given-names></name></person-group><article-title>Bayesian inference of sampled ancestor trees for epidemiology and fossil calibration</article-title><source>PLoS Comput Biol</source><year>2014</year><volume>10</volume><issue>12</issue><elocation-id>e1003919</elocation-id><pub-id pub-id-type="pmcid">PMC4263412</pub-id><pub-id pub-id-type="pmid">25474353</pub-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1003919</pub-id></element-citation></ref><ref id="R15"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gavryushkina</surname><given-names>A</given-names></name><name><surname>Heath</surname><given-names>TA</given-names></name><name><surname>Ksepka</surname><given-names>DT</given-names></name><name><surname>Stadler</surname><given-names>T</given-names></name><name><surname>Welch</surname><given-names>D</given-names></name><name><surname>Drummond</surname><given-names>AJ</given-names></name></person-group><article-title>Bayesian total-evidence dating reveals the recent crown radiation of penguins</article-title><source>Systematic Biol</source><year>2017</year><volume>66</volume><issue>1</issue><fpage>57</fpage><lpage>73</lpage><pub-id pub-id-type="pmcid">PMC5410945</pub-id><pub-id pub-id-type="pmid">28173531</pub-id><pub-id pub-id-type="doi">10.1093/sysbio/syw060</pub-id></element-citation></ref><ref id="R16"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gillespie</surname><given-names>DT</given-names></name></person-group><article-title>A general method for numerically simulating the stochastic time evolution of coupled chemical reactions</article-title><source>J Comput Phys</source><year>1976</year><volume>22</volume><fpage>403</fpage></element-citation></ref><ref id="R17"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Grear</surname><given-names>DA</given-names></name><name><surname>Hall</surname><given-names>JS</given-names></name><name><surname>Dusek</surname><given-names>RJ</given-names></name><name><surname>Ip</surname><given-names>HS</given-names></name></person-group><article-title>Inferring epidemiologic dynamics from viral evolution: 2014–2015 Eurasian/North American highly pathogenic avian influenza viruses exceed transmission threshold, R<sub>0</sub> = 1, in wild birds and poultry in North America</article-title><source>Evol Appl</source><year>2017</year><volume>11</volume><issue>4</issue><fpage>547</fpage><lpage>557</lpage><pub-id pub-id-type="pmcid">PMC5891053</pub-id><pub-id pub-id-type="pmid">29636805</pub-id><pub-id pub-id-type="doi">10.1111/eva.12576</pub-id></element-citation></ref><ref id="R18"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Grenfell</surname><given-names>BT</given-names></name><name><surname>Pybus</surname><given-names>OG</given-names></name><name><surname>Gog</surname><given-names>JR</given-names></name><name><surname>Wood</surname><given-names>JLN</given-names></name><name><surname>Daly</surname><given-names>JM</given-names></name><name><surname>Mumford</surname><given-names>JA</given-names></name><name><surname>Holmes</surname><given-names>EC</given-names></name></person-group><article-title>Unifying the epidemiological and evolutionary dynamics of pathogens</article-title><source>Science</source><year>2004</year><volume>303</volume><issue>5656</issue><fpage>327</fpage><lpage>32</lpage><pub-id pub-id-type="pmid">14726583</pub-id></element-citation></ref><ref id="R19"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Guinat</surname><given-names>C</given-names></name><name><surname>Valenzuela Agüí</surname><given-names>C</given-names></name><name><surname>Vaughan</surname><given-names>TG</given-names></name><name><surname>Scire</surname><given-names>J</given-names></name><name><surname>Pohlmann</surname><given-names>A</given-names></name><name><surname>Staubach</surname><given-names>C</given-names></name><name><surname>King</surname><given-names>J</given-names></name><name><surname>Świętoń</surname><given-names>E</given-names></name><name><surname>Dán</surname><given-names>Á</given-names></name><name><surname>Černíková</surname><given-names>L</given-names></name><etal/></person-group><article-title>Disentangling the role of poultry farms and wild birds in the spread of highly pathogenic avian influenza virus in Europe</article-title><source>Virus Evol</source><year>2022</year><volume>8</volume><issue>2</issue><pub-id pub-id-type="pmcid">PMC9752641</pub-id><pub-id pub-id-type="pmid">36533150</pub-id><pub-id pub-id-type="doi">10.1093/ve/veac073</pub-id></element-citation></ref><ref id="R20"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hasegawa</surname><given-names>M</given-names></name><name><surname>Kishino</surname><given-names>H</given-names></name><name><surname>Yano</surname><given-names>T</given-names></name></person-group><article-title>Dating of the human-ape splitting by a molecular clock of mitochondrial DNA</article-title><source>J Mol Evol</source><year>1985</year><volume>22</volume><issue>2</issue><fpage>160</fpage><lpage>174</lpage><pub-id pub-id-type="pmid">3934395</pub-id></element-citation></ref><ref id="R21"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Heath</surname><given-names>TA</given-names></name><name><surname>Huelsenbeck</surname><given-names>JP</given-names></name><name><surname>Stadler</surname><given-names>T</given-names></name></person-group><article-title>The fossilized birth-death process for coherent calibration of divergence-time estimates</article-title><source>Proc Natl Acad Sci U S A</source><year>2014</year><volume>111</volume><fpage>E2957</fpage><lpage>E2966</lpage><pub-id pub-id-type="pmcid">PMC4115571</pub-id><pub-id pub-id-type="pmid">25009181</pub-id><pub-id pub-id-type="doi">10.1073/pnas.1319091111</pub-id></element-citation></ref><ref id="R22"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hey</surname><given-names>J</given-names></name><name><surname>Nielsen</surname><given-names>R</given-names></name></person-group><article-title>Integration within the Felsenstein equation for improved Markov chain Monte Carlo methods in population genetics</article-title><source>Proc Natl Acad Sci U S A</source><year>2007</year><volume>104</volume><issue>8</issue><fpage>2785</fpage><lpage>2790</lpage><pub-id pub-id-type="pmcid">PMC1815259</pub-id><pub-id pub-id-type="pmid">17301231</pub-id><pub-id pub-id-type="doi">10.1073/pnas.0611164104</pub-id></element-citation></ref><ref id="R23"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kendall</surname><given-names>DG</given-names></name></person-group><article-title>On the generalized “birth-and-death” process</article-title><source>The Annals of Mathematical Statistics</source><year>1948</year><volume>19</volume><issue>1</issue><fpage>1</fpage><lpage>15</lpage></element-citation></ref><ref id="R24"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>King</surname><given-names>AA</given-names></name><name><surname>Lin</surname><given-names>Q</given-names></name><name><surname>Ionides</surname><given-names>EL</given-names></name></person-group><article-title>Markov genealogy processes</article-title><source>Theor Popul Biol</source><year>2022</year><volume>143</volume><fpage>77</fpage><lpage>91</lpage><pub-id pub-id-type="pmcid">PMC8846264</pub-id><pub-id pub-id-type="pmid">34896438</pub-id><pub-id pub-id-type="doi">10.1016/j.tpb.2021.11.003</pub-id></element-citation></ref><ref id="R25"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kühnert</surname><given-names>D</given-names></name><name><surname>Stadler</surname><given-names>T</given-names></name><name><surname>Vaughan</surname><given-names>TG</given-names></name><name><surname>Drummond</surname><given-names>AJ</given-names></name></person-group><article-title>Simultaneous reconstruction of evolutionary history and epidemiological dynamics from viral sequences with the birth-death sir model</article-title><source>J R Soc Interface</source><year>2014</year><volume>11</volume><issue>94</issue><elocation-id>20131106</elocation-id><pub-id pub-id-type="pmcid">PMC3973358</pub-id><pub-id pub-id-type="pmid">24573331</pub-id><pub-id pub-id-type="doi">10.1098/rsif.2013.1106</pub-id></element-citation></ref><ref id="R26"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kühnert</surname><given-names>D</given-names></name><name><surname>Stadler</surname><given-names>T</given-names></name><name><surname>Vaughan</surname><given-names>TG</given-names></name><name><surname>Drummond</surname><given-names>AJ</given-names></name></person-group><article-title>Phylodynamics with migration: A computational framework to quantify population structure from genomic data</article-title><source>Mol Biol Evol</source><year>2016</year><volume>33</volume><fpage>2102</fpage><lpage>2116</lpage><pub-id pub-id-type="pmcid">PMC4948704</pub-id><pub-id pub-id-type="pmid">27189573</pub-id><pub-id pub-id-type="doi">10.1093/molbev/msw064</pub-id></element-citation></ref><ref id="R27"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Loiseau</surname><given-names>C</given-names></name><name><surname>Windels</surname><given-names>EM</given-names></name><name><surname>Gygli</surname><given-names>SM</given-names></name><name><surname>Jugheli</surname><given-names>L</given-names></name><name><surname>Maghradze</surname><given-names>N</given-names></name><name><surname>Brites</surname><given-names>D</given-names></name><name><surname>Ross</surname><given-names>A</given-names></name><name><surname>Goig</surname><given-names>G</given-names></name><name><surname>Reinhard</surname><given-names>M</given-names></name><name><surname>Borrell</surname><given-names>S</given-names></name><etal/></person-group><article-title>The relative transmission fitness of multidrug-resistant Mycobacterium tuberculosis in a drug resistance hotspot</article-title><source>Nat Commun</source><year>2023</year><volume>14</volume><issue>1</issue><pub-id pub-id-type="pmcid">PMC10082831</pub-id><pub-id pub-id-type="pmid">37031225</pub-id><pub-id pub-id-type="doi">10.1038/s41467-023-37719-y</pub-id></element-citation></ref><ref id="R28"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Louca</surname><given-names>S</given-names></name><name><surname>Pennell</surname><given-names>MW</given-names></name></person-group><article-title>A general and efficient algorithm for the likelihood of diversification and discrete-trait evolutionary models</article-title><source>Systematic Biol</source><year>2019</year><volume>69</volume><issue>3</issue><fpage>545</fpage><lpage>556</lpage><pub-id pub-id-type="pmid">31432088</pub-id></element-citation></ref><ref id="R29"><element-citation publication-type="other"><person-group person-group-type="author"><name><surname>MacPherson</surname><given-names>A</given-names></name><name><surname>Pennell</surname><given-names>M</given-names></name></person-group><source>unpublished data</source><date-in-citation>last accessed April 7, 2025</date-in-citation><pub-id pub-id-type="doi">10.1101/2024.06.07.597929v1</pub-id></element-citation></ref><ref id="R30"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Maddison</surname><given-names>WP</given-names></name><name><surname>Midford</surname><given-names>PE</given-names></name><name><surname>Otto</surname><given-names>SP</given-names></name></person-group><article-title>Estimating a binary character’s effect on speciation and extinction</article-title><source>Systematic Biol</source><year>2007</year><volume>56</volume><issue>5</issue><fpage>701</fpage><lpage>710</lpage><pub-id pub-id-type="pmid">17849325</pub-id></element-citation></ref><ref id="R31"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Manceau</surname><given-names>M</given-names></name><name><surname>Gupta</surname><given-names>A</given-names></name><name><surname>Vaughan</surname><given-names>T</given-names></name><name><surname>Stadler</surname><given-names>T</given-names></name></person-group><article-title>The probability distribution of the ancestral population size conditioned on the reconstructed phylogenetic tree with occurrence data</article-title><source>J Theor Biol</source><year>2021</year><volume>509</volume><elocation-id>110400</elocation-id><pub-id pub-id-type="pmcid">PMC7733867</pub-id><pub-id pub-id-type="pmid">32739241</pub-id><pub-id pub-id-type="doi">10.1016/j.jtbi.2020.110400</pub-id></element-citation></ref><ref id="R32"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Müller</surname><given-names>NF</given-names></name><name><surname>Rasmussen</surname><given-names>D</given-names></name><name><surname>Stadler</surname><given-names>T</given-names></name></person-group><article-title>MASCOT: parameter and state inference under the marginal structured coalescent approximation</article-title><source>Bioinformatics</source><year>2018</year><volume>34</volume><issue>22</issue><fpage>3843</fpage><lpage>3848</lpage><pub-id pub-id-type="pmcid">PMC6223361</pub-id><pub-id pub-id-type="pmid">29790921</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/bty406</pub-id></element-citation></ref><ref id="R33"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nadeau</surname><given-names>SA</given-names></name><name><surname>Vaughan</surname><given-names>TG</given-names></name><name><surname>Scire</surname><given-names>J</given-names></name><name><surname>Huisman</surname><given-names>JS</given-names></name><name><surname>Stadler</surname><given-names>T</given-names></name></person-group><article-title>The origin and early spread of SARS-CoV-2 in Europe</article-title><source>Proc Natl Acad Sci U S A</source><year>2021</year><volume>118</volume><issue>9</issue><pub-id pub-id-type="pmcid">PMC7936359</pub-id><pub-id pub-id-type="pmid">33571105</pub-id><pub-id pub-id-type="doi">10.1073/pnas.2012008118</pub-id></element-citation></ref><ref id="R34"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rabosky</surname><given-names>DL</given-names></name></person-group><article-title>Automatic detection of key innovations, rate shifts, and diversity-dependence on phylogenetic trees</article-title><source>PLoS ONE</source><year>2014</year><volume>9</volume><issue>2</issue><elocation-id>e89543</elocation-id><pub-id pub-id-type="pmcid">PMC3935878</pub-id><pub-id pub-id-type="pmid">24586858</pub-id><pub-id pub-id-type="doi">10.1371/journal.pone.0089543</pub-id></element-citation></ref><ref id="R35"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rasmussen</surname><given-names>DA</given-names></name><name><surname>Stadler</surname><given-names>T</given-names></name></person-group><article-title>Coupling adaptive molecular evolution to phylodynamics using fitness-dependent birth-death models</article-title><source>eLife</source><year>2019</year><volume>8</volume><pub-id pub-id-type="pmcid">PMC6715349</pub-id><pub-id pub-id-type="pmid">31411558</pub-id><pub-id pub-id-type="doi">10.7554/eLife.45562</pub-id></element-citation></ref><ref id="R36"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Scire</surname><given-names>J</given-names></name><name><surname>Barido-Sottani</surname><given-names>J</given-names></name><name><surname>Kühnert</surname><given-names>D</given-names></name><name><surname>Vaughan</surname><given-names>TG</given-names></name><name><surname>Stadler</surname><given-names>T</given-names></name></person-group><article-title>Robust phylodynamic analysis of genetic sequencing data from structured populations</article-title><source>Viruses</source><year>2022</year><volume>14</volume><issue>8</issue><fpage>1648</fpage><pub-id pub-id-type="pmcid">PMC9413058</pub-id><pub-id pub-id-type="pmid">36016270</pub-id><pub-id pub-id-type="doi">10.3390/v14081648</pub-id></element-citation></ref><ref id="R37"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stadler</surname><given-names>T</given-names></name></person-group><article-title>Sampling-through-time in birth-death trees</article-title><source>J Theor Biol</source><year>2010</year><volume>267</volume><issue>3</issue><fpage>396</fpage><lpage>404</lpage><pub-id pub-id-type="pmid">20851708</pub-id></element-citation></ref><ref id="R38"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stadler</surname><given-names>T</given-names></name><name><surname>Kühnert</surname><given-names>D</given-names></name><name><surname>Bonhoeffer</surname><given-names>S</given-names></name><name><surname>Drummond</surname><given-names>AJ</given-names></name></person-group><article-title>Birth-death skyline plot reveals temporal changes of epidemic spread in HIV and hepatitis C virus (HCV)</article-title><source>Proc Natl Acad Sci U S A</source><year>2012</year><volume>110</volume><issue>1</issue><fpage>228</fpage><lpage>233</lpage><pub-id pub-id-type="pmcid">PMC3538216</pub-id><pub-id pub-id-type="pmid">23248286</pub-id><pub-id pub-id-type="doi">10.1073/pnas.1207965110</pub-id></element-citation></ref><ref id="R39"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stadler</surname><given-names>T</given-names></name><name><surname>Pybus</surname><given-names>OG</given-names></name><name><surname>Stumpf</surname><given-names>MPH</given-names></name></person-group><article-title>Phylodynamics for cell biologists</article-title><source>Science</source><year>2021</year><volume>371</volume><issue>6526</issue><pub-id pub-id-type="pmid">33446527</pub-id></element-citation></ref><ref id="R40"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Vaughan</surname><given-names>TG</given-names></name><name><surname>Kühnert</surname><given-names>D</given-names></name><name><surname>Popinga</surname><given-names>A</given-names></name><name><surname>Welch</surname><given-names>D</given-names></name><name><surname>Drummond</surname><given-names>AJ</given-names></name></person-group><article-title>Efficient Bayesian inference under the structured coalescent</article-title><source>Bioinformatics</source><year>2014</year><volume>30</volume><issue>16</issue><fpage>2272</fpage><lpage>2279</lpage><pub-id pub-id-type="pmcid">PMC4207426</pub-id><pub-id pub-id-type="pmid">24753484</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btu201</pub-id></element-citation></ref><ref id="R41"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Vaughan</surname><given-names>TG</given-names></name><name><surname>Leventhal</surname><given-names>GE</given-names></name><name><surname>Rasmussen</surname><given-names>DA</given-names></name><name><surname>Drummond</surname><given-names>AJ</given-names></name><name><surname>Welch</surname><given-names>D</given-names></name><name><surname>Stadler</surname><given-names>T</given-names></name></person-group><article-title>Estimating epidemic incidence and prevalence from genomic data</article-title><source>Mol Biol Evol</source><year>2019</year><volume>36</volume><fpage>1804</fpage><lpage>1816</lpage><pub-id pub-id-type="pmcid">PMC6681632</pub-id><pub-id pub-id-type="pmid">31058982</pub-id><pub-id pub-id-type="doi">10.1093/molbev/msz106</pub-id></element-citation></ref><ref id="R42"><element-citation publication-type="web"><collab>World Health Organization</collab><source>Middle East respiratory syndrome coronavirus (MERS-CoV), electronic resource</source><date-in-citation>last accessed 27 August 2024</date-in-citation><comment><ext-link ext-link-type="uri" xlink:href="https://www.who.int/news-room/fact-sheets/detail/middle-east-respiratory-syndrome-coronavirus-(mers-cov)">https://www.who.int/news-room/fact-sheets/detail/middle-east-respiratory-syndrome-coronavirus-(mers-cov)</ext-link></comment></element-citation></ref><ref id="R43"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Yang</surname><given-names>Z</given-names></name></person-group><article-title>Maximum likelihood phylogenetic estimation from DNA sequences with variable rates over sites: approximate methods</article-title><source>J Mol Evol</source><year>1994</year><volume>39</volume><fpage>306</fpage><lpage>314</lpage><pub-id pub-id-type="pmid">7932792</pub-id></element-citation></ref><ref id="R44"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zaki</surname><given-names>AM</given-names></name><name><surname>van Boheemen</surname><given-names>S</given-names></name><name><surname>Bestebroer</surname><given-names>TM</given-names></name><name><surname>Osterhaus</surname><given-names>AD</given-names></name><name><surname>Fouchier</surname><given-names>RA</given-names></name></person-group><article-title>Isolation of a novel coronavirus from a man with pneumonia in Saudi Arabia</article-title><source>New Engl J Med</source><year>2012</year><volume>367</volume><issue>19</issue><fpage>1814</fpage><lpage>1820</lpage><pub-id pub-id-type="pmid">23075143</pub-id></element-citation></ref><ref id="R45"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zhang</surname><given-names>Z</given-names></name><name><surname>Shen</surname><given-names>L</given-names></name><name><surname>Gu</surname><given-names>X</given-names></name></person-group><article-title>Evolutionary dynamics of MERS-CoV: Potential recombination, positive selection and transmission</article-title><source>Sci Rep</source><year>2016</year><volume>6</volume><issue>1</issue><pub-id pub-id-type="pmcid">PMC4855236</pub-id><pub-id pub-id-type="pmid">27142087</pub-id><pub-id pub-id-type="doi">10.1038/srep25049</pub-id></element-citation></ref><ref id="R46"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zhukova</surname><given-names>A</given-names></name><name><surname>Hecht</surname><given-names>F</given-names></name><name><surname>Maday</surname><given-names>Y</given-names></name><name><surname>Gascuel</surname><given-names>O</given-names></name></person-group><article-title>Fast and accurate maximum-likelihood estimation of multi-type birth–death epidemiological models from phylogenetic trees</article-title><source>Systematic Biol</source><year>2023</year><volume>72</volume><issue>6</issue><fpage>1387</fpage><lpage>1402</lpage><pub-id pub-id-type="pmcid">PMC10924745</pub-id><pub-id pub-id-type="pmid">37703335</pub-id><pub-id pub-id-type="doi">10.1093/sysbio/syad059</pub-id></element-citation></ref></ref-list></back><floats-group><fig id="F1" position="float"><label>Fig. 1</label><caption><p>Relationship between the tip-typed tree 𝒯, the edge-typed tree 𝒯<sub><italic>C</italic></sub>, the multi-type lineage-through-time function <inline-formula><mml:math id="M86"><mml:mrow><mml:mover accent="true"><mml:mi>K</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the cumulative sample count function <inline-formula><mml:math id="M87"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and the multi-type population size function <inline-formula><mml:math id="M88"><mml:mrow><mml:mover accent="true"><mml:mi>N</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, for a single realization of a multi-type birth-death-sampling model starting at time 0 and ending at time 𝒯. The time of the root of the tree is <inline-formula><mml:math id="M89"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p></caption><graphic xlink:href="EMS201624-f001"/></fig><fig id="F2" position="float"><label>Fig. 2</label><caption><p>Quantile-quantile plots comparing the distributions of summary statistics for the edge-typed trees belonging to the original simulated distribution (horizontal axes) to the equivalent distributions computed from the edge-typed trees generated by the stochastic mapping algorithm (vertical axes). The statistic Count<sub><italic>i</italic>→<italic>j</italic></sub> represents the number of transitions from type <italic>i</italic> to type <italic>j</italic> recorded by the edge-typed tree, while Length<sub><italic>i</italic></sub> represents the total edge length associated with type <italic>i</italic>.</p></caption><graphic xlink:href="EMS201624-f002"/></fig><fig id="F3" position="float"><label>Fig. 3</label><caption><p>Comparisons between empirical quantiles of distributions of type-specific population sizes derived from trajectories generated by direct simulation and those generating using the particle filter, averaging over a broad family of three-type multi-type models. Each panel shows an overlaid series of quantile-quantile plots comparing population size quantiles (10% through to 90%) for a type-specific subpopulation at a 51 evenly-spaced times spanning the simulation period. The close proximity of all points to the dashed diagonal indicates equivalence between the sample distributions, which we expect for a correct implementation.</p></caption><graphic xlink:href="EMS201624-f003"/></fig><fig id="F4" position="float"><label>Fig. 4</label><caption><title>Joint inference of phylogenetic tree with ancestral host types and host-specific epidemic trajectories indicating the timing and frequency of MERS camel to human spillover events.</title><p>(a) A maximum clade credibility (MCC) summary from the dated phylogeny posterior with most highly probable host types at internal nodes marked. (b) Marginal posterior of infected host population size dynamics sampled using our particle filtering approach, with the thick central lines representing the median and the bounds of the shaded areas representing the 2.5% and 97.5% quantiles of the marginal host-specific infected population size posterior at each time point. (c) Equivalent visualization of infected host trajectories simulated naively from the inferred model parameters, illustrating the importance of the tree in recovering infection dynamics. (d) Marginal posteriors of spillover events present on the tree (i.e. ancestral to included samples) and present in the larger population since 2011.</p></caption><graphic xlink:href="EMS201624-f004"/></fig><table-wrap id="T1" orientation="portrait" position="float"><label>Table 1</label><caption><title>Meanings of mathematical symbols used in this paper.</title></caption><table frame="hsides" rules="groups"><thead><tr><th valign="top" align="center" style="border-top: 1px solid #ffffff">Symbol</th><th valign="top" align="left" style="border-top: 1px solid #ffffff;border-left: 1px solid #000000">Meaning</th></tr></thead><tbody><tr><td valign="top" align="center" style="border-top: 1px solid #000000"><italic>d</italic></td><td valign="top" align="left" style="border-top: 1px solid #000000;border-left: 1px solid #000000">Number of types in multi-type model</td></tr><tr><td valign="top" align="center"><italic>T</italic></td><td valign="top" align="left" style="border-left: 1px solid #000000">Duration of the multi-type birth-death process</td></tr><tr><td valign="top" align="center"><italic>X</italic><sub><italic>i</italic></sub>,<italic>Y</italic><sub><italic>i</italic></sub></td><td valign="top" align="left" style="border-left: 1px solid #000000">Individual and sample of type <italic>i</italic></td></tr><tr><td valign="top" align="center"><italic>f</italic><sub><italic>i</italic></sub></td><td valign="top" align="left" style="border-left: 1px solid #000000">Probability of starting individual being of type <italic>i</italic></td></tr><tr><td valign="top" align="center"><italic>i</italic><sub>0</sub></td><td valign="top" align="left" style="border-left: 1px solid #000000">Starting individual type</td></tr><tr><td valign="top" align="center">λ<sub><italic>ij</italic></sub></td><td valign="top" align="left" style="border-left: 1px solid #000000">Birth rate from type <italic>i</italic> to type <italic>j</italic></td></tr><tr><td valign="top" align="center"><italic>m<sub>ij</sub></italic></td><td valign="top" align="left" style="border-left: 1px solid #000000">Migration rate from <italic>i</italic> to <italic>j</italic></td></tr><tr><td valign="top" align="center"><italic>μ</italic><sub><italic>i</italic></sub></td><td valign="top" align="left" style="border-left: 1px solid #000000">Death rate from type <italic>i</italic></td></tr><tr><td valign="top" align="center"><italic>ψ</italic><sub><italic>i</italic></sub></td><td valign="top" align="left" style="border-left: 1px solid #000000">Sampling rate for type <italic>i</italic></td></tr><tr><td valign="top" align="center"><italic>r</italic><sub><italic>i</italic></sub></td><td valign="top" align="left" style="border-left: 1px solid #000000">Sample removal probability for type <italic>i</italic></td></tr><tr><td valign="top" align="center"><inline-formula><mml:math id="M90"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>ρ</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula></td><td valign="top" align="left" style="border-left: 1px solid #000000">Probabilities of synchronous sampling of type <italic>i</italic></td></tr><tr><td valign="top" align="center"><inline-formula><mml:math id="M91"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:mrow><mml:mo stretchy="true">→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula></td><td valign="top" align="left" style="border-left: 1px solid">Times of synchronous sampling of type <italic>i</italic></td></tr><tr><td valign="top" align="center">ℰ</td><td valign="top" align="left" style="border-left: 1px solid">Complete population trajectory</td></tr><tr><td valign="top" align="center">𝒮</td><td valign="top" align="left" style="border-left: 1px solid">Set of types and times of all generated samples</td></tr><tr><td valign="top" align="center">𝒯</td><td valign="top" align="left" style="border-left: 1px solid">Tip-typed phylogeny relating sampled individuals</td></tr><tr><td valign="top" align="center">𝒯<italic><sub>C</sub></italic></td><td valign="top" align="left" style="border-left: 1px solid">Edge-typed phylogeny relating sampled individuals</td></tr><tr><td valign="top" align="center">ϵ<sub>1</sub>, ϵ<sub>2</sub> …</td><td valign="top" align="left" style="border-left: 1px solid #000000">Events in a population trajectory</td></tr><tr><td valign="top" align="center"><italic>R</italic></td><td valign="top" align="left" style="border-left: 1px solid">Set of all possible reactions in multi-type birth-death model</td></tr><tr><td valign="top" align="center"><italic>t</italic><sub><italic>ϵ</italic></sub>,<italic>r</italic><sub><italic>ϵ</italic></sub></td><td valign="top" align="left" style="border-left: 1px solid #000000">Time and reaction associated with event <italic>ϵ</italic></td></tr><tr><td valign="top" align="center"><italic>N</italic><sub><italic>i</italic></sub> (<italic>t</italic>)</td><td valign="top" align="left" style="border-left: 1px solid #000000">Size of population associated with type <italic>i</italic> at time <italic>t</italic></td></tr><tr><td valign="top" align="center"><italic>K</italic><sub><italic>i</italic></sub> (<italic>t</italic>)</td><td valign="top" align="left" style="border-left: 1px solid #000000">Number of lineages of type <italic>i</italic> extant in 𝒯<sub><italic>c</italic></sub> at time <italic>t</italic></td></tr><tr><td valign="top" align="center"><italic>S</italic><sub><italic>i</italic></sub> (<italic>t</italic>)</td><td valign="top" align="left" style="border-left: 1px solid #000000">Number of samples of type <italic>i</italic> in 𝒮 at or before time <italic>t</italic></td></tr><tr><td valign="top" align="center"><italic>η</italic></td><td valign="top" align="left" style="border-left: 1px solid #000000">Set of multi-type birth-death model parameters</td></tr><tr><td valign="top" align="center"><italic>σ</italic></td><td valign="top" align="left" style="border-left: 1px solid #000000">Set of nucleotide substitution model parameters</td></tr><tr><td valign="top" align="center">𝒜</td><td valign="top" align="left" style="border-left: 1px solid #000000">Aligned set of nucleotide sequences</td></tr><tr><td valign="top" align="center"><italic>V</italic> (<italic>e,t</italic>)</td><td valign="top" align="left" style="border-left: 1px solid #000000">Unknown type at edge <italic>e</italic> and time <italic>t</italic> on tree 𝒯</td></tr><tr><td valign="top" align="center"><italic>𝒯</italic><sub>↓</sub> (<italic>e,t</italic>)</td><td valign="top" align="left" style="border-left: 1px solid #000000">Subtree below edge <italic>e</italic> at time <italic>t</italic> on tree 𝒯</td></tr><tr><td valign="top" align="center"><italic>𝒯</italic><sub>↑</sub>(<italic>e,t</italic>)</td><td valign="top" align="left" style="border-left: 1px solid #000000">Tree after pruning below edge <italic>e</italic> at time <italic>t</italic> on 𝒯</td></tr><tr><td valign="top" align="center"><inline-formula><mml:math id="M92"><mml:mrow><mml:msubsup><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td><td valign="top" align="left" style="border-left: 1px solid #000000">Probability P(𝒯<sub>↓</sub>(<italic>e,t</italic>)|<italic>V</italic> (<italic>e,t</italic>) = <italic>i</italic>,<italic>η</italic>)</td></tr><tr><td valign="top" align="center"><inline-formula><mml:math id="M93"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td><td valign="top" align="left" style="border-left: 1px solid #000000">Probability P(𝒯<sub>↑</sub>(<italic>e,t</italic>),<italic>V</italic> (<italic>e,t</italic>) = <italic>i</italic>|<italic>η</italic></td></tr><tr><td valign="top" align="center"><inline-formula><mml:math id="M94"><mml:mrow><mml:msubsup><mml:mi>π</mml:mi><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td><td valign="top" align="left" style="border-left: 1px solid">Probability <italic>P</italic>(<italic>V</italic> (<italic>e,t</italic>) = <italic>i</italic>|(𝒯, <italic>η</italic>)</td></tr><tr><td valign="top" align="center"><inline-formula><mml:math id="M95"><mml:mrow><mml:msubsup><mml:mi>Q</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td><td valign="top" align="left" style="border-left: 1px solid #000000"><italic>i</italic> to <italic>j</italic> transition rate at <italic>e</italic>, <italic>t</italic> in stochastic mapping (SM)</td></tr><tr><td valign="top" align="center"><inline-formula><mml:math id="M96"><mml:mrow><mml:msubsup><mml:mi>W</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula></td><td valign="top" align="left" style="border-left: 1px solid #000000">Transition prob. from <italic>i</italic> to <italic>j</italic>, <italic>k</italic> at node below <italic>e</italic> in SM</td></tr><tr><td valign="top" align="center"><italic>f</italic><sub><italic>r</italic></sub> (<italic>t</italic>)</td><td valign="top" align="left" style="border-left: 1px solid #000000">Prob. that <italic>r</italic> effects the observed change in 𝒯<sub><italic>C</italic></sub> at <italic>t</italic></td></tr><tr><td valign="top" align="center"><italic>A</italic><sub><italic>r</italic></sub>(<italic>t</italic>)</td><td valign="top" align="left" style="border-left: 1px solid #000000">Propensity of reaction <italic>r</italic> at time <italic>t</italic> given <italic>N</italic>(<italic>t</italic>)</td></tr><tr><td valign="top" align="center"><italic>𝒪</italic></td><td valign="top" align="left" style="border-left: 1px solid">Set of events in ℰ observable in 𝒯<italic><sub>C</sub></italic></td></tr><tr><td valign="top" align="center"><italic>𝒰</italic></td><td valign="top" align="left" style="border-left: 1px solid">Compliment of 𝒪</td></tr><tr><td valign="top" align="center"><italic>R</italic>(<italic>t</italic><sub><italic>ϵ</italic></sub>)</td><td valign="top" align="left" style="border-left: 1px solid #000000">Set of reactions compatible with 𝒯<italic><sub>C</sub></italic> at event time <italic>t</italic><sub><italic>ϵ</italic></sub></td></tr><tr><td valign="top" align="center">ℰ<sub>1</sub>,…, ℰ<sub><italic>L</italic></sub></td><td valign="top" align="left" style="border-left: 1px solid #000000">Partitioning of trajectory ℰ at event times in 𝒪</td></tr><tr><td valign="top" align="center"><italic>w</italic><sub><italic>l</italic></sub> (ℰ<sub><italic>l</italic></sub>)</td><td valign="top" align="left" style="border-left: 1px solid #000000">Importance weight of partial trajectory ℰ<sub><italic>l</italic></sub></td></tr><tr><td valign="top" align="center" style="border-bottom: 1px solid"><italic>P</italic>*(ℰ<sub><italic>l</italic></sub>| ℰ<sub><italic>l</italic></sub> <sub>−1</sub>)</td><td valign="top" align="left" style="border-left: 1px solid #000000;border-bottom: 1px solid">Importance distribution for partial trajectory ℰ<sub><italic>l</italic></sub></td></tr></tbody></table></table-wrap><table-wrap id="T2" orientation="portrait" position="float"><label>Table 2</label><caption><title>Parameter priors used in the analysis of the MERS-CoV data. Subscripts <italic>i</italic> and <italic>j</italic> specify host types selected from the possible values (Camel, Human). The variable <italic>d</italic><sub><italic>s</italic></sub> represents the duration in years between the first and last samples in the dataset. (Note that although priors are shared between types in this analysis, independent type-specific rates were estimated.)</title></caption><table frame="void" rules="groups"><thead><tr><th valign="top" align="left">Parameter</th><th valign="top" align="left">Unit</th><th valign="top" align="left">Value/Prior distribution</th></tr></thead><tbody><tr><td valign="top" align="left" style="border-top: 1px solid #000000"><italic>R</italic><sub><italic>ii</italic></sub></td><td valign="top" align="left" style="border-top: 1px solid">—</td><td valign="top" align="left" style="border-top: 1px solid #000000">LogNorm(0, 0.5)</td></tr><tr><td valign="top" align="left"><italic>R</italic><sub><italic>ij</italic></sub> (<italic>i</italic> ≠ <italic>j</italic>)</td><td valign="top" align="left">—</td><td valign="top" align="left">Exp(1)</td></tr><tr><td valign="top" align="left"><italic>δ</italic><sub><italic>i</italic></sub></td><td valign="top" align="left">Year<sup>−1</sup></td><td valign="top" align="left">LogNorm(3, 0.5)</td></tr><tr><td valign="top" align="left"><italic>s</italic><sub><italic>i</italic></sub></td><td valign="top" align="left">—</td><td valign="top" align="left">Unif(0, 0.1)</td></tr><tr><td valign="top" align="left"><italic>r</italic><sub><italic>i</italic></sub></td><td valign="top" align="left">—</td><td valign="top" align="left">1</td></tr><tr><td valign="top" align="left"><italic>T</italic></td><td valign="top" align="left">Year</td><td valign="top" align="left">LogUnif(<italic>d</italic><sub><italic>s</italic></sub>, 20)</td></tr></tbody></table></table-wrap></floats-group></article>